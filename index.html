<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>PaperStudio - 打印纸设计工具</title>
    <link href="./static/icons.min.css" rel="stylesheet" />
    <link href="./static/coloris.min.css" rel="stylesheet" />
    <link href="./static/toastify.min.css" rel="stylesheet" />
    <script src="./static/tailwindcss.js"></script>
    <script src="./static/fabric.min.js"></script>
    <script src="./static/jspdf.umd.min.js"></script>
    <script src="./static/svg2pdf.umd.min.js"></script>
    <script src="./static/opentype.min.js"></script>
    <script src="./static/hotkeys-js.min.js"></script>
    <script src="./static/toastify-js.js"></script>
    <script src="./static/coloris.min.js"></script>
    <script src="./static/xlsx.full.min.js"></script>
    <script src="./static/idb-keyval.umd.js"></script>
    <script src="./static/bwip-js.min.js"></script>
    <link rel="preload" href="./static/SourceHanSerifCN-Bold.ttf" as="font" type="font/ttf" crossorigin />
    <style>
      /* 基础滚动条隐藏 */
      .no-scrollbar::-webkit-scrollbar {
        display: none;
      }

      .no-scrollbar {
        -ms-overflow-style: none;
        scrollbar-width: none;
      }

      /* 自定义滚动条样式 */
      .custom-scrollbar::-webkit-scrollbar {
        width: 6px;
        height: 6px;
      }

      .custom-scrollbar::-webkit-scrollbar-track {
        background: transparent;
      }

      .custom-scrollbar::-webkit-scrollbar-thumb {
        background-color: #cbd5e1;
        border-radius: 3px;
      }

      .custom-scrollbar::-webkit-scrollbar-thumb:hover {
        background-color: #94a3b8;
      }

      /* UI 交互状态 */
      .tool-btn.active {
        background-color: #fee2e2;
        color: #e11d48;
        border-color: #e11d48;
      }

      /* 画布区域背景 */
      #scrollContainer {
        background-image: radial-gradient(#ddd 1px, transparent 1px);
        background-size: 20px 20px;
        display: block;
        padding: 0px 20px 0px 40px;
      }

      #zoomViewport {
        margin: 40px auto 20px;
        transform-origin: center;
        overflow: hidden;
        border-radius: 2px;
        box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
      }

      .layer-item[draggable="true"] {
        cursor: grab;
      }
      .layer-item[draggable="true"]:active {
        cursor: grabbing;
      }
      .layer-item.dragging {
        opacity: 0.5;
        background-color: #f3f4f6;
        border: 2px dashed #cbd5e1;
      }
      /* 禁止背景层拖拽 */
      .layer-item.no-drag {
        cursor: default;
      }
      /* 模态框与卡片 */
      .modal-backdrop {
        background-color: rgba(0, 0, 0, 0.6);
        backdrop-filter: blur(4px);
      }

      .template-card:hover {
        transform: translateY(-2px);
        box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
      }

      /* 光标状态 */
      .canvas-container.grabbing-mode canvas {
        cursor: grabbing !important;
      }

      .canvas-container.grab-mode canvas {
        cursor: grab !important;
      }

      /* 紧凑型表单控件 */
      .compact-input {
        font-size: 12px;
        padding: 4px 6px;
        height: 28px;
      }

      .compact-label {
        color: #6b7280;
        margin-bottom: 2px;
        display: flex;
        column-gap: 5px;
        align-items: center;
      }

      /* 样式按钮 */
      .style-btn {
        width: 28px;
        height: 28px;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .style-btn.active {
        background-color: #e5e7eb;
        font-weight: bold;
        color: #000;
      }

      /* 下拉菜单 */
      .dropdown:hover .dropdown-menu {
        display: block;
      }

      .dropdown-menu {
        display: none;
        position: absolute;
        background-color: white;
        box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
        border: 1px solid #e5e7eb;
        border-radius: 0.5rem;
        z-index: 50;
        padding: 0.5rem;
        top: 100%;
        left: 0;
        width: 120px;
      }

      /* 表格编辑器 */
      .table-editor-grid {
        border-collapse: collapse;
        width: 100%;
      }

      .table-editor-grid td {
        border: 1px solid #cbd5e1;
        min-width: 60px;
        height: 44px;
        text-align: center;
        cursor: text;
        padding: 4px;
        font-size: 12px;
        color: #0f172a;
        transition: background-color 0.15s ease;
      }

      .table-editor-grid td.selected {
        outline: 2px solid #f97316;
        outline-offset: -2px;
        box-shadow: inset 0 0 0 1px rgba(249, 115, 22, 0.3);
      }

      .table-editor-grid td:focus {
        outline: 2px solid #2563eb;
        outline-offset: -2px;
      }

      .table-style-btn {
        border: 1px solid #e2e8f0;
        border-radius: 0.375rem;
        width: 32px;
        height: 32px;
        display: flex;
        align-items: center;
        justify-content: center;
        background: #fff;
        transition: all 0.15s ease;
      }

      .table-style-btn.active {
        background: #fee2e2;
        border-color: #f87171;
        color: #b91c1c;
        font-weight: 600;
      }
      /* 表格编辑器网格样式 */
      .table-editor-grid td {
        border: 1px solid #cbd5e1;
        min-width: 60px; /* 最小宽度，防止太扁 */
        cursor: text;
        padding: 4px;
        position: relative;
        transition: background-color 0.1s;
      }

      /* 选中高亮 */
      .table-editor-grid td.selected {
        background-color: rgba(59, 130, 246, 0.15) !important;
        box-shadow: inset 0 0 0 2px #3b82f6;
        z-index: 10;
      }

      .table-editor-grid td:focus {
        outline: none;
        background-color: #fff;
        box-shadow: inset 0 0 0 2px #2563eb;
        z-index: 20;
      }

      /* 悬浮工具栏 */
      #tableFloatMenu {
        pointer-events: auto;
        will-change: top, left;
      }

      .tool-icon-btn {
        width: 26px;
        height: 26px;
        display: flex;
        align-items: center;
        justify-content: center;
        border-radius: 4px;
        color: #475569;
        transition: all 0.2s;
        border: 1px solid transparent;
      }

      .tool-icon-btn:hover:not(:disabled) {
        background-color: #f1f5f9;
        color: #0f172a;
        border-color: #cbd5e1;
      }

      .tool-icon-btn:active:not(:disabled) {
        background-color: #e2e8f0;
      }

      .tool-icon-btn:disabled {
        opacity: 0.3;
        cursor: not-allowed;
        color: #94a3b8;
      }

      /* 标尺样式 */
      .ruler-canvas {
        position: absolute;
        background-color: #f8fafc;
        z-index: 40;
        pointer-events: none;
      }

      #ruler-h {
        top: 0px;
        left: 20px;
        width: calc(100% - 20px);
        height: 20px;
        border-bottom: 1px solid #cbd5e1;
      }

      #ruler-v {
        left: 0;
        width: 20px;
        top: 20px;
        height: calc(100% - 20px);
        border-right: 1px solid #cbd5e1;
      }

      #ruler-corner {
        position: absolute;
        left: 0;
        top: 0;
        width: 20px;
        height: 20px;
        background: #ffffff;
        z-index: 41;
        border-right: 1px solid #cbd5e1;
        border-bottom: 1px solid #cbd5e1;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 8px;
        color: #64748b;
        font-weight: bold;
      }
      .editable-num {
        width: 2em;
        background: transparent;
        text-align: center;
        padding: 0;
      }
      .editable-num:focus {
        outline: none;
      }
      .editable-num::-webkit-inner-spin-button,
      .editable-num::-webkit-outer-spin-button {
        -webkit-appearance: none;
        margin: 0;
      }
      *:focus,
      *:focus-visible {
        outline: none !important;
        box-shadow: none !important;
        border-color: transparent;
      }

      input:focus,
      select:focus,
      textarea:focus {
        border-color: #e11d48 !important;
      }

      @font-face {
        font-family: "SourceHanSerifCN-Bold";
        src: url("./static/SourceHanSerifCN-Bold.ttf") format("truetype");
        font-weight: normal;
        font-style: normal;
        font-display: swap;
      }

      /* ========================================= */
      /* 打印专用样式 */
      /* ========================================= */

      #printContainer {
        display: none;
      }

      @media print {
        body > *:not(#printContainer) {
          display: none !important;
        }

        #printContainer {
          display: block !important;
          position: absolute;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          z-index: 99999;
          background: white;
        }

        #printContainer img {
          width: 100%;
          height: auto;
          display: block;
        }
      }
    </style>
  </head>

  <body class="bg-gray-50 h-screen flex flex-col text-slate-700 font-sans overflow-hidden">
    <div id="welcomeModal" class="fixed inset-0 z-50 flex items-center justify-center modal-backdrop transition-opacity duration-300">
      <div class="bg-white w-[850px] h-[550px] rounded-2xl shadow-2xl flex overflow-hidden">
        <div class="w-1/3 bg-slate-900 text-white p-8 flex flex-col justify-between relative overflow-hidden">
          <div class="relative z-10">
            <div class="flex items-center gap-3 mb-8">
              <div class="bg-red-600 text-white p-2 rounded-lg">
                <i class="ph ph-article text-3xl"></i>
              </div>
              <div>
                <h1 class="text-xl font-bold tracking-tight">PaperStudio</h1>
                <p class="text-slate-400 text-xs">简单的打印纸设计工具</p>
              </div>
            </div>
            <div class="space-y-4">
              <button onclick="App.templates.load('blank_a4')" class="w-full py-3 px-4 bg-red-600 hover:bg-red-700 rounded-xl flex items-center gap-3 transition group">
                <i class="ph ph-plus-circle text-xl"></i>
                <span class="font-medium">新建空白纸</span>
              </button>
              <button onclick="document.getElementById('projectImportInput').click()" class="w-full py-3 px-4 bg-slate-800 hover:bg-slate-700 rounded-xl flex items-center gap-3 transition">
                <i class="ph ph-folder-open text-xl text-slate-400"></i>
                <span class="font-medium">打开纸文件</span>
              </button>
            </div>
          </div>
          <a
            href="https://github.com/jingguanzhang/PaperStudio"
            target="_blank"
            class="relative z-20 flex items-center gap-2 text-slate-500 hover:text-white transition-colors cursor-pointer w-fit group">
            <i class="ph ph-github-logo text-2xl group-hover:scale-110 transition-transform"></i>
            <span class="text-xs font-medium">Github</span>
          </a>
          <i class="ph ph-scroll absolute -bottom-5 -right-10 text-[200px] text-slate-800 opacity-50 rotate-12"></i>
        </div>
        <div class="w-2/3 p-8 bg-gray-50 flex flex-col">
          <h2 class="text-lg font-bold text-slate-800 mb-4 flex justify-between items-center">从模板开始</h2>
          <div id="templateGrid" class="grid grid-cols-2 gap-4 overflow-y-auto pr-2 custom-scrollbar"></div>
        </div>
      </div>
    </div>
    <div id="contactModal" class="hidden fixed inset-0 z-[60] flex items-center justify-center modal-backdrop transition-opacity duration-200">
      <div class="bg-white rounded-xl shadow-2xl p-6 w-[320px] text-center relative transform transition-all scale-100">
        <button
          onclick="App.ui.hideModal('contactModal')"
          class="absolute top-3 right-3 text-slate-400 hover:text-slate-600 w-8 h-8 flex items-center justify-center rounded-full hover:bg-gray-100 transition">
          <i class="ph ph-x text-lg"></i>
        </button>

        <h3 class="text-lg font-bold text-slate-800 mb-1">联系开发者</h3>

        <div class="bg-white p-2 rounded-xl border border-gray-100 shadow-inner inline-block mb-4">
          <img src="./static/addme.jpg" alt="联系作者" class="w-48 h-48 object-contain rounded-lg" />
        </div>

        <div class="space-y-1">
          <p class="text-sm font-medium text-slate-700">扫码添加微信</p>
          <p class="text-sm text-slate-400">反馈建议 · 交流</p>
        </div>
      </div>
    </div>
    <div id="permissionModal" class="hidden fixed inset-0 z-[70] flex items-center justify-center modal-backdrop transition-opacity duration-200">
      <div class="bg-white rounded-xl shadow-2xl p-6 w-[400px] text-center relative transform transition-all scale-100">
        <div class="w-14 h-14 bg-orange-50 text-orange-500 rounded-full flex items-center justify-center mx-auto mb-4 border border-orange-100">
          <i class="ph ph-lock-key text-3xl"></i>
        </div>

        <h3 class="text-xl font-bold text-slate-800 mb-2">需要访问权限</h3>
        <p class="text-sm text-slate-500 mb-1">为了读取数据源文件，浏览器需要您的确认。</p>
        <p class="text-xs font-mono bg-gray-100 text-gray-600 py-1 px-2 rounded inline-block mb-6 max-w-full truncate" id="permFileName">filename.xlsx</p>

        <div class="flex gap-3 justify-center">
          <button id="permCancelBtn" class="px-5 py-2.5 rounded-lg border border-gray-300 text-slate-600 hover:bg-gray-50 text-sm font-medium transition">取消</button>
          <button id="permGrantBtn" class="px-5 py-2.5 rounded-lg bg-red-600 text-white hover:bg-red-700 text-sm font-bold shadow-md shadow-red-100 transition flex items-center gap-2">
            <i class="ph ph-check-circle"></i> 授予权限
          </button>
        </div>
      </div>
    </div>
    <div id="sponsorModal" class="hidden fixed inset-0 z-[60] flex items-center justify-center modal-backdrop transition-opacity duration-200">
      <div class="bg-white rounded-xl shadow-2xl p-6 w-[320px] text-center relative transform transition-all scale-100">
        <button
          onclick="App.ui.hideModal('sponsorModal')"
          class="absolute top-3 right-3 text-slate-400 hover:text-slate-600 w-8 h-8 flex items-center justify-center rounded-full hover:bg-gray-100 transition">
          <i class="ph ph-x text-lg"></i>
        </button>

        <div class="w-12 h-12 bg-red-50 rounded-full flex items-center justify-center mx-auto mb-3">
          <i class="ph ph-heart text-2xl text-red-500"></i>
        </div>

        <h3 class="text-lg font-bold text-slate-800 mb-1">感谢支持</h3>
        <div class="p-2 rounded-xl border border-orange-100 shadow-inner inline-block mb-4">
          <img src="./static/support.jpg" alt="微信收款码" class="w-48 h-48 object-contain rounded-lg mix-blend-multiply" />
        </div>

        <div class="space-y-1">
          <p class="text-sm font-medium text-slate-700">如果觉得工具好用</p>
          <p class="text-sm text-slate-400">欢迎请作者喝杯咖啡，激励持续更新</p>
        </div>
      </div>
    </div>
    <div id="tableModal" class="hidden fixed inset-0 z-50 items-center justify-center modal-backdrop">
      <div class="bg-white w-[98vw] h-[95vh] rounded-2xl shadow-2xl flex flex-col overflow-hidden relative">
        <div class="flex items-center justify-between px-6 py-4 border-b border-gray-100 z-20 bg-white shadow-sm shrink-0">
          <div>
            <h3 class="text-lg font-bold text-slate-800 flex items-center gap-2"><i class="ph ph-table text-red-600"></i> 表格编辑器</h3>
            <p class="text-xs text-slate-400 mt-0.5">拖动分割线调整宽高，选中单元格右键或使用悬浮菜单编辑</p>
          </div>
          <div class="flex items-center gap-2 bg-gray-50 rounded-lg px-3 py-1 border border-gray-200">
            <i class="ph ph-minus text-xs text-gray-400 cursor-pointer hover:text-slate-700" onclick="App.tableEditor.changeZoom(-0.1)"></i>
            <input
              type="range"
              id="tableEditorZoom"
              min="0.2"
              max="3"
              step="0.1"
              value="1"
              class="accent-red-600 h-1.5 w-24 bg-gray-200 rounded-lg appearance-none cursor-pointer"
              oninput="App.tableEditor.setZoom(this.value)"
              title="编辑器视图缩放" />
            <i class="ph ph-plus text-xs text-gray-400 cursor-pointer hover:text-slate-700" onclick="App.tableEditor.changeZoom(0.1)"></i>
            <span id="tableEditorZoomVal" class="text-xs font-mono text-slate-600 w-10 text-center font-bold">100%</span>
          </div>
          <button onclick="App.tableEditor.close()" class="p-2 rounded-full hover:bg-gray-100 text-gray-400 hover:text-gray-600 transition">
            <i class="ph ph-x text-xl"></i>
          </button>
        </div>

        <div class="flex-1 overflow-auto bg-slate-50 flex items-center justify-center p-16 relative select-none cursor-default" id="tableEditArea">
          <div id="tableWrapper" class="m-auto relative group shadow-xl bg-white transition-all duration-200 ring-1 ring-slate-900/5">
            <button
              onclick="App.tableEditor.addCR('row', 'top')"
              class="absolute -top-5 left-0 w-full h-5 flex items-center justify-center text-slate-300 hover:text-red-500 hover:bg-red-50/80 opacity-0 group-hover:opacity-100 transition-all duration-200 z-10">
              <i class="ph ph-plus-circle text-xl"></i>
            </button>
            <button
              onclick="App.tableEditor.addCR('row', 'bottom')"
              class="absolute -bottom-5 left-0 w-full h-5 flex items-center justify-center text-slate-300 hover:text-red-500 hover:bg-red-50/80 opacity-0 group-hover:opacity-100 transition-all duration-200 z-10">
              <i class="ph ph-plus-circle text-xl"></i>
            </button>
            <button
              onclick="App.tableEditor.addCR('col', 'left')"
              class="absolute top-0 -left-5 h-full w-5 flex items-center justify-center text-slate-300 hover:text-red-500 hover:bg-red-50/80 opacity-0 group-hover:opacity-100 transition-all duration-200 z-10">
              <i class="ph ph-plus-circle text-xl"></i>
            </button>
            <button
              onclick="App.tableEditor.addCR('col', 'right')"
              class="absolute top-0 -right-5 h-full w-5 flex items-center justify-center text-slate-300 hover:text-red-500 hover:bg-red-50/80 opacity-0 group-hover:opacity-100 transition-all duration-200 z-10">
              <i class="ph ph-plus-circle text-xl"></i>
            </button>

            <table class="table-editor-grid border-collapse bg-white" id="tableEditorTable">
              <tbody id="tableGridBody"></tbody>
            </table>
          </div>

          <div
            id="tableFloatMenu"
            class="hidden absolute z-50 bg-white text-slate-700 rounded-lg shadow-2xl p-1.5 flex items-center gap-2 transform -translate-x-1/2 -translate-y-full mb-3 transition-all duration-150 border border-gray-200 ring-1 ring-black/5 font-sans">
            <div class="border-r border-gray-200 pr-2 hidden" id="floatDataBindWrapper">
              <select id="floatDataBind" class="h-7 bg-gray-50 border border-gray-300 rounded text-xs text-slate-700 focus:outline-none focus:border-red-500 w-24 hover:bg-gray-100">
                <option value="">不绑定数据</option>
              </select>
            </div>
            <!-- 字体选择 -->
            <div class="border-r border-gray-200 pr-2">
              <select
                id="floatFontFamily"
                onclick="App.loadLocalFonts()"
                class="h-7 bg-gray-50 border border-gray-300 rounded text-xs text-slate-700 focus:outline-none focus:border-red-500 w-24 hover:bg-gray-100">
                <option value="SourceHanSerifCN-Bold">思源宋体</option>
                <option value="SimSun">宋体</option>
                <option value="KaiTi">楷体</option>
                <option value="SimHei">黑体</option>
                <option value="Arial">Arial</option>
              </select>
            </div>

            <!-- 字号与加粗 -->
            <div class="flex gap-1 border-r border-gray-200 pr-2 items-center">
              <input
                type="number"
                id="floatFontSize"
                class="w-10 h-7 bg-gray-50 border border-gray-300 rounded text-center text-xs text-slate-700 focus:outline-none focus:border-red-500"
                min="9"
                max="72"
                title="字号" />
              <button id="floatBoldBtn" class="p-1.5 hover:bg-gray-100 rounded text-slate-500 hover:text-slate-900 transition">
                <i class="ph ph-text-b"></i>
              </button>
            </div>

            <!-- 边框设置 -->
            <div class="flex gap-1 border-r border-gray-200 pr-2 items-center">
              <input
                type="number"
                id="floatBorderWidth"
                class="w-10 h-7 bg-gray-50 border border-gray-300 rounded text-center text-xs text-slate-700 focus:outline-none focus:border-red-500"
                min="0"
                max="10"
                step="0.5"
                title="边框宽度" />
              <div class="relative w-7 h-7 rounded hover:bg-gray-100 flex items-center justify-center group/picker border border-transparent hover:border-gray-200" title="边框颜色">
                <input type="color" id="floatBorderColorInput" class="absolute inset-0 w-full h-full opacity-0 cursor-pointer z-10" />
                <i class="ph ph-square text-slate-400 group-hover/picker:text-slate-600"></i>
                <div id="floatBorderColorInd" class="absolute bottom-1 right-1 w-2 h-2 rounded-full border border-gray-300 bg-slate-400 pointer-events-none"></div>
              </div>
            </div>

            <div class="flex gap-1 border-r border-gray-200 pr-2 items-center">
              <div
                class="relative w-7 h-7 rounded hover:bg-gray-100 flex items-center justify-center group/picker border border-transparent hover:border-gray-200"
                title="背景颜色"
                onclick="document.getElementById('floatBgInput').click();">
                <input type="text" id="floatBgInput" class="absolute inset-0 w-full h-full opacity-0 cursor-pointer z-10" data-coloris value="#ffffff" />
                <i class="ph ph-paint-bucket text-slate-400 group-hover/picker:text-slate-600"></i>
                <div id="floatBgIndicator" class="absolute bottom-1 right-1 w-2 h-2 rounded-full border border-gray-300 bg-white pointer-events-none"></div>
              </div>

              <div class="relative w-7 h-7 rounded hover:bg-gray-100 flex items-center justify-center group/picker border border-transparent hover:border-gray-200" title="文字颜色">
                <input type="color" id="floatTextInput" class="absolute inset-0 w-full h-full opacity-0 cursor-pointer z-10" />
                <i class="ph ph-text-t text-slate-400 group-hover/picker:text-slate-600"></i>
                <div id="floatTextIndicator" class="absolute bottom-1 right-1 w-2 h-2 rounded-full border border-gray-300 bg-slate-900 pointer-events-none"></div>
              </div>
            </div>

            <div class="flex gap-1 border-r border-gray-200 pr-2">
              <button onclick="App.tableEditor.applyStyle({align:'left'})" class="p-1.5 hover:bg-gray-100 rounded text-slate-500 hover:text-slate-900">
                <i class="ph ph-text-align-left"></i>
              </button>
              <button onclick="App.tableEditor.applyStyle({align:'center'})" class="p-1.5 hover:bg-gray-100 rounded text-slate-500 hover:text-slate-900">
                <i class="ph ph-text-align-center"></i>
              </button>
              <button onclick="App.tableEditor.applyStyle({align:'right'})" class="p-1.5 hover:bg-gray-100 rounded text-slate-500 hover:text-slate-900">
                <i class="ph ph-text-align-right"></i>
              </button>
              <button id="floatMergeBtn" class="relative flex items-center justify-center p-1.5 hover:bg-gray-100 rounded text-slate-500 hover:text-slate-900" title="合并">
                <i class="ph ph-arrows-in-line-horizontal"></i><i class="ph ph-corners-out text-[25px] absolute"></i>
              </button>
              <button id="floatSplitBtn" class="relative flex items-center justify-center p-1.5 hover:bg-gray-100 rounded text-slate-500 hover:text-slate-900" title="拆分">
                <i class="ph ph-arrows-out-line-horizontal"></i><i class="ph ph-corners-out text-[25px] absolute"></i>
              </button>
            </div>

            <div class="flex gap-1">
              <button onclick="App.tableEditor.deleteCR('row')" class="relative flex items-center justify-center p-1.5 hover:bg-gray-100 rounded text-slate-400 transition group" title="删除选中行">
                <i class="ph ph-rows text-lg"></i>
                <i class="ph ph-trash text-sm absolute -bottom-1 -right-1 rounded-full p-[1px] shadow-sm"></i>
              </button>

              <button onclick="App.tableEditor.deleteCR('col')" class="relative flex items-center justify-center p-1.5 hover:bg-gray-100 rounded text-slate-400 transition group" title="删除选中列">
                <i class="ph ph-columns text-lg"></i>
                <i class="ph ph-trash text-sm absolute -bottom-1 -right-1 rounded-full p-[1px] shadow-sm"></i>
              </button>
            </div>

            <div class="absolute bottom-0 left-1/2 -ml-1.5 -mb-1.5 w-3 h-3 bg-white transform rotate-45 border-r border-b border-gray-200"></div>
          </div>
        </div>

        <div class="px-6 py-4 border-t border-gray-200 bg-gray-50 flex items-center justify-between shrink-0 z-20">
          <div class="flex items-center gap-4">
            <div class="flex items-center gap-2 bg-white px-2 py-1 rounded border border-gray-200">
              <label class="text-xs text-slate-500 font-bold">行数</label>
              <input type="number" id="tableEditorRowsInput" min="1" max="100" class="w-6 h-6 text-xs text-center focus:border-red-500 focus:outline-none transition bg-transparent" />
            </div>
            <div class="flex items-center gap-2 bg-white px-2 py-1 rounded border border-gray-200">
              <label class="text-xs text-slate-500 font-bold">列数</label>
              <input type="number" id="tableEditorColsInput" min="1" max="60" class="w-6 h-6 text-xs text-center focus:border-red-500 focus:outline-none transition bg-transparent" />
            </div>
            <button id="tableDimSyncBtn" class="hidden text-xs text-red-600 hover:text-red-800 underline">刷新</button>
          </div>
          <div class="flex gap-3 ml-auto">
            <button id="tableCancelBtn" class="px-5 py-2.5 rounded-lg border border-gray-300 text-slate-700 text-sm font-medium hover:bg-white hover:border-gray-400 transition bg-white shadow-sm">
              取消
            </button>
            <button id="tableInsertBtn" class="px-6 py-2.5 rounded-lg bg-red-600 text-white text-sm font-bold hover:bg-red-700 transition shadow-md shadow-red-100 flex items-center gap-2">
              <i class="ph ph-check-circle text-lg"></i> 完成并插入
            </button>
          </div>
        </div>
      </div>
    </div>

    <input type="file" id="projectImportInput" hidden accept=".paper" />
    <input type="file" id="imgUpload" hidden accept="image/*" />
    <input type="file" id="imgReplaceInput" hidden accept="image/*" />

    <header class="h-14 bg-white border-b border-gray-200 flex items-center justify-between px-4 shadow-sm z-30 shrink-0 text-sm whitespace-nowrap">
      <div class="flex items-center gap-4">
        <div class="flex items-center gap-2 text-slate-800 cursor-pointer" onclick="App.ui.showModal('welcomeModal')">
          <i class="ph ph-scroll text-2xl text-red-600"></i>
          <span class="font-bold tracking-tight">PaperStudio</span>
        </div>
        <div class="flex items-center gap-1">
          <button
            onclick="document.getElementById('projectImportInput').click()"
            class="hover:bg-gray-100 px-2 py-1 rounded font-medium flex items-center gap-1 transition text-slate-600"
            title="打开 (Ctrl+O)">
            <i class="ph ph-folder-open text-lg"></i> 打开
          </button>
          <button onclick="App.io.saveProject()" class="hover:bg-gray-100 px-2 py-1 rounded font-medium flex items-center gap-1 transition text-slate-600" title="保存 (Ctrl+S)">
            <i class="ph ph-floppy-disk text-lg"></i> 保存
          </button>
          <div class="w-px h-4 bg-gray-300 mx-1"></div>
          <button
            id="btnUndo"
            onclick="App.history.undo()"
            disabled
            class="hover:bg-gray-100 px-2 py-1 rounded font-medium flex items-center gap-1 transition text-slate-600 disabled:opacity-40 disabled:cursor-not-allowed disabled:hover:bg-transparent"
            title="撤销 (Ctrl+Z)">
            <i class="ph ph-arrow-u-up-left text-lg"></i>
          </button>
          <button
            id="btnRedo"
            onclick="App.history.redo()"
            disabled
            class="hover:bg-gray-100 px-2 py-1 rounded font-medium flex items-center gap-1 transition text-slate-600 disabled:opacity-40 disabled:cursor-not-allowed disabled:hover:bg-transparent"
            title="重做 (Ctrl+Y)">
            <i class="ph ph-arrow-u-up-right text-lg"></i>
          </button>
        </div>
      </div>

      <div class="flex items-center gap-1">
        <div class="flex items-center hover:bg-gray-100 rounded px-1.5">
          <button onclick="App.tools.addText()" class="flex items-center gap-1 py-1.5 font-medium transition text-gray-600" title="插入文字"><i class="ph ph-text-t text-lg"></i> 文字</button>

          <div class="relative dropdown h-full">
            <button class="flex items-center justify-center px-1 py-1.5 h-full rounded-r hover:bg-gray-100 font-medium transition text-gray-600">
              <i class="ph ph-caret-down text-xs"></i>
            </button>

            <div class="dropdown-menu w28 left-[50%] -translate-x-[75%]">
              <button onclick="App.tools.addParagraph()" class="w-full text-left px-3 py-2 hover:bg-gray-100 flex items-center gap-2 text-gray-600 transition">
                <i class="ph ph-text-align-justify text-lg"></i> 段落
              </button>
              <button onclick="App.tools.addDate()" class="w-full text-left px-3 py-2 hover:bg-gray-100 flex items-center gap-2 text-gray-600 transition">
                <i class="ph ph-calendar text-lg"></i> 时间
              </button>
              <button onclick="App.tools.addPageNum()" class="w-full text-left px-3 py-2 hover:bg-gray-100 flex items-center gap-2 text-gray-600 transition">
                <i class="ph ph-hash text-lg"></i> 页码
              </button>
              <button onclick="App.tools.addSerialNumber()" class="w-full text-left px-3 py-2 hover:bg-gray-100 flex items-center gap-2 text-gray-600 transition">
                <i class="ph ph-list-numbers text-lg"></i> 序列号
              </button>
            </div>
          </div>
        </div>

        <button onclick="document.getElementById('imgUpload').click()" class="flex items-center gap-1 px-3 py-1.5 rounded hover:bg-gray-100 font-medium transition text-gray-600">
          <i class="ph ph-image text-lg"></i> 图片
        </button>

        <button onclick="App.tableEditor.open()" class="flex items-center gap-1 px-3 py-1.5 rounded hover:bg-gray-100 font-medium transition text-gray-600">
          <i class="ph ph-table text-lg"></i> 表格
        </button>
        <button onclick="App.tools.addBarcode()" class="flex items-center gap-1 px-3 py-1.5 rounded hover:bg-gray-100 font-medium transition text-gray-600">
          <i class="ph ph-barcode text-lg"></i> 条码
        </button>

        <div class="relative dropdown">
          <button class="flex items-center gap-1 px-3 py-1.5 rounded hover:bg-gray-100 font-medium transition text-gray-600">
            <i class="ph ph-shapes text-lg"></i> 图形 <i class="ph ph-caret-down"></i>
          </button>
          <div class="dropdown-menu">
            <button onclick="App.tools.addLine()" class="flex items-center gap-1 px-3 py-1.5 rounded hover:bg-gray-100 font-medium transition text-gray-600">
              <i class="ph ph-line-segment text-lg"></i> 线条
            </button>
            <button onclick="App.tools.addShape('rect')" class="w-full text-left px-2 py-2 hover:bg-gray-100 flex items-center gap-2"><i class="ph ph-rectangle"></i> 矩形</button>
            <button onclick="App.tools.addShape('circle')" class="w-full text-left px-2 py-2 hover:bg-gray-100 flex items-center gap-2"><i class="ph ph-circle"></i> 圆形</button>
            <button onclick="App.tools.addShape('triangle')" class="w-full text-left px-2 py-2 hover:bg-gray-100 flex items-center gap-2"><i class="ph ph-triangle"></i> 三角形</button>
            <button onclick="App.tools.addShape('star')" class="w-full text-left px-2 py-2 hover:bg-gray-100 flex items-center gap-2"><i class="ph ph-star"></i> 角形</button>
            <button onclick="App.tools.addShape('diamond')" class="w-full text-left px-2 py-2 hover:bg-gray-100 flex items-center gap-2"><i class="ph ph-diamond"></i> 菱形</button>
          </div>
        </div>
      </div>

      <div class="w-80 flex justify-end gap-2">
        <button
          onclick="App.ui.showModal('sponsorModal')"
          class="flex items-center gap-1.5 px-3 py-1.5 rounded-full bg-red-50 hover:bg-red-100 text-red-600 border border-red-100 transition text-xs font-bold mr-1">
          <i class="ph ph-heart-straight text-lg"></i>
          <span>支持作者</span>
        </button>
        <button onclick="App.ui.showModal('contactModal')" class="flex items-center gap-1 px-3 py-1.5 rounded hover:bg-gray-100 text-md font-medium transition text-gray-600" title="联系作者">
          <i class="ph ph-wechat-logo text-lg"></i>
        </button>
        <button onclick="App.ui.toggleFullScreen()" class="flex items-center gap-1 px-3 py-1.5 rounded hover:bg-gray-100 text-md font-medium transition text-gray-600" title="全屏模式">
          <i id="fsIcon" class="ph ph-corners-out text-lg"></i>
        </button>
        <button onclick="App.io.exportPDF()" class="bg-white border border-red-200 text-red-600 hover:bg-red-50 px-3 py-1.5 rounded flex items-center gap-1 shadow-sm transition">
          <i class="ph ph-file-pdf text-lg"></i> 导出 PDF
        </button>
        <button onclick="App.io.print()" class="bg-red-600 hover:bg-red-700 text-white px-3 py-1.5 rounded flex items-center gap-1 shadow-sm transition" title="打印 (Ctrl+P)">
          <i class="ph ph-printer text-lg"></i> 打印
        </button>
      </div>
    </header>

    <div class="flex-1 flex overflow-hidden">
      <aside class="w-64 bg-white border-r border-gray-200 flex flex-col z-20 overflow-y-auto no-scrollbar text-xs">
        <div class="p-4 space-y-6">
          <section>
            <h3 class="font-bold text-gray-400 uppercase tracking-wider mb-3 flex items-center gap-1 text-sm"><i class="ph ph-files"></i> 纸张选项</h3>
            <div class="space-y-3" id="paperOptions">
              <div class="grid grid-cols-2">
                <label class="compact-label col-span-2">纸张尺寸</label>
                <select id="paperSize" onchange="App.paper.updateSize()" class="w-full border-gray-300 rounded-md border p-2 bg-gray-50 col-span-2">
                  <option value="A3">A3 (297 × 420 mm)</option>
                  <option value="A4" selected>A4 (210 × 297 mm)</option>
                  <option value="A5">A5 (148 × 210 mm)</option>
                  <option value="B4">B4 (250 × 353 mm)</option>
                  <option value="B5">B5 (176 × 250 mm)</option>
                  <option value="Letter">Letter 美信</option>
                  <option value="Legal">Legal 美长</option>
                  <option value="16开">16开 (210 × 285 mm)</option>
                  <option value="32开">32开 (185 × 260 mm)</option>
                  <option value="方纸">方纸 (230 × 230 mm)</option>
                  <hr class="my-2 border-gray-300" />
                  <hr class="my-2 border-gray-300" />
                  <option value="CUSTOM">自定义尺寸…</option>
                </select>
                <label class="flex items-center gap-1 cursor-pointer mt-3 select-none">
                  <input type="checkbox" id="paperOrientation" class="accent-red-600 rounded scale-90" onchange="App.paper.updateSize()" />
                  <span class="text-gray-600">横向</span>
                </label>
                <label id="dualOptionWrapper" class="hidden flex items-center gap-1 cursor-pointer mt-3 select-none">
                  <input type="checkbox" id="paperDual" class="accent-red-600 rounded scale-90" onchange="App.paper.drawPaper()" />
                  <span class="text-gray-600" title="横向纸张上左右各生成一份相同内容">对开模式</span>
                </label>
              </div>
              <div id="customSizeInputs" class="grid grid-cols-2 gap-2 hidden">
                <div>
                  <label class="compact-label">宽(mm)</label>
                  <input type="number" id="customW" value="210" class="w-full compact-input border rounded" />
                </div>
                <div>
                  <label class="compact-label">高(mm)</label>
                  <input type="number" id="customH" value="297" class="w-full compact-input border rounded" />
                </div>
                <button onclick="App.paper.updateSize()" class="col-span-2 bg-gray-100 hover:bg-gray-200 py-1 rounded">应用尺寸</button>
              </div>
              <div class="grid grid-cols-2 gap-2">
                <div>
                  <label class="compact-label">上边距</label>
                  <input type="number" id="marginTop" value="25" min="0" class="w-full compact-input border border-gray-300 rounded" oninput="App.paper.drawGrid()" />
                </div>
                <div>
                  <label class="compact-label">下边距</label>
                  <input type="number" id="marginBottom" value="25" min="0" class="w-full compact-input border border-gray-300 rounded" oninput="App.paper.drawGrid()" />
                </div>
                <div>
                  <label class="compact-label">左边距</label>
                  <input type="number" id="marginLeft" value="20" min="0" class="w-full compact-input border border-gray-300 rounded" oninput="App.paper.drawGrid()" />
                </div>
                <div>
                  <label class="compact-label">右边距</label>
                  <input type="number" id="marginRight" value="20" min="0" class="w-full compact-input border border-gray-300 rounded" oninput="App.paper.drawGrid()" />
                </div>
              </div>
            </div>
          </section>
          <section>
            <div class="space-y-3">
              <div>
                <label class="compact-label">纸张类型</label>
                <select id="paperType" onchange="App.paper.changeType(this.value, true)" class="w-full border-gray-300 rounded-md border p-2 bg-gray-50">
                  <option value="blank" selected>空白纸</option>
                </select>
              </div>

              <div class="flex items-center gap-2">
                <div class="flex-1">
                  <label class="compact-label">背景颜色</label>
                  <div class="flex items-center gap-2">
                    <input type="color" id="paperBgColor" value="#ffffff" oninput="App.paper.drawGrid()" class="h-7 w-full p-0 border-0 rounded cursor-pointer" />
                    <button onclick="document.getElementById('paperBgColor').value='#ffffff'; App.paper.drawGrid()" class="px-2 py-1 bg-gray-100 hover:bg-gray-200 rounded text-xs" title="重置为白色">
                      <i class="ph ph-arrow-counter-clockwise"></i>
                    </button>
                  </div>
                </div>

                <div class="flex items-center gap-2 flex-2" data-paper-types="ruled,grid,composition,english,music,tianzige,mizige,huizige,jiugongge,dots,triangle,hexagon">
                  <div class="flex-1">
                    <label class="compact-label">线条颜色</label>
                    <input type="color" id="gridColor" value="#e11d48" class="h-7 w-full p-0 border-0 rounded cursor-pointer" oninput="App.paper.updateSettings()" />
                  </div>
                  <div class="w-16">
                    <label class="compact-label">线宽</label>
                    <input type="number" id="strokeWidth" value="1" min="0" max="5" step="0.1" class="w-full compact-input border rounded" oninput="App.paper.updateSettings()" />
                  </div>
                </div>
              </div>

              <div data-paper-types="label">
                <h3 class="font-bold text-gray-400 uppercase tracking-wider mb-3 flex items-center gap-1 text-sm"><i class="ph ph-tag"></i> 标签选项</h3>
                <div class="space-y-3">
                  <!-- 标签尺寸 -->
                  <div class="grid grid-cols-2 gap-2">
                    <div>
                      <label class="compact-label">标签宽(mm)</label>
                      <input type="number" id="labelWidth" class="w-full compact-input border rounded" oninput="App.paper.autoLayoutLabels()" />
                    </div>
                    <div>
                      <label class="compact-label">标签高(mm)</label>
                      <input type="number" id="labelHeight" class="w-full compact-input border rounded" oninput="App.paper.autoLayoutLabels()" />
                    </div>
                  </div>

                  <div id="labelLayout" class="grid grid-cols gap-2">
                    <div class="grid grid-cols-[1fr_auto_1fr] gap-2 items-end">
                      <div>
                        <label class="compact-label">横向个数(列)</label>
                        <input type="number" id="labelCols" min="1" class="w-full compact-input border rounded" oninput="App.paper.updateSettings()" />
                      </div>
                      <button
                        onclick="App.paper.calcLabelSizeFromGrid()"
                        class="h-[28px] w-[28px] bg-gray-50 hover:bg-gray-100 text-gray-600 border border-gray-200 rounded flex items-center justify-center transition mb-[1px]"
                        title="自动计算标签尺寸">
                        <i class="ph ph-arrows-out"></i>
                      </button>
                      <div>
                        <label class="compact-label">纵向个数(行)</label>
                        <input type="number" id="labelRows" min="1" class="w-full compact-input border rounded" oninput="App.paper.updateSettings()" />
                      </div>
                    </div>
                    <div class="grid grid-cols-2 gap-2">
                      <div>
                        <label class="compact-label">横向间距(mm)</label>
                        <input type="number" id="labelGapH" min="0" step="0.5" class="w-full compact-input border rounded" oninput="App.paper.updateSettings()" />
                      </div>
                      <div>
                        <label class="compact-label">纵向间距(mm)</label>
                        <input type="number" id="labelGapV" min="0" step="0.5" class="w-full compact-input border rounded" oninput="App.paper.updateSettings()" />
                      </div>
                    </div>
                  </div>

                  <div>
                    <label class="compact-label">打印份数</label>
                    <input type="number" id="labelQuantity" min="1" value="1" class="w-full compact-input border rounded" oninput="App.paper.updateSettings()" />
                  </div>

                  <div class="grid grid-cols-2 gap-2 cursor-pointer select-none">
                    <label class="flex items-center">
                      <input type="checkbox" id="fitLabelSize" class="accent-red-600 rounded scale-90" onchange="App.paper.updateSize()" />
                      <span class="compact-label mb-0 font-bold text-slate-600">单张模式</span>
                    </label>
                    <div class="flex items-center gap-2" id="showMarks">
                      <label class="flex items-center">
                        <input type="checkbox" id="showCropMarks" class="accent-red-600 rounded scale-90" onchange="App.paper.updateSettings()" />
                        <span class="compact-label mb-0 font-bold text-slate-600">显示分隔线</span>
                      </label>
                    </div>
                  </div>
                </div>
              </div>

              <div data-paper-types="ruled,english,composition">
                <div class="flex justify-between mb-1">
                  <label class="compact-label">行数</label>
                  <input type="number" id="rowCountDisplay" value="20" class="editable-num bg-gray-100" oninput="document.getElementById('rowCount').value=this.value; App.paper.updateSettings()" />
                </div>
                <input
                  type="range"
                  id="rowCount"
                  min="0"
                  max="50"
                  value="20"
                  class="w-full accent-red-600 h-1.5 bg-gray-200 rounded-lg appearance-none cursor-pointer"
                  oninput="App.paper.updateSettings()" />
              </div>

              <div data-paper-types="ruled,english,tianzige,mizige,huizige,jiugongge,grid,triangle,hexagon" class="flex items-center gap-2">
                <label class="flex items-center gap-2 cursor-pointer flex-1 select-none">
                  <input type="checkbox" id="gridDashed" class="accent-red-600 rounded scale-90" onchange="App.paper.updateSettings()" />
                  <span class="text-gray-600 compact-label mb-0">虚线</span>
                </label>
                <div class="w-16 relative">
                  <span class="compact-label">间距</span>
                  <input type="number" id="gridDashArray" value="4" min="0.1" max="20" class="w-full compact-input border rounded" oninput="App.paper.updateSettings()" />
                </div>
              </div>
              <div data-paper-types="huizige" class="grid grid-cols-2 gap-2 mt-2 border-t border-gray-200 pt-2">
                <div>
                  <label class="compact-label">回字内框宽</label>
                  <input type="number" id="huiInnerW" value="10" min="2" max="50" class="w-full compact-input border rounded" oninput="App.paper.updateSettings()" />
                </div>
                <div>
                  <label class="compact-label">回字内框高</label>
                  <input type="number" id="huiInnerH" value="10" min="2" max="50" class="w-full compact-input border rounded" oninput="App.paper.updateSettings()" />
                </div>
              </div>
              <div data-paper-types="ruled" class="grid grid-cols-2 gap-2">
                <label class="flex items-center gap-2 cursor-pointer">
                  <input type="checkbox" id="doubleFirst" class="accent-red-600 rounded scale-90" onchange="App.paper.drawGrid()" checked /><span class="text-gray-600">首行双线</span></label
                >
                <label class="flex items-center gap-2 cursor-pointer">
                  <input type="checkbox" id="doubleLast" class="accent-red-600 rounded scale-90" onchange="App.paper.drawGrid()" checked /><span class="text-gray-600">尾行双线</span></label
                >
                <label class="flex items-center gap-2 cursor-pointer">
                  <input type="checkbox" id="ruledClosed" class="accent-red-600 rounded scale-90" onchange="App.paper.drawGrid()" /><span class="text-gray-600">闭合两侧</span></label
                >
                <label class="flex items-center gap-2 cursor-pointer">
                  <input type="checkbox" id="ruledClosedDouble" class="accent-red-600 rounded scale-90" onchange="App.paper.drawGrid()" /><span class="text-gray-600">双线闭合</span></label
                >
              </div>

              <div data-paper-types="english" class="grid grid-cols-3 gap-2">
                <div>
                  <label class="compact-label">行线间距 </label>
                  <input type="number" id="englishLineGap" value="6" min="2" max="20" class="w-full compact-input border rounded" oninput="App.paper.updateSettings()" />
                </div>
                <div>
                  <label class="compact-label">行距偏移 </label>
                  <input type="number" id="englishOffset" value="0" min="-20" max="20" class="w-full compact-input border rounded" oninput="App.paper.updateSettings()" />
                </div>
                <div>
                  <label class="compact-label">格行间距 </label>
                  <input type="number" id="englishGroupGap" value="6" min="0" max="40" class="w-full compact-input border rounded" oninput="App.paper.updateSettings()" />
                </div>
              </div>

              <div data-paper-types="composition" class="grid grid-cols-2 gap-2">
                <div class="col-span-2">
                  <div class="flex justify-between mb-1">
                    <label class="compact-label">每行格数</label>
                    <input
                      type="number"
                      id="columnCountDisplay"
                      value="12"
                      class="editable-num bg-gray-100"
                      oninput="document.getElementById('columnCount').value=this.value; App.paper.updateSettings()" />
                  </div>
                  <input
                    type="range"
                    id="columnCount"
                    min="2"
                    max="40"
                    value="12"
                    class="w-full accent-red-600 h-1.5 bg-gray-200 rounded-lg appearance-none cursor-pointer"
                    oninput="App.paper.updateSettings()" />
                </div>
              </div>

              <div data-paper-types="grid" class="grid grid-cols-2 gap-2">
                <div class="col-span-2">
                  <div class="flex justify-between mb-1">
                    <label class="compact-label">每行格数</label>
                    <input
                      type="number"
                      id="gridColDisplay"
                      value="24"
                      class="editable-num bg-gray-100"
                      oninput="document.getElementById('gridColumns').value=this.value; App.paper.updateSettings()" />
                  </div>
                  <input
                    type="range"
                    id="gridColumns"
                    min="2"
                    max="60"
                    value="24"
                    class="w-full accent-red-600 h-1.5 bg-gray-200 rounded-lg appearance-none cursor-pointer"
                    oninput="App.paper.updateSettings()" />
                </div>
              </div>

              <div data-paper-types="music" class="grid grid-cols-2 gap-2">
                <div>
                  <label class="compact-label">每组线数</label>
                  <input type="number" id="staffLineCount" value="5" min="1" max="12" class="w-full compact-input border rounded" oninput="App.paper.updateSettings()" />
                </div>

                <div>
                  <label class="compact-label">谱表数量</label>
                  <input type="number" id="staffCount" value="8" min="1" max="20" class="w-full compact-input border rounded" oninput="App.paper.updateSettings()" />
                </div>
                <div>
                  <label class="compact-label">行间距(mm)</label>
                  <input type="number" id="staffLineGap" value="3" min="1" max="10" class="w-full compact-input border rounded" oninput="App.paper.updateSettings()" />
                </div>
                <div>
                  <label class="compact-label">谱表间距(mm)</label>
                  <input type="number" id="staffGroupGap" value="10" min="0" max="40" class="w-full compact-input border rounded" oninput="App.paper.updateSettings()" />
                </div>
              </div>

              <div data-paper-types="tianzige,mizige,huizige,jiugongge" class="grid grid-cols-2 gap-2">
                <div>
                  <label class="compact-label">格子大小(mm)</label>
                  <input type="number" id="tianSize" value="20" min="6" max="40" class="w-full compact-input border rounded" oninput="App.paper.updateSettings()" />
                </div>
                <div>
                  <label class="compact-label">中线细度</label>
                  <input type="number" id="tianInnerScale" value="0.5" step="0.1" min="0.1" max="2" class="w-full compact-input border rounded" oninput="App.paper.updateSettings()" />
                </div>
              </div>
              <div data-paper-types="jiugongge" class="grid grid-cols-2 gap-2 mt-2 border-t border-gray-200 pt-2">
                <div>
                  <label class="compact-label">内格列数 (竖分)</label>
                  <input type="number" id="jiuCols" value="3" min="0" max="10" class="w-full compact-input border rounded" oninput="App.paper.updateSettings()" />
                </div>
                <div>
                  <label class="compact-label">内格行数 (横分)</label>
                  <input type="number" id="jiuRows" value="3" min="0" max="10" class="w-full compact-input border rounded" oninput="App.paper.updateSettings()" />
                </div>
              </div>
              <div data-paper-types="dots" class="grid grid-cols-2 gap-2 hidden">
                <div>
                  <label class="compact-label">点密度(mm)</label>
                  <input type="number" id="dotSpace" value="5" min="2" max="50" class="w-full compact-input border rounded" oninput="App.paper.updateSettings()" />
                </div>
                <div>
                  <label class="compact-label">圆点直径(mm)</label>
                  <input type="number" id="dotSize" value="1" step="0.1" min="0.1" max="5" class="w-full compact-input border rounded" oninput="App.paper.updateSettings()" />
                </div>
                <div>
                  <label class="compact-label"> <input type="checkbox" id="dotStagger" class="accent-red-600 rounded scale-90" onchange="App.paper.updateSettings()" />隔行错位</label>
                </div>
              </div>
              <div data-paper-types="triangle,hexagon" class="grid grid-cols-1 gap-2 hidden">
                <div>
                  <label class="compact-label">图形边长(mm)</label>
                  <input type="number" id="geoSize" value="10" min="2" max="50" class="w-full compact-input border rounded" oninput="App.paper.updateSettings()" />
                </div>
              </div>
              <div data-paper-types="grid,composition,tianzige,mizige,huizige,jiugongge" class="mt-3 border-t border-gray-200 pt-2">
                <label class="flex items-center gap-2 cursor-pointer select-none">
                  <input type="checkbox" id="doubleBorder" class="accent-red-600 rounded scale-90" onchange="App.paper.drawGrid()" />
                  <span class="text-gray-600 text-xs font-bold">双线边框</span>
                </label>
              </div>
            </div>
          </section>
        </div>
      </aside>

      <main class="flex-1 bg-gray-200 relative flex flex-col overflow-hidden">
        <div class="absolute bottom-8 right-4 z-20 flex items-center bg-white shadow-lg rounded-lg p-1 border border-gray-200 text-xs">
          <button onclick="App.zoom.change(-0.1)" class="w-7 h-7 flex items-center justify-center text-gray-600 hover:bg-gray-100 rounded transition">
            <i class="ph ph-minus"></i>
          </button>
          <span id="zoomPercent" class="font-mono w-12 text-center text-gray-600 font-bold">100%</span>
          <button onclick="App.zoom.change(0.1)" class="w-7 h-7 flex items-center justify-center text-gray-600 hover:bg-gray-100 rounded transition">
            <i class="ph ph-plus"></i>
          </button>
          <div class="w-px h-3 bg-gray-300"></div>
          <button onclick="App.zoom.autoFit()" class="w-7 h-7 flex items-center justify-center text-gray-600 hover:bg-gray-100 rounded transition" title="自适应">
            <i class="ph ph-arrows-out-simple"></i>
          </button>
        </div>

        <div id="topToolbar" class="h-[25px] justify-center bg-white border-b border-gray-200 flex items-center px-4 shrink-0 z-10 gap-3 select-none overflow-x-auto no-scrollbar">
          <div class="flex items-center gap-1">
            <button onclick="App.tools.flip('x')" class="tune-btn tool-icon-btn" title="水平翻转" disabled>
              <i class="ph ph-flip-horizontal"></i>
            </button>
            <button onclick="App.tools.flip('y')" class="tune-btn tool-icon-btn" title="垂直翻转" disabled>
              <i class="ph ph-flip-vertical"></i>
            </button>
            <button onclick="App.tools.rotate(-90)" class="tune-btn tool-icon-btn" title="逆时针旋转90°" disabled>
              <i class="ph ph-arrow-counter-clockwise"></i>
            </button>
            <button onclick="App.tools.rotate(90)" class="tune-btn tool-icon-btn" title="顺时针旋转90°" disabled>
              <i class="ph ph-arrow-clockwise"></i>
            </button>
            <div class="w-px h-3 bg-gray-300"></div>
            <button onclick="App.tools.nudge('left')" class="tune-btn tool-icon-btn" title="左移" disabled><i class="ph ph-caret-left"></i></button>
            <button onclick="App.tools.nudge('down')" class="tune-btn tool-icon-btn" title="下移" disabled><i class="ph ph-caret-down"></i></button>
            <button onclick="App.tools.nudge('up')" class="tune-btn tool-icon-btn" title="上移" disabled><i class="ph ph-caret-up"></i></button>
            <button onclick="App.tools.nudge('right')" class="tune-btn tool-icon-btn" title="右移" disabled><i class="ph ph-caret-right"></i></button>
          </div>

          <div class="w-px h-3 bg-gray-300"></div>

          <div class="flex items-center gap-1">
            <button onclick="App.ui.alignObject('left')" class="tune-btn tool-icon-btn" title="左对齐于画布" disabled>
              <i class="ph ph-align-left-simple"></i>
            </button>
            <button onclick="App.ui.alignObject('centerH')" class="tune-btn tool-icon-btn" title="水平居中于画布" disabled>
              <i class="ph ph-align-center-horizontal-simple"></i>
            </button>
            <button onclick="App.ui.alignObject('right')" class="tune-btn tool-icon-btn" title="右对齐于画布" disabled>
              <i class="ph ph-align-right-simple"></i>
            </button>
            <button onclick="App.ui.alignObject('top')" class="tune-btn tool-icon-btn" title="顶对齐于画布" disabled>
              <i class="ph ph-align-top-simple"></i>
            </button>
            <button onclick="App.ui.alignObject('middle')" class="tune-btn tool-icon-btn" title="垂直居中于画布" disabled>
              <i class="ph ph-align-center-vertical-simple"></i>
            </button>
            <button onclick="App.ui.alignObject('bottom')" class="tune-btn tool-icon-btn" title="底对齐于画布" disabled>
              <i class="ph ph-align-bottom-simple"></i>
            </button>
          </div>

          <div class="w-px h-3 bg-gray-300"></div>

          <div class="flex items-center gap-1">
            <button onclick="App.ui.align('left')" class="align-btn tool-icon-btn" title="左对齐" disabled><i class="ph ph-align-left"></i></button>
            <button onclick="App.ui.align('center')" class="align-btn tool-icon-btn" title="水平居中" disabled>
              <i class="ph ph-align-center-horizontal"></i>
            </button>
            <button onclick="App.ui.align('right')" class="align-btn tool-icon-btn" title="右对齐" disabled><i class="ph ph-align-right"></i></button>
            <button onclick="App.ui.align('top')" class="align-btn tool-icon-btn" title="顶对齐" disabled><i class="ph ph-align-top"></i></button>
            <button onclick="App.ui.align('middle')" class="align-btn tool-icon-btn" title="垂直居中" disabled>
              <i class="ph ph-align-center-vertical"></i>
            </button>
            <button onclick="App.ui.align('bottom')" class="align-btn tool-icon-btn" title="底对齐" disabled>
              <i class="ph ph-align-bottom"></i>
            </button>
          </div>

          <div class="w-px h-3 bg-gray-300"></div>

          <div class="flex items-center gap-1">
            <button onclick="App.ui.distribute('horizontal')" class="dist-btn tool-icon-btn" title="水平分布" disabled>
              <i class="ph ph-columns"></i>
            </button>
            <button onclick="App.ui.distribute('vertical')" class="dist-btn tool-icon-btn" title="垂直分布" disabled>
              <i class="ph ph-rows"></i>
            </button>
          </div>
          <div class="w-px h-3 bg-gray-300"></div>
          <div class="flex items-center gap-1">
            <button onclick="App.tools.group()" id="btnGroup" class="tool-icon-btn" title="群组 (Ctrl+G)" disabled>
              <i class="ph ph-subtract-square"></i>
            </button>
            <button onclick="App.tools.ungroup()" id="btnUngroup" class="tool-icon-btn" title="解组 (Ctrl+Shift+G)" disabled>
              <i class="ph ph-unite-square"></i>
            </button>
          </div>
          <div class="w-px h-3 bg-gray-300"></div>
          <button onclick="App.tools.toggleLock()" id="btnLock" class="tool-icon-btn" title="锁定/解锁 (Ctrl+L)" disabled>
            <i class="ph ph-lock-key-open"></i>
          </button>
        </div>

        <div class="absolute top-[25px] left-0 z-10">
          <div id="ruler-corner">mm</div>
          <canvas id="ruler-h" class="ruler-canvas"></canvas>
          <canvas id="ruler-v" class="ruler-canvas"></canvas>
        </div>
        <div id="scrollContainer" class="flex-1 overflow-auto custom-scrollbar relative">
          <div id="zoomViewport">
            <div id="canvasWrapper" class="shadow-2xl bg-white relative">
              <canvas id="paperCanvas"></canvas>
            </div>
          </div>
        </div>
        <div
          id="dataNavBar"
          class="hidden absolute bottom-8 left-1/2 transform -translate-x-1/2 z-20 bg-white shadow-xl rounded-full px-4 py-2 border border-slate-200 flex items-center gap-3 transition-all duration-300">
          <div class="h-6 w-px bg-slate-200"></div>
          <div class="flex items-center gap-1">
            <button onclick="App.dataSource.nav('first')" class="p-1.5 rounded-full hover:bg-slate-100 text-slate-500 hover:text-slate-800 transition" title="首条">
              <i class="ph ph-caret-double-left"></i>
            </button>
            <button onclick="App.dataSource.nav('prev')" class="p-1.5 rounded-full hover:bg-slate-100 text-slate-500 hover:text-slate-800 transition" title="上一条">
              <i class="ph ph-caret-left"></i>
            </button>

            <div class="flex items-center bg-slate-100 rounded px-2 py-1 mx-1">
              <input
                type="number"
                id="vdpIndexInput"
                value="1"
                min="1"
                onchange="App.dataSource.nav('goto', this.value)"
                class="w-10 bg-transparent text-center text-sm font-bold text-slate-700 focus:outline-none border-none p-0 appearance-none" />
              <span class="text-xs text-slate-400 select-none">/ <span id="vdpTotal">0</span></span>
            </div>

            <button onclick="App.dataSource.nav('next')" class="p-1.5 rounded-full hover:bg-slate-100 text-slate-500 hover:text-slate-800 transition" title="下一条">
              <i class="ph ph-caret-right"></i>
            </button>
            <button onclick="App.dataSource.nav('last')" class="p-1.5 rounded-full hover:bg-slate-100 text-slate-500 hover:text-slate-800 transition" title="末条">
              <i class="ph ph-caret-double-right"></i>
            </button>
          </div>
          <div class="h-6 w-px bg-slate-200 mx-1"></div>

          <label class="flex items-center gap-1.5 cursor-pointer select-none" title="勾选后，批量打印/导出将只处理当前显示的这一页">
            <input type="checkbox" id="checkOnlyCurrentPage" onchange="App.state.printCurrentOnly = this.checked" class="accent-red-600 rounded scale-90" />
            <span class="text-xs font-bold text-slate-600 whitespace-nowrap">仅当前页</span>
          </label>
        </div>

        <div class="h-5 bg-white border-t border-gray-200 flex items-center justify-between px-3 text-gray-400 shrink-0 z-30 text-xs">
          <span id="canvasSizeLabel">A4</span>
          <span class="flex items-center"><i class="ph ph-mouse-left-click"></i>拖动平移 | 滚轮缩放 | Shift+点击 多选 | Alt+拉框 多选</span>
        </div>
        <!-- 标签模式切换按钮 -->
        <div id="labelModeToggle" class="hidden absolute bottom-8 left-8 z-20">
          <button onclick="App.label.toggleMode()" class="bg-white shadow-lg rounded-lg px-4 py-2 border border-gray-200 text-xs font-medium flex items-center gap-2 hover:bg-gray-50 transition">
            <i id="labelModeIcon" class="ph ph-eye text-base"></i>
            <span id="labelModeText">预览模式</span>
          </button>
        </div>
      </main>

      <aside class="w-64 bg-white border-l border-gray-200 flex flex-col z-20 h-full text-xs">
        <div class="h-9 border-b border-gray-200 flex bg-gray-50 shrink-0">
          <button onclick="App.ui.switchTab('props')" id="tabBtn-props" class="flex-1 font-medium text-slate-700 bg-white border-b-2 border-red-600 transition hover:bg-white focus:outline-none">
            <i class="ph ph-sliders"></i> 属性
          </button>
          <button
            onclick="App.ui.switchTab('layers')"
            id="tabBtn-layers"
            class="flex-1 font-medium text-slate-500 border-b-2 border-transparent hover:text-slate-700 hover:bg-gray-100 transition focus:outline-none flex items-center justify-center gap-1">
            <i class="ph ph-stack"></i> 图层
          </button>
          <button
            onclick="App.ui.switchTab('data')"
            id="tabBtn-data"
            class="flex-1 font-medium text-slate-500 border-b-2 border-transparent hover:text-slate-700 hover:bg-gray-100 transition focus:outline-none flex items-center justify-center gap-1">
            <i class="ph ph-database"></i> 数据源
          </button>
        </div>

        <div class="flex-1 flex flex-col overflow-hidden min-h-[45%] relative">
          <div id="tabContent-props" class="absolute inset-0 flex flex-col bg-white">
            <div id="noSelection" class="flex-1 flex flex-col items-center justify-center text-gray-300 p-8 text-center">
              <i class="ph ph-cursor-click text-4xl mb-2"></i>
              <p>选中元素以编辑</p>
            </div>
            <div id="selectionControls" class="hidden flex-1 overflow-y-auto p-3 space-y-4 text-xs">
              <section id="dataTypeTabs" class="bg-gray-100 p-1 rounded-lg grid grid-cols-4 gap-1 mb-2 select-none">
                <button onclick="App.ui.setDataType('static')" id="dtBtn-static" class="py-1.5 text-center rounded-md transition text-[10px] font-bold text-slate-500 hover:text-slate-700">
                  静态
                </button>
                <button onclick="App.ui.setDataType('variable')" id="dtBtn-variable" class="py-1.5 text-center rounded-md transition text-[10px] font-bold text-slate-500 hover:text-slate-700">
                  变量
                </button>
                <button onclick="App.ui.setDataType('serial')" id="dtBtn-serial" class="py-1.5 text-center rounded-md transition text-[10px] font-bold text-slate-500 hover:text-slate-700">
                  序列
                </button>
                <button onclick="App.ui.setDataType('date')" id="dtBtn-date" class="py-1.5 text-center rounded-md transition text-[10px] font-bold text-slate-500 hover:text-slate-700">时间</button>
              </section>

              <section id="dataProps" class="hidden bg-white border border-gray-200 rounded-lg p-3 space-y-2 mb-3">
                <div class="compact-label text-slate-600">变量绑定设置</div>
                <div id="varSettings">
                  <div id="noDataSourceTip" class="hidden text-[10px] text-red-500 py-1">请先在"数据源"面板加载 Excel 文件</div>
                  <div id="bindControls">
                    <div>
                      <label class="compact-label text-slate-600">工作表</label>
                      <select id="bindSheet" onchange="App.ui.updateBind('sheet', this.value)" class="w-full compact-input border rounded text-xs bg-white"></select>
                    </div>
                    <div class="mt-2">
                      <label class="compact-label text-slate-600">绑定字段</label>
                      <select id="bindField" onchange="App.ui.updateBind('field', this.value)" class="w-full compact-input border rounded text-xs bg-white"></select>
                    </div>
                  </div>
                </div>
                <div id="vdpImgDirCtrl" class="hidden mt-2 pt-2 border-t border-gray-100">
                  <div class="flex justify-between items-center mb-1">
                    <label class="compact-label text-slate-600">图片文件夹</label>
                    <span id="vdpImgDirStatus" class="text-[10px] text-orange-500 font-bold">未连接</span>
                  </div>
                  <button
                    onclick="App.dataSource.selectImageDir()"
                    class="w-full py-1 border rounded bg-gray-50 hover:bg-white text-xs text-slate-600 transition flex items-center justify-center gap-1">
                    <i class="ph ph-folder-open"></i>
                    <span id="vdpImgDirBtnText">选择文件夹...</span>
                  </button>
                </div>
              </section>

              <section id="geoProps" class="border-b border-gray-100 pb-3">
                <div class="flex justify-between items-center mb-2 border-b border-gray-100">
                  <span class="font-bold text-slate-500">对象属性</span>
                  <button
                    id="propLockBtn"
                    onclick="App.tools.toggleLock()"
                    class="text-slate-400 hover:text-red-600 transition flex items-center gap-1 px-2 py-1 rounded hover:bg-gray-100"
                    title="锁定/解锁">
                    <span id="propLockText" class="text-[10px]">未锁定</span>
                    <i class="ph ph-lock-key-open text-lg" id="propLockIcon"></i>
                  </button>
                </div>
                <div class="grid grid-cols-3 gap-2 mb-2">
                  <div>
                    <label class="compact-label">X 坐标</label>
                    <input type="number" id="propX" class="w-full compact-input border rounded" onchange="App.ui.updateGeo('left', this.value)" />
                  </div>
                  <div>
                    <label class="compact-label">Y 坐标</label>
                    <input type="number" id="propY" class="w-full compact-input border rounded" onchange="App.ui.updateGeo('top', this.value)" />
                  </div>
                  <div>
                    <label class="compact-label">旋转∠</label>
                    <input type="number" id="propAngle" class="w-full compact-input border rounded" onchange="App.ui.updateGeo('angle', this.value)" />
                  </div>
                </div>
                <div class="grid grid-cols-2 gap-2">
                  <div>
                    <label class="compact-label">宽度</label>
                    <input type="number" id="propW" class="w-full compact-input border rounded" onchange="App.ui.updateGeo('width', this.value)" />
                  </div>
                  <div>
                    <label class="compact-label">高度</label>
                    <input type="number" id="propH" class="w-full compact-input border rounded" onchange="App.ui.updateGeo('height', this.value)" />
                  </div>
                </div>
              </section>
              <section id="affixProps" class="border-b border-gray-100 pb-3 mb-2 hidden">
                <div class="grid grid-cols-1 gap-2">
                  <div>
                    <label class="compact-label">前缀</label>
                    <input
                      type="text"
                      id="propPrefix"
                      class="w-full compact-input border rounded"
                      placeholder="无"
                      oninput="App.content.setAffix(App.canvas.getActiveObject(), 'prefix', this.value)" />
                  </div>
                  <div>
                    <label class="compact-label">后缀</label>
                    <input
                      type="text"
                      id="propSuffix"
                      class="w-full compact-input border rounded"
                      placeholder="无"
                      oninput="App.content.setAffix(App.canvas.getActiveObject(), 'suffix', this.value)" />
                  </div>
                </div>
              </section>
              <section id="transProps" class="border-b border-gray-100 pb-3">
                <label class="compact-label flex justify-between"><span>透明度</span> <span id="opacityVal" class="text-gray-400">100%</span></label>
                <input
                  type="range"
                  id="propOpacity"
                  min="0"
                  max="1"
                  step="0.01"
                  oninput="App.ui.setProp('opacity', parseFloat(this.value)); 
                document.getElementById('opacityVal').innerText=Math.round(this.value*100)+'%'"
                  class="w-full accent-red-600 h-1.5 bg-gray-200 rounded-lg appearance-none cursor-pointer" />
              </section>

              <section id="barcodeProps" class="hidden space-y-3 border-b border-gray-100 pb-3">
                <div class="font-bold text-xs text-slate-500 mb-2 flex items-center gap-1"><i class="ph ph-barcode"></i> 条码设置</div>

                <div>
                  <label class="compact-label">条码类型</label>
                  <select id="bcType" onchange="App.barcode.applySettings()" class="w-full compact-input border rounded bg-white">
                    <optgroup label="常用二维码">
                      <option value="qrcode">QR Code (二维码)</option>
                      <option value="microqrcode">Micro QR Code</option>
                      <option value="datamatrix">Data Matrix</option>
                      <option value="pdf417">PDF417</option>
                      <option value="micropdf417">Micro PDF417</option>
                      <option value="azteccode">Aztec Code</option>
                      <option value="maxicode">MaxiCode (UPS)</option>
                      <option value="hanxin">Han Xin (汉信码)</option>
                      <option value="dotcode">DotCode</option>
                      <option value="gridmatrix">Grid Matrix</option>
                    </optgroup>
                    <optgroup label="常用条形码">
                      <option value="code128">Code 128</option>
                      <option value="ean13">EAN-13</option>
                      <option value="ean8">EAN-8</option>
                      <option value="upca">UPC-A</option>
                      <option value="upce">UPC-E</option>
                      <option value="code39">Code 39</option>
                      <option value="code39ext">Code 39 Extended</option>
                      <option value="code93">Code 93</option>
                      <option value="code93ext">Code 93 Extended</option>
                      <option value="rationalizedCodabar">Codabar</option>
                    </optgroup>
                    <optgroup label="物流与供应链">
                      <option value="gs1-128">GS1-128 (UCC/EAN-128)</option>
                      <option value="itf14">ITF-14</option>
                      <option value="interleaved2of5">Interleaved 2 of 5</option>
                      <option value="databaromni">GS1 DataBar Omni</option>
                      <option value="databarstacked">GS1 DataBar Stacked</option>
                      <option value="databarexpanded">GS1 DataBar Expanded</option>
                      <option value="sscc18">SSCC-18</option>
                    </optgroup>
                    <optgroup label="工业/医疗/其他">
                      <option value="code11">Code 11</option>
                      <option value="msi">MSI / Plessey</option>
                      <option value="telepen">Telepen</option>
                      <option value="pharmacode">Pharmacode (医药码)</option>
                      <option value="channelcode">Channel Code</option>
                      <option value="posicode">PosiCode</option>
                    </optgroup>
                    <optgroup label="邮政码">
                      <option value="uspsimail">USPS Intelligent Mail</option>
                      <option value="postnet">USPS POSTNET</option>
                      <option value="planet">USPS PLANET</option>
                      <option value="royalmail">Royal Mail (RM4SCC)</option>
                      <option value="japanpost">Japan Post (日本邮政)</option>
                      <option value="auspost">Australia Post</option>
                      <option value="kix">KIX (荷兰邮政)</option>
                    </optgroup>
                  </select>
                </div>

                <div>
                  <div class="flex items-center justify-between mb-1">
                    <label class="compact-label mb-0">内容数据</label>
                    <label class="flex items-center gap-1 cursor-pointer select-none" title="引用其他对象的共享数据">
                      <input type="checkbox" id="bcUseShared" onchange="App.barcode.toggleSharedMode(this.checked)" class="accent-red-600 rounded scale-90" />
                      <span class="text-[10px] text-slate-500 font-bold">使用共享字段</span>
                    </label>
                  </div>

                  <textarea
                    id="bcText"
                    rows="2"
                    oninput="App.barcode.applySettings()"
                    class="w-full text-xs p-2 border rounded resize-none focus:outline-none focus:border-red-500 font-mono"></textarea>

                  <select id="bcSharedSelect" onchange="App.barcode.applySettings()" class="hidden w-full compact-input border rounded bg-white border-red-300 text-xs"></select>

                  <p id="bcError" class="text-[10px] text-red-500 mt-1 hidden"></p>
                </div>

                <div class="grid grid-cols-1 gap-2">
                  <div>
                    <label class="compact-label">条码颜色</label>
                    <div class="h-7 border rounded p-0.5 overflow-hidden relative bg-white">
                      <input type="color" id="bcColor" oninput="App.barcode.applySettings()" class="absolute -top-2 -left-2 w-[150%] h-16 cursor-pointer" />
                    </div>
                  </div>
                </div>

                <!-- 一维码专用选项 -->
                <div id="bc1DOptions" class="space-y-2">
                  <div class="flex items-center justify-between">
                    <label class="flex items-center gap-2 cursor-pointer select-none">
                      <input type="checkbox" id="bcShowText" onchange="App.barcode.applySettings()" class="accent-red-600 rounded scale-90" checked />
                      <span class="compact-label mb-0">显示文字</span>
                    </label>
                  </div>
                  <div class="grid grid-cols-2 gap-2">
                    <div>
                      <label class="compact-label">文字位置</label>
                      <select id="bcTextAlign" onchange="App.barcode.applySettings()" class="w-full compact-input border rounded bg-white">
                        <option value="center">居中</option>
                        <option value="left">左对齐</option>
                        <option value="right">右对齐</option>
                      </select>
                    </div>
                    <div>
                      <label class="compact-label">条码高度比例</label>
                      <input type="number" id="bcBarHeight" value="10" min="1" max="50" oninput="App.barcode.applySettings()" class="w-full compact-input border rounded" />
                    </div>

                    <div>
                      <label class="compact-label">文字大小</label>
                      <input type="number" id="bcFontSize" value="10" min="5" max="72" oninput="App.barcode.applySettings()" class="w-full compact-input border rounded" />
                    </div>
                    <div>
                      <label class="compact-label">文字间距</label>
                      <input type="number" id="bcTextGap" value="0" min="-10" max="20" oninput="App.barcode.applySettings()" class="w-full compact-input border rounded" />
                    </div>
                  </div>
                </div>

                <div id="bc2DOptions" class="hidden space-y-2">
                  <div>
                    <label class="compact-label">纠错等</label>
                    <select id="bcEcc" onchange="App.barcode.applySettings()" class="w-full compact-input border rounded bg-white">
                      <option value="L">L (7%)</option>
                      <option value="M">M (15%)</option>
                      <option value="Q" selected>Q (25%)</option>
                      <option value="H">H (30%)</option>
                    </select>
                  </div>
                </div>
              </section>

              <section id="textProps" class="hidden space-y-2">
                <div class="flex gap-1 items-end">
                  <div class="flex-1">
                    <label class="compact-label">字体</label>
                    <select id="propFont" onchange="App.ui.setProp('fontFamily', this.value)" onclick="App.loadLocalFonts()" class="w-full compact-input border rounded bg-white">
                      <option value="SourceHanSerifCN-Bold" style="font-family: 'SourceHanSerifCN-Bold'">思源宋体</option>
                      <option value="SimSun">宋体</option>
                      <option value="KaiTi">楷体</option>
                      <option value="SimHei">黑体</option>
                      <option value="FangSong">仿宋</option>
                      <option value="Arial">Arial</option>
                      <option value="'Times New Roman'">Times New Roman</option>
                    </select>
                  </div>
                  <div class="w-16">
                    <label class="compact-label">字号</label>
                    <input type="number" id="propSize" oninput="App.ui.setProp('fontSize', Utils.pt2px(this.value))" class="w-full compact-input border rounded" />
                  </div>
                </div>
                <div class="flex gap-2 items-center">
                  <div class="flex border rounded overflow-hidden shrink-0">
                    <button id="btnBold" onclick="App.ui.toggleStyle('bold')" class="style-btn hover:bg-gray-50 border-r">
                      <i class="ph ph-text-b"></i>
                    </button>
                    <button id="btnItalic" onclick="App.ui.toggleStyle('italic')" class="style-btn hover:bg-gray-50 border-r">
                      <i class="ph ph-text-italic"></i>
                    </button>
                    <button id="btnUnderline" onclick="App.ui.toggleStyle('underline')" class="style-btn hover:bg-gray-50">
                      <i class="ph ph-text-underline"></i>
                    </button>
                    <button id="btnVertical" onclick="App.ui.toggleVertical()" class="style-btn hover:bg-gray-50" title="竖排文字">
                      <i class="ph ph-text-t rotate-90"></i>
                    </button>
                  </div>
                  <div class="flex-1 h-7 border rounded p-0.5 overflow-hidden flex items-center relative">
                    <input type="color" id="propColor" oninput="App.ui.setProp('fill', this.value)" class="absolute -top-2 -left-2 w-[150%] h-20 cursor-pointer p-0 border-0" />
                  </div>
                </div>
                <div class="flex border rounded overflow-hidden flex-1">
                  <button onclick="App.ui.setProp('textAlign', 'left')" class="flex-1 py-1 hover:bg-gray-50 border-r flex justify-center">
                    <i class="ph ph-text-align-left"></i>
                  </button>
                  <button onclick="App.ui.setProp('textAlign', 'center')" class="flex-1 py-1 hover:bg-gray-50 border-r flex justify-center">
                    <i class="ph ph-text-align-center"></i>
                  </button>
                  <button onclick="App.ui.setProp('textAlign', 'right')" class="flex-1 py-1 hover:bg-gray-50 flex justify-center">
                    <i class="ph ph-text-align-right"></i>
                  </button>
                </div>
                <div>
                  <label class="compact-label flex justify-between"
                    ><span>行高</span>
                    <input
                      type="number"
                      id="lineHeightVal"
                      value="1.2"
                      step="0.1"
                      class="editable-num bg-gray-100"
                      oninput="document.getElementById('propLineHeight').value=this.value; App.ui.setProp('lineHeight', parseFloat(this.value))" />
                  </label>
                  <input
                    type="range"
                    id="propLineHeight"
                    min="0.1"
                    max="10"
                    step="0.1"
                    value="1.2"
                    oninput="App.ui.setProp('lineHeight', parseFloat(this.value)); document.getElementById('lineHeightVal').value=this.value"
                    class="w-full accent-red-600 h-1.5 bg-gray-200 rounded-lg appearance-none cursor-pointer" />
                </div>
                <div>
                  <label class="compact-label flex justify-between"
                    ><span>字间距</span>
                    <input
                      type="number"
                      id="charSpacingVal"
                      value="0"
                      step="10"
                      class="editable-num bg-gray-100"
                      oninput="document.getElementById('propCharSpacing').value=this.value; App.ui.setProp('charSpacing', parseInt(this.value))" />
                  </label>
                  <input
                    type="range"
                    id="propCharSpacing"
                    min="-500"
                    max="10000"
                    step="10"
                    oninput="App.ui.setProp('charSpacing', parseInt(this.value)); document.getElementById('charSpacingVal').value=this.value"
                    class="w-full accent-red-600 h-1.5 bg-gray-200 rounded-lg appearance-none cursor-pointer" />
                </div>
              </section>
              <section id="dateProps" class="hidden space-y-3 border-b border-gray-100 pb-3">
                <div class="font-bold text-xs text-slate-500 mb-2 flex items-center gap-1"><i class="ph ph-calendar"></i> 日期时间设置</div>
                <div class="flex items-center gap-4 bg-gray-50 p-2 rounded border border-gray-200">
                  <label class="flex items-center gap-2 cursor-pointer select-none">
                    <input type="checkbox" id="dateShowDate" class="accent-red-600 rounded scale-90" onchange="App.ui.updateDateConfig('showDate', this.checked)" />
                    <span class="text-xs font-bold text-slate-700">显示日期</span>
                  </label>
                  <label class="flex items-center gap-2 cursor-pointer select-none">
                    <input type="checkbox" id="dateShowTime" class="accent-red-600 rounded scale-90" onchange="App.ui.updateDateConfig('showTime', this.checked)" />
                    <span class="text-xs font-bold text-slate-700">显示时间</span>
                  </label>
                </div>

                <div id="dateFormatWrapper">
                  <label class="compact-label">日期格式</label>
                  <select id="dateFormat" onchange="App.ui.updateDateConfig('dateFormat', this.value)" class="w-full compact-input border rounded bg-white"></select>
                </div>

                <div id="timeFormatWrapper">
                  <label class="compact-label">时间格式</label>
                  <select id="timeFormat" onchange="App.ui.updateDateConfig('timeFormat', this.value)" class="w-full compact-input border rounded bg-white"></select>
                </div>

                <div class="grid grid-cols-2 gap-2">
                  <div>
                    <label class="compact-label" title="正数向后推，负数向前推">天数偏移</label>
                    <input type="number" id="dateOffsetDays" value="0" class="w-full compact-input border rounded" onchange="App.ui.updateDateConfig('offsetDays', parseInt(this.value))" />
                  </div>
                  <div>
                    <label class="compact-label" title="用于调整时区或特定时间">分钟偏移</label>
                    <input type="number" id="dateOffsetMinutes" value="0" class="w-full compact-input border rounded" onchange="App.ui.updateDateConfig('offsetMinutes', parseInt(this.value))" />
                  </div>
                </div>
              </section>

              <section id="pageNumProps" class="hidden space-y-3 border-b border-gray-100 pb-3">
                <div class="font-bold text-xs text-slate-500 mb-2 flex items-center gap-1"><i class="ph ph-hash"></i> 页码设置</div>

                <div>
                  <label class="compact-label">页码格式</label>
                  <select id="pageFormat" onchange="App.ui.updatePageConfig('format', this.value)" class="w-full compact-input border rounded bg-white">
                    <option value="第 {page} 页">第 1 页</option>
                    <option value="{page}">1</option>
                    <option value="- {page} -">- 1 -</option>
                    <option value="Page {page}">Page 1</option>
                    <option value="{page} / {total}">1 / 10</option>
                  </select>
                </div>

                <div>
                  <label class="compact-label">起始页码</label>
                  <input type="number" id="pageStartFrom" value="1" min="0" class="w-full compact-input border rounded" onchange="App.ui.updatePageConfig('startFrom', parseInt(this.value))" />
                </div>
              </section>
              <section id="serialProps" class="hidden space-y-3 border-b border-gray-100 pb-3">
                <div class="font-bold text-xs text-slate-500 mb-2 flex items-center gap-1"><i class="ph ph-list-numbers"></i> 序列号设置</div>

                <div class="grid grid-cols-2 gap-2">
                  <div>
                    <label class="compact-label">起始值</label>
                    <input type="text" id="serialStartValue" value="1" class="w-full compact-input border rounded" oninput="App.ui.updateSerialConfig('startValue', this.value)" />
                  </div>
                  <div>
                    <label class="compact-label">间隔值</label>
                    <input type="number" id="serialStep" value="1" min="1" class="w-full compact-input border rounded" onchange="App.ui.updateSerialConfig('step', parseInt(this.value))" />
                  </div>
                </div>

                <div class="grid grid-cols-2 gap-2">
                  <div>
                    <label class="compact-label">重复次数</label>
                    <input type="number" id="serialRepeat" value="1" min="1" class="w-full compact-input border rounded" onchange="App.ui.updateSerialConfig('repeat', parseInt(this.value))" />
                  </div>
                  <div>
                    <label class="compact-label">变化类型</label>
                    <select id="serialChangeType" onchange="App.ui.updateSerialConfig('changeType', this.value)" class="w-full compact-input border rounded bg-white">
                      <option value="increment">递增</option>
                      <option value="decrement">递减</option>
                    </select>
                  </div>
                </div>

                <div id="serialGenerateCountWrapper" class="hidden">
                  <label class="compact-label flex items-center gap-1">
                    生成数量
                    <span class="text-[10px] text-orange-600">(影响页面总数)</span>
                  </label>
                  <input
                    type="number"
                    id="serialGenerateCount"
                    value="10"
                    min="1"
                    class="w-full compact-input border rounded"
                    oninput="App.ui.updateSerialConfig('generateCount', parseInt(this.value))" />
                </div>

                <div class="bg-gray-50 border border-gray-200 rounded p-2 text-[10px] text-red-700">
                  <i class="ph ph-info"></i>
                  <span id="serialPreviewText">预览: 1, 1, 2, 2, 3, 3...</span>
                </div>
              </section>
              <section id="lineProps" class="hidden space-y-2">
                <div class="flex items-center gap-2">
                  <div class="flex-1">
                    <label class="compact-label">线颜色</label>
                    <div class="flex-1 h-7 border rounded p-0.5 overflow-hidden flex items-center relative">
                      <input type="color" id="lineColor" oninput="App.ui.setProp('stroke', this.value)" class="absolute -top-2 -left-2 w-[150%] h-20 cursor-pointer p-0 border-0" />
                    </div>
                  </div>
                  <div class="w-16">
                    <label class="compact-label">线宽</label>
                    <input type="number" id="lineStrokeWidth" min="0" max="50" step="0.1" oninput="App.ui.setProp('strokeWidth', parseFloat(this.value))" class="w-full compact-input border rounded" />
                  </div>
                </div>

                <div class="flex items-center gap-2 pt-1 border-t border-gray-100">
                  <label class="flex items-center gap-2 cursor-pointer flex-1 select-none">
                    <input type="checkbox" id="lineDashCheck" class="accent-red-600 rounded scale-90" onchange="App.ui.updateLineDash()" />
                    <span class="text-gray-600 compact-label mb-0">虚线</span>
                  </label>
                  <div class="w-16">
                    <label class="compact-label">间距</label>
                    <input type="number" id="lineDashVal" value="4" min="0.1" max="50" step="0.1" class="w-full compact-input border rounded" oninput="App.ui.updateLineDash()" />
                  </div>
                </div>
              </section>

              <section id="shapeProps" class="hidden space-y-3 border-b border-gray-100 pb-3">
                <div class="flex gap-2">
                  <div class="flex-1">
                    <div class="flex justify-between items-center mb-1">
                      <label class="compact-label mb-0">填充</label>
                      <label class="flex items-center gap-1 cursor-pointer select-none" title="无填充(透明)">
                        <input type="checkbox" id="shapeNoFill" class="accent-red-600 rounded scale-75" onchange="App.ui.toggleShapeFill()" />
                        <span class="text-[10px] text-gray-400">无</span>
                      </label>
                    </div>
                    <div class="h-8 border rounded p-0.5 overflow-hidden relative bg-white transition" id="shapeFillWrapper">
                      <input type="color" id="shapeFill" oninput="App.ui.setShapeFill(this.value)" class="absolute -top-2 -left-2 w-[150%] h-16 cursor-pointer" />
                    </div>
                  </div>

                  <div class="flex-1">
                    <label class="compact-label mb-1 block">边框颜色</label>
                    <div class="h-8 border rounded p-0.5 overflow-hidden relative bg-white">
                      <input type="color" id="shapeStroke" oninput="App.ui.setProp('stroke', this.value)" class="absolute -top-2 -left-2 w-[150%] h-16 cursor-pointer" />
                    </div>
                  </div>

                  <div class="w-16">
                    <label class="compact-label mb-1 block">线宽</label>
                    <input
                      type="number"
                      id="shapeStrokeWidth"
                      min="0"
                      max="20"
                      step="0.1"
                      class="w-full compact-input border rounded h-8"
                      oninput="App.ui.setProp('strokeWidth', parseFloat(this.value))" />
                  </div>
                </div>
                <div id="shapeDash" class="flex items-center gap-2 pt-2 border-t border-gray-100 mt-2">
                  <label class="flex items-center gap-2 cursor-pointer flex-1 select-none">
                    <input type="checkbox" id="shapeDashCheck" class="accent-red-600 rounded scale-90" onchange="App.ui.updateShapeDash()" />
                    <span class="text-gray-600 compact-label mb-0">虚线描边</span>
                  </label>
                  <div class="w-16">
                    <label class="compact-label">间距</label>
                    <input type="number" id="shapeDashVal" value="5" min="1" max="50" class="w-full compact-input border rounded" oninput="App.ui.updateShapeDash()" />
                  </div>
                </div>
                <div id="rectCornerControl" class="hidden space-y-2 pt-2 border-t border-gray-200">
                  <!-- 类型选择与总控 -->
                  <div class="flex items-end gap-2">
                    <div class="w-1/3">
                      <label class="compact-label">角类型</label>
                      <select id="cornerStyle" onchange="App.tools.updateSmartCorner('style', this.value)" class="w-full compact-input border rounded bg-white">
                        <option value="round">圆角</option>
                        <option value="bevel">斜角</option>
                      </select>
                    </div>
                    <div class="flex-1">
                      <label class="compact-label flex justify-between"
                        ><span>角尺寸</span>
                        <input
                          type="number"
                          id="masterRadiusVal"
                          value="0"
                          class="editable-num bg-gray-100"
                          oninput="document.getElementById('masterRadius').value=this.value; App.tools.updateSmartCorner('all', this.value)" />
                      </label>
                      <input
                        type="range"
                        id="masterRadius"
                        min="0"
                        max="100"
                        value="0"
                        oninput="App.tools.updateSmartCorner('all', this.value)"
                        class="w-full accent-red-600 h-1.5 bg-gray-200 rounded-lg appearance-none cursor-pointer" />
                    </div>
                  </div>

                  <div class="grid grid-cols-2 gap-2 bg-gray-50 p-2 rounded border border-gray-200">
                    <div class="relative">
                      <span class="absolute left-1 top-1 text-[10px] text-gray-400">左上</span>
                      <input type="number" id="cornerTL" min="0" oninput="App.tools.updateSmartCorner('tl', this.value)" class="w-full compact-input border rounded text-right pl-6" />
                    </div>
                    <div class="relative">
                      <span class="absolute left-1 top-1 text-[10px] text-gray-400">右上</span>
                      <input type="number" id="cornerTR" min="0" oninput="App.tools.updateSmartCorner('tr', this.value)" class="w-full compact-input border rounded text-right pl-6" />
                    </div>
                    <div class="relative">
                      <span class="absolute left-1 top-1 text-[10px] text-gray-400">左下</span>
                      <input type="number" id="cornerBL" min="0" oninput="App.tools.updateSmartCorner('bl', this.value)" class="w-full compact-input border rounded text-right pl-6" />
                    </div>
                    <div class="relative">
                      <span class="absolute left-1 top-1 text-[10px] text-gray-400">右下</span>
                      <input type="number" id="cornerBR" min="0" oninput="App.tools.updateSmartCorner('br', this.value)" class="w-full compact-input border rounded text-right pl-6" />
                    </div>
                  </div>
                </div>
              </section>

              <section id="tableProps" class="hidden space-y-2 border-b border-gray-100 pb-3">
                <button onclick="App.tableEditor.open(App.canvas.getActiveObject())" class="w-full py-2 bg-red-50 text-red-600 border border-red-200 rounded font-medium transition">
                  <i class="ph ph-table text-base mr-1"></i> 编辑表格
                </button>
                <p class="text-[11px] text-gray-400 leading-relaxed">提示：请使用表格工具调整行列、合并拆分以及单元格样式。</p>
              </section>

              <section id="imgProps" class="hidden space-y-3">
                <button
                  onclick="document.getElementById('imgReplaceInput').click()"
                  class="w-full py-2 bg-gray-100 text-slate-700 border border-gray-300 rounded font-medium hover:bg-gray-200 transition text-xs">
                  <i class="ph ph-arrows-clockwise"></i> 替换图片
                </button>

                <div id="imgNormalControls" class="space-y-2">
                  <div class="flex gap-2">
                    <button onclick="App.tools.setAsBackground()" class="flex-1 py-2 bg-red-50 text-red-600 border border-red-200 rounded font-medium hover:bg-red-100 transition text-xs">
                      <i class="ph ph-image-square"></i> 设为背景
                    </button>
                    <button onclick="App.tools.fillPaper()" class="flex-1 py-2 border bg-gray-100 rounded font-medium transition text-xs"><i class="ph ph-arrows-out-simple"></i> 铺满页面</button>
                  </div>
                </div>

                <div id="imgBgControls" class="hidden space-y-3 pt-2 border-t border-gray-100">
                  <label class="flex items-center gap-2 cursor-pointer select-none">
                    <input type="checkbox" id="checkPrintBg" onchange="App.tools.togglePrintBackground(this.checked)" class="accent-red-600 rounded scale-90" />
                    <span class="text-xs font-bold text-slate-700">打印/导出时显示</span>
                  </label>
                  <p class="text-[10px] text-gray-400">关闭后，背景图仅在设计时可见，不会被打印或导出为PDF。</p>

                  <button
                    onclick="App.paper.clearBackground()"
                    class="w-full py-2 border border-red-200 text-red-600 hover:bg-red-50 rounded font-medium transition text-xs flex items-center justify-center gap-1">
                    <i class="ph ph-trash"></i> 删除背景图片
                  </button>
                </div>
              </section>

              <section id="sharedProps" class="hidden space-y-3 pt-2 border-t border-gray-100 mt-2">
                <div class="flex items-center justify-between mb-2">
                  <label class="font-bold text-xs text-slate-500 mb-2 flex items-center gap-1"><i class="ph ph-arrows-left-right"></i>字段数据共享</label>
                </div>
                <div class="flex gap-4 mb-2 text-xs px-1 select-none">
                  <label class="flex items-center gap-1 cursor-pointer">
                    <input type="radio" name="syncMode" value="none" class="accent-red-600" onchange="App.ui.toggleSyncMode('none')" />
                    <span>无</span>
                  </label>
                  <label class="flex items-center gap-1 cursor-pointer">
                    <input type="radio" name="syncMode" value="share" class="accent-red-600" onchange="App.ui.toggleSyncMode('share')" />
                    <span>共享</span>
                  </label>
                  <label class="flex items-center gap-1 cursor-pointer">
                    <input type="radio" name="syncMode" value="ref" class="accent-red-600" onchange="App.ui.toggleSyncMode('ref')" />
                    <span>引用</span>
                  </label>
                </div>
                <div id="syncPanel_share" class="hidden space-y-2">
                  <div class="flex gap-1">
                    <input
                      type="text"
                      id="propSharedInput"
                      class="w-full compact-input border rounded disabled:bg-gray-100 disabled:text-gray-500 disabled:cursor-not-allowed"
                      onkeydown="if(event.key === 'Enter') App.ui.saveSharedId()"
                      placeholder="输入共享名 (如: price)" />
                    <button
                      id="propSharedBtn"
                      onclick="App.ui.saveSharedId()"
                      class="px-3 bg-red-50 text-red-600 border border-red-200 rounded hover:bg-red-100 transition text-xs whitespace-nowrap font-medium">
                      保存
                    </button>
                  </div>
                  <div class="flex justify-between items-center">
                    <p id="propSharedHint" class="text-[10px] text-gray-400"></p>
                  </div>
                </div>

                <div id="syncPanel_ref" class="hidden">
                  <select id="propSharedSelect" onchange="App.ui.applyRefId(this.value)" class="w-full compact-input border rounded bg-white border-red-200">
                    <option value="">选择共享字段</option>
                  </select>
                  <p class="text-[10px] text-gray-400 mt-1">选择已存在共享字段，内容将自动同步。</p>
                </div>
              </section>
            </div>
          </div>

          <div id="tabContent-layers" class="absolute inset-0 flex flex-col bg-white hidden">
            <div id="layerList" class="flex-1 overflow-y-auto p-1 space-y-0.5 custom-scrollbar"></div>
          </div>

          <div id="tabContent-data" class="absolute inset-0 flex flex-col bg-white hidden">
            <div id="dataPanel" class="flex-1 flex flex-col p-4 overflow-hidden">
              <div class="flex flex-col items-center justify-center h-full text-center space-y-3" id="noDataState">
                <div class="bg-gray-50 p-4 rounded-full">
                  <i class="ph ph-microsoft-excel-logo text-3xl text-green-600"></i>
                </div>
                <div>
                  <h3 class="font-bold text-slate-700">导入 Excel 数据</h3>
                  <p class="text-xs text-gray-400 mt-1">支持 .xlsx / .xls 格式</p>
                </div>
                <button onclick="App.dataSource.openFile()" class="px-4 py-2 bg-slate-800 text-white rounded-lg hover:bg-slate-700 transition text-xs font-medium flex items-center gap-2">
                  <i class="ph ph-file-plus"></i> 选择本地文件
                </button>
              </div>
              <div id="dataLoadedState" class="hidden flex-col h-full">
                <div class="bg-slate-50 p-3 rounded-lg border border-slate-200 mb-4">
                  <div class="flex items-center justify-between mb-2">
                    <div class="flex items-center gap-2 overflow-hidden">
                      <i class="ph ph-file-xls text-green-600 text-lg shrink-0"></i>
                      <span id="dsFileName" class="font-bold text-xs truncate" title="文件名">filename.xlsx</span>
                    </div>
                    <button onclick="App.dataSource.close()" class="text-slate-400 hover:text-red-500 transition shrink-0" title="断开连接">
                      <i class="ph ph-trash"></i>
                    </button>
                  </div>
                  <div class="space-y-1">
                    <label class="text-[10px] uppercase font-bold text-slate-400 tracking-wider">工作表 (Sheet)</label>
                    <div class="flex items-center gap-1">
                      <select
                        id="dsSheetSelect"
                        onchange="App.dataSource.changeSheet(this.value)"
                        class="flex-1 text-xs border-gray-300 rounded bg-white py-1.5 focus:ring-red-500 focus:border-red-500"></select>
                      <button
                        onclick="App.dataSource.batchUpdateBinding()"
                        class="h-[30px] px-2 bg-white border border-gray-300 rounded text-slate-600 hover:text-red-600 hover:border-red-300 transition"
                        title="重新绑定">
                        <i class="ph ph-arrows-left-right"></i>
                      </button>
                    </div>
                  </div>
                </div>

                <div class="flex-1 overflow-hidden flex flex-col">
                  <div class="flex justify-between items-end mb-2 border-b border-gray-100 pb-1">
                    <span class="font-bold text-xs text-slate-500">字段列表</span>
                    <span id="dsRowCount" class="text-[10px] bg-green-100 text-green-700 px-1.5 py-0.5 rounded-full font-mono">0 条数据</span>
                  </div>
                  <div class="flex-1 overflow-y-auto custom-scrollbar bg-slate-50 rounded border border-gray-100 p-2">
                    <ul id="dsFieldList" class="space-y-1"></ul>
                  </div>
                  <p class="text-[10px] text-slate-400 mt-2 leading-relaxed"><i class="ph ph-info"></i> 提示：切换到"属性设置"选中文字，开启"可变数据"以绑定字段。</p>
                </div>

                <button
                  onclick="App.dataSource.reloadFromFile()"
                  class="mt-3 w-full py-2 border border-slate-200 hover:bg-slate-50 text-slate-600 rounded text-xs font-medium transition flex items-center justify-center gap-2">
                  <i class="ph ph-arrows-clockwise"></i> 重新读取文件
                </button>
              </div>
            </div>
          </div>
        </div>
      </aside>
    </div>
    <!-- Loading Overlay -->
    <div id="loadingOverlay" class="hidden fixed inset-0 z-[60] bg-white/80 backdrop-blur-sm flex flex-col items-center justify-center">
      <div class="animate-spin rounded-full h-12 w-12 border-4 border-red-600 border-t-transparent"></div>
      <p class="mt-4 text-slate-600 font-medium animate-pulse">正在加载模板...</p>
    </div>
    <script>
      // --- 1. 配置与常量定义 ---
      const CONFIG = {
        DPI: 96,
        MM_TO_PX: 3.7795,
        PT_TO_PX: 1.3333,
        SIZES: {
          A3: {
            w: 297,
            h: 420,
          },
          A4: {
            w: 210,
            h: 297,
          },
          A5: {
            w: 148,
            h: 210,
          },
          B4: {
            w: 250,
            h: 353,
          },
          B5: {
            w: 176,
            h: 250,
          },
          Letter: {
            w: 215.9,
            h: 279.4,
          },
          Legal: {
            w: 215.9,
            h: 355.6,
          },
          "16开": {
            w: 210,
            h: 285,
          },
          "32开": {
            w: 185,
            h: 260,
          },
          方纸: {
            w: 230,
            h: 230,
          },
        },
      };
      const CUSTOM_PROPS = [
        "id",
        "selectable",
        "evented",
        "lockMovementX",
        "lockMovementY",
        "isGrid",
        "excludeFromExport",
        "isSmartRect",
        "cornerConfig",
        "isTable",
        "tableData",
        "isVertical",
        "dataBinding",
        "printBackground",
        "isBarcode",
        "barcodeConfig",
        "isDynamicDate",
        "dateConfig",
        "isDynamicPageNum",
        "pageConfig",
        "isSerialNumber",
        "serialConfig",
        "prefix",
        "suffix",
        "rawContent",
        "sharedId",
        "refId",
        "prefixRaw",
        "suffixRaw",
        "syncMode",
        "imgDirId",
        "imgDirName",
      ];

      const DATE_FMT_OPTS = [
        {
          l: "2024-01-30",
          v: "YYYY-MM-DD",
        },
        {
          l: "2024/01/30",
          v: "YYYY/MM/DD",
        },
        {
          l: "2024.01.30",
          v: "YYYY.MM.DD",
        },
        {
          l: "20240130",
          v: "YYYYMMDD",
        },
        {
          l: "01-30",
          v: "MM-DD",
        },
        {
          l: "01/30",
          v: "MM/DD",
        },

        {
          l: "2024年01月30日",
          v: "YYYY年MM月DD日",
        },
        {
          l: "2024年01月",
          v: "YYYY年MM月",
        },
        {
          l: "01月30日",
          v: "MM月DD日",
        },
        {
          l: "2024年",
          v: "YYYY年",
        },

        {
          l: "30/01/2024 (日月年)",
          v: "DD/MM/YYYY",
        },
        {
          l: "01/30/2024 (月日年)",
          v: "MM/DD/YYYY",
        },
        {
          l: "30-01-2024",
          v: "DD-MM-YYYY",
        },

        {
          l: "2024 (仅年)",
          v: "YYYY",
        },
        {
          l: "2024年",
          v: "YYYY年",
        },
        {
          l: "01 (仅月)",
          v: "MM",
        },
        {
          l: "01月",
          v: "MM月",
        },
        {
          l: "30 (仅日)",
          v: "DD",
        },
        {
          l: "30日",
          v: "DD日",
        },
      ];

      const TIME_FMT_OPTS = [
        {
          l: "14:30:59",
          v: "HH:mm:ss",
        },
        {
          l: "14:30",
          v: "HH:mm",
        },
        {
          l: "14-30-59",
          v: "HH-mm-ss",
        },
        {
          l: "14.30.59",
          v: "HH.mm.ss",
        },
        {
          l: "143059",
          v: "HHmmss",
        },

        {
          l: "02:30:59 PM",
          v: "h:mm:ss A",
        },
        {
          l: "02:30 PM",
          v: "h:mm A",
        },
        {
          l: "PM 02:30",
          v: "A h:mm",
        },
        {
          l: "2:30 (无AM/PM)",
          v: "h:mm",
        },

        {
          l: "14时30分59秒",
          v: "HH时mm分ss秒",
        },
        {
          l: "14时30分",
          v: "HH时mm分",
        },
        {
          l: "30分59秒",
          v: "mm分ss秒",
        },
        {
          l: "14点30分",
          v: "HH点mm分",
        },

        {
          l: "14 (仅时-24)",
          v: "HH",
        },
        {
          l: "14时",
          v: "HH时",
        },
        {
          l: "2 (仅时-12)",
          v: "h",
        },
        {
          l: "30 (仅分)",
          v: "mm",
        },
        {
          l: "30分",
          v: "mm分",
        },
        {
          l: "59 (仅秒)",
          v: "ss",
        },
        {
          l: "59秒",
          v: "ss秒",
        },
      ];

      // --- 通用工具类 ---
      const Utils = {
        mm2px: (mm) => mm * CONFIG.MM_TO_PX,
        px2mm: (px) => px / CONFIG.MM_TO_PX,
        pt2px: (pt) => Math.round(pt * CONFIG.PT_TO_PX),
        px2pt: (px) => Math.round(px / CONFIG.PT_TO_PX),

        // 生成唯一ID
        generateUniqueId: () => `handle_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,

        // 显示 Toast 提示
        toast: (text, type = "info") => {
          const bg = type === "error" ? "linear-gradient(to right, #ff5f6d, #ffc371)" : type === "success" ? "linear-gradient(to right, #00b09b, #96c93d)" : "#333";
          Toastify({
            text,
            duration: 3000,
            gravity: "top",
            position: "center",
            style: {
              background: bg,
              borderRadius: "8px",
              fontSize: "12px",
              boxShadow: "0 4px 6px rgba(0,0,0,0.1)",
            },
          }).showToast();
        },

        // 节流函数
        throttle: (func, limit) => {
          let inThrottle;
          return function () {
            const args = arguments,
              context = this;
            if (!inThrottle) {
              func.apply(context, args);
              inThrottle = true;
              setTimeout(() => (inThrottle = false), limit);
            }
          };
        },

        formatDate: function (date, unusedFormat, config) {
          if (!config) return date.toLocaleString();

          let targetDate = new Date(date);
          if (config.offsetDays) {
            targetDate.setDate(targetDate.getDate() + (parseInt(config.offsetDays) || 0));
          }
          if (config.offsetMinutes) {
            targetDate.setMinutes(targetDate.getMinutes() + (parseInt(config.offsetMinutes) || 0));
          }

          let formatString = "";
          if (config.showDate) formatString += config.dateFormat || "YYYY-MM-DD";
          if (config.showDate && config.showTime) formatString += " ";
          if (config.showTime) formatString += config.timeFormat || "HH:mm:ss";

          if (!formatString) return "";

          const parts = {
            YYYY: targetDate.getFullYear(),
            MM: String(targetDate.getMonth() + 1).padStart(2, "0"),
            DD: String(targetDate.getDate()).padStart(2, "0"),
            HH: String(targetDate.getHours()).padStart(2, "0"),
            mm: String(targetDate.getMinutes()).padStart(2, "0"),
            ss: String(targetDate.getSeconds()).padStart(2, "0"),
            h: String(targetDate.getHours() % 12 || 12),
            A: targetDate.getHours() >= 12 ? "PM" : "AM",
          };

          let result = formatString;

          Object.keys(parts).forEach((key) => {
            result = result.replace(new RegExp(key, "g"), parts[key]);
          });

          return result;
        },

        generateSmartRectPath: (w, h, r, style) => {
          const maxR = Math.min(w, h) / 2;
          const tl = Math.min(r.tl, maxR),
            tr = Math.min(r.tr, maxR),
            br = Math.min(r.br, maxR),
            bl = Math.min(r.bl, maxR);

          let path = `M ${tl} 0 L ${w - tr} 0 `;

          if (style === "round") {
            path += tr > 0 ? `A ${tr} ${tr} 0 0 1 ${w} ${tr} ` : `L ${w} 0 `;
            path += `L ${w} ${h - br} `;
            path += br > 0 ? `A ${br} ${br} 0 0 1 ${w - br} ${h} ` : `L ${w} ${h} `;
            path += `L ${bl} ${h} `;
            path += bl > 0 ? `A ${bl} ${bl} 0 0 1 0 ${h - bl} ` : `L 0 ${h} `;
            path += `L 0 ${tl} `;
            path += tl > 0 ? `A ${tl} ${tl} 0 0 1 ${tl} 0 ` : `L 0 0 `;
          } else {
            // Bevel style
            path += `L ${w} ${tr} L ${w} ${h - br} L ${w - br} ${h} L ${bl} ${h} L 0 ${h - bl} L 0 ${tl} L ${tl} 0 `;
          }
          return path + "Z";
        },

        // Liang-Barsky 线段裁剪算法
        clipLine: (x1, y1, x2, y2, left, top, right, bottom) => {
          let t0 = 0.0,
            t1 = 1.0;
          const dx = x2 - x1;
          const dy = y2 - y1;
          const p = [-dx, dx, -dy, dy];
          const q = [x1 - left, right - x1, y1 - top, bottom - y1];

          for (let i = 0; i < 4; i++) {
            if (p[i] === 0) {
              if (q[i] < 0) return null;
            } else {
              const t = q[i] / p[i];
              if (p[i] < 0) {
                if (t > t1) return null;
                if (t > t0) t0 = t;
              } else {
                if (t < t0) return null;
                if (t < t1) t1 = t;
              }
            }
          }

          if (t0 > t1) return null;

          return {
            x1: x1 + t0 * dx,
            y1: y1 + t0 * dy,
            x2: x1 + t1 * dx,
            y2: y1 + t1 * dy,
          };
        },
      };

      // --- 2. App 主逻辑 ---
      const App = {
        canvas: null,
        state: {
          currentPaper: {
            ...CONFIG.SIZES["A4"],
          },
          baseWidth: 0,
          baseHeight: 0,
          zoom: 1,
          isPanning: false,
          clipboard: null,
          pasteCount: 0,
          selectionQueue: [],
          localFontsLoaded: false,
          hasUnsavedChanges: false,
          availabelFonts: [],
          editingBackground: false,
          printCurrentOnly: false,
          isReplacingObject: false,
          dataSource: {
            fileHandle: null,
            fileHandleId: null,
            fileName: "",
            workbook: null,
            sheetNames: [],
            currentSheet: "",
            data: [],
            headers: [],
            isActive: false,
            currentDataIndex: 0,
            imgDirHandle: null,
            imgDirId: null,
            isRequestingPerm: false,
            imgDirCache: {},
          },
          label: {
            mode: "design",
            designContent: null,
          },
        },

        // 初始化应用
        init: function () {
          Coloris({
            el: "#floatBgInput",
            theme: "polaroid",
            themeMode: "light",
            alpha: true,
            format: "hex",
            wrap: false,
            swatches: ["#ffffff", "#666666", "#e11d48", "#2563eb", "#16a34a", "transparent"],
          });

          this.canvas = new fabric.Canvas("paperCanvas", {
            backgroundColor: "#fff",
            preserveObjectStacking: true,
            selection: true,
            enableRetinaScaling: true,
            fireRightClick: true,
            stopContextMenu: true,
            defaultCursor: "default",
            hoverCursor: "move",
          });

          // 全局对象默认样式
          fabric.Object.prototype.set({
            borderColor: "#3b82f6",
            borderScaleFactor: 1.5,
            cornerColor: "white",
            cornerStrokeColor: "#3b82f6",
            borderOpacityWhenMoving: 1,
            cornerSize: 8,
            transparentCorners: false,
            centeredScaling: false,
            uniformScaling: false,
            uniScaleKey: "shiftKey",
            objectCaching: false,
            noScaleCache: false,
          });

          // 自定义旋转控制手柄
          const rotateImg = new Image();
          rotateImg.src = "./static/rotate.png";

          function renderRotationControl(ctx, left, top, styleOverride, fabricObject) {
            if (fabricObject.__corner !== this.name) return;
            const size = this.cornerSize;
            ctx.save();
            ctx.translate(left, top);
            ctx.rotate(fabric.util.degreesToRadians(fabricObject.angle));
            const cornerAngleAdjustment = {
              mtr_tr: 0,
              mtr_br: 90,
              mtr_bl: 180,
              mtr_tl: 270,
            };
            const adjustment = cornerAngleAdjustment[this.name] || 0;
            ctx.rotate(fabric.util.degreesToRadians(adjustment));

            if (rotateImg.complete) {
              ctx.drawImage(rotateImg, -size / 2, -size / 2, size, size);
            } else {
              ctx.beginPath();
              ctx.arc(0, 0, size / 2, 0, 2 * Math.PI);
              ctx.fillStyle = "#ccc";
              ctx.fill();
            }
            ctx.restore();
          }

          function createRotationControl(x, y, name) {
            const offsetDist = 5;
            return new fabric.Control({
              name: name,
              x: x,
              y: y,
              offsetX: x * offsetDist * 2.5,
              offsetY: y * offsetDist * 2.5,
              actionHandler: fabric.controlsUtils.rotationWithSnapping,
              actionName: "rotate",
              cursorStyle: "none",
              render: renderRotationControl,
              cornerSize: 24,
              withConnection: false,
            });
          }

          const applyCustomRotationControls = (controlsConfig) => {
            controlsConfig.mtr_tl = createRotationControl(-0.5, -0.5, "mtr_tl");
            controlsConfig.mtr_tr = createRotationControl(0.5, -0.5, "mtr_tr");
            controlsConfig.mtr_bl = createRotationControl(-0.5, 0.5, "mtr_bl");
            controlsConfig.mtr_br = createRotationControl(0.5, 0.5, "mtr_br");
            delete controlsConfig.mtr;
          };

          applyCustomRotationControls(fabric.Object.prototype.controls);
          applyCustomRotationControls(fabric.Textbox.prototype.controls);

          this.canvas.on("mouse:move", (opt) => {
            const target = this.canvas.getActiveObject();
            if (target && target.__corner !== target._lastHoveredCorner) {
              target._lastHoveredCorner = target.__corner;
              this.canvas.requestRenderAll();
            }
          });
          this.canvas.on("object:removed", (e) => {
            if (App.history.locked) return;
            const target = e.target;
            if (target && target.sharedId && target.syncMode === "share") {
              const sharedId = target.sharedId;
              const lastValue = App.content.compute(target);
              App.canvas.getObjects().forEach((obj) => {
                if (obj.syncMode === "ref" && obj.refId === sharedId) {
                  obj.set({
                    syncMode: "none",
                    refId: null,
                    editable: true,
                    rawContent: lastValue,
                  });
                  App.content.render(obj);
                }
              });
            }
            setTimeout(() => App.dataSource && App.dataSource.refreshBindingState(), 100);
          });

          this.paper.init();
          this.ruler.init();
          this.history.init();
          this.zoom.autoFit();
          this.dataSource.initAutoRefresh();
          this.tableEditor.init();
          this.templates.init();
          this.events.initHotkeys();
          this.events.initEvents();
          if ("queryLocalFonts" in window) setTimeout(() => this.loadLocalFonts(), 1000);
        },

        // --- 历史记录管理 ---
        history: {
          stack: [],
          index: -1,
          locked: false,
          maxSteps: 20,

          init: function () {
            const saveHandler = (e) => {
              const target = e?.target;
              if (!this.locked && (!target || (!target.isGrid && !target.__tableScaling))) this.saveState();
            };
            App.canvas.on({
              "object:modified": saveHandler,
              "object:added": saveHandler,
              "object:removed": saveHandler,
            });
          },

          updateUI: function () {
            const btnUndo = document.getElementById("btnUndo");
            const btnRedo = document.getElementById("btnRedo");
            if (btnUndo && btnRedo) {
              btnUndo.disabled = this.index <= 0;
              btnRedo.disabled = this.index >= this.stack.length - 1;
            }
          },

          saveState: function () {
            if (this.locked) return;
            if (App.state.paperType === "label" && App.state.label.mode === "preview") return;
            if (this.index < this.stack.length - 1) {
              this.stack = this.stack.slice(0, this.index + 1);
            }

            const json = App.canvas.toJSON(CUSTOM_PROPS);
            json.objects = json.objects.filter((o) => !o.isGrid);
            const currentStr = JSON.stringify(json);
            if (this.index >= 0 && this.stack[this.index] === currentStr) {
              return;
            }

            this.stack.push(currentStr);
            if (this.stack.length > this.maxSteps) this.stack.shift();
            else this.index++;
            this.updateUI();
            App.state.hasUnsavedChanges = true;
            setTimeout(() => {
              if (App.dataSource) {
                App.dataSource.updateNavUI();
              }
            }, 0);
          },

          reset: function () {
            this.stack = [];
            this.index = -1;
            this.locked = false;
            this.saveState();
          },

          undo: function () {
            if (this.index <= 0) return;
            this.load(this.stack[--this.index]);
          },

          redo: function () {
            if (this.index >= this.stack.length - 1) return;
            this.load(this.stack[++this.index]);
          },

          load: function (jsonStr) {
            this.locked = true;
            App.canvas.loadFromJSON(jsonStr, () => {
              App.paper.drawGrid();
              App.canvas.renderAll();
              App.ui.updateLayerList();
              App.ui.updateInspector();
              this.locked = false;
              this.updateUI();
            });
          },
        },

        //数据源模块
        dataSource: {
          getCanvasState: function () {
            const objs = App.canvas.getObjects();
            let hasBinding = false;
            let maxSerialCount = 0;

            objs.forEach((o) => {
              if (o.dataBinding && o.dataBinding.type === "variable" && o.dataBinding.field) {
                hasBinding = true;
              }

              if (o.isTable && o.tableData && o.tableData.cells) {
                o.tableData.cells.flat().forEach((cell) => {
                  if (cell.dataBinding && cell.dataBinding.type === "variable" && cell.dataBinding.field) {
                    hasBinding = true;
                  }
                });
              }

              if (o.isSerialNumber && o.serialConfig) {
                maxSerialCount = Math.max(maxSerialCount, o.serialConfig.generateCount || 1);
              }
            });

            return {
              hasBinding,
              maxSerialCount,
            };
          },
          openFile: async function () {
            try {
              const [handle] = await window.showOpenFilePicker({
                types: [
                  {
                    description: "Excel Spreadsheets",
                    accept: {
                      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": [".xlsx"],
                      "application/vnd.ms-excel": [".xls"],
                    },
                  },
                ],
                multiple: false,
              });

              let finalHandleId = null;
              let isExisting = false;

              try {
                const entries = await idbKeyval.entries();

                for (const [key, storedHandle] of entries) {
                  if (storedHandle && storedHandle.kind === "file" && typeof storedHandle.isSameEntry === "function") {
                    const isSame = await handle.isSameEntry(storedHandle);
                    if (isSame) {
                      finalHandleId = key;
                      isExisting = true;
                      break;
                    }
                  }
                }
              } catch (checkErr) {
                console.warn("检查重复句柄失败，将创建新 ID", checkErr);
              }

              if (!finalHandleId) {
                finalHandleId = Utils.generateUniqueId();
              }
              await idbKeyval.set(finalHandleId, handle);
              await this.loadFromHandle(handle, finalHandleId);
            } catch (err) {
              if (err.name !== "AbortError") {
                console.error(err);
                Utils.toast("打开文件失败", "error");
              }
            }
          },

          requestPermissionUI: function (handle) {
            return new Promise((resolve) => {
              const modal = document.getElementById("permissionModal");
              const nameLabel = document.getElementById("permFileName");
              const grantBtn = document.getElementById("permGrantBtn");
              const cancelBtn = document.getElementById("permCancelBtn");

              if (!modal) {
                return resolve(false);
              }

              nameLabel.innerText = handle.name;
              modal.classList.remove("hidden");

              const cleanup = () => {
                modal.classList.add("hidden");
                grantBtn.onclick = null;
                cancelBtn.onclick = null;
              };

              grantBtn.onclick = async () => {
                try {
                  const status = await handle.requestPermission({
                    mode: "read",
                  });
                  cleanup();
                  resolve(status === "granted");
                } catch (e) {
                  console.error(e);
                  cleanup();
                  resolve(false);
                }
              };

              cancelBtn.onclick = () => {
                cleanup();
                Utils.toast("已取消加载数据源", "info");
                resolve(false);
              };
            });
          },

          reloadFromFile: async function () {
            const s = App.state.dataSource;
            let handle = s.fileHandle;
            const handleId = s.fileHandleId;

            if (!handle && handleId) {
              try {
                handle = await idbKeyval.get(handleId);
              } catch (e) {}
            }

            if (handle) {
              await this.loadFromHandle(handle, handleId || s.fileHandleId);
            } else {
              this.openFile();
            }
          },

          loadFromHandle: async function (handle, handleId) {
            let perm = await handle.queryPermission({
              mode: "read",
            });
            if (perm !== "granted") {
              const granted = await this.requestPermissionUI(handle);
              if (!granted) {
                this.close();
                return;
              }
            }

            try {
              App.canvas.renderOnAddRemove = false;
              let file;
              try {
                file = await handle.getFile();
              } catch (fileErr) {
                if (fileErr.name === "NotFoundError" || fileErr.name === "NotReadableError") {
                  if (handleId) await idbKeyval.del(handleId);
                  Utils.toast(`文件已失效: ${handle.name}`, "error");
                  this.close();
                  return;
                }
                throw fileErr;
              }

              App.state.dataSource.lastModified = file.lastModified;
              const arrayBuffer = await file.arrayBuffer();

              const workbook = XLSX.read(arrayBuffer, {
                type: "array",
                cellNF: true,
                cellStyles: true,
                cellText: true,
                cellDates: false,
                cellFormula: false,
              });

              const validSheetNames = workbook.SheetNames.filter((name) => {
                const ws = workbook.Sheets[name];

                return ws["!ref"];
              });

              if (validSheetNames.length === 0) {
                Utils.toast("导入失败：表格内容为空", "error");
                this.close();
                return;
              }

              const s = App.state.dataSource;
              s.fileHandle = handle;
              s.fileHandleId = handleId;
              s.fileName = handle.name;
              s.workbook = workbook;
              s.sheetNames = validSheetNames;
              s.isActive = true;
              this._sheetCache = {};
              if (!s.currentSheet || !s.sheetNames.includes(s.currentSheet)) {
                s.currentSheet = s.sheetNames[0];
              }

              this.processCurrentSheet(true);

              const act = App.canvas.getActiveObject();
              if (act && act.dataBinding && act.dataBinding.type === "variable" && s.headers.length > 0) {
                act.dataBinding.sheet = s.currentSheet;
                act.dataBinding.field = s.headers[0];
                setTimeout(() => App.ui.updateInspector(), 0);
              }

              await this.renderPage(0);
              this.updateNavUI();
            } catch (e) {
              console.error(e);
              Utils.toast("文件读取失败", "error");
              this.close();
            } finally {
              App.canvas.renderOnAddRemove = true;
              App.canvas.requestRenderAll();
            }
          },

          processCurrentSheet: function (skipRender = false) {
            const s = App.state.dataSource;
            if (!s.isActive || !s.workbook) return;
            const worksheet = s.workbook.Sheets[s.currentSheet];

            const jsonHeader = XLSX.utils.sheet_to_json(worksheet, {
              header: 1,
            });

            s.data = [];
            s.headers = [];

            if (jsonHeader.length > 0) {
              s.headers = jsonHeader[0].map((h) => String(h || "").trim());

              s.data = XLSX.utils.sheet_to_json(worksheet, {
                raw: false,
                dateNF: "yyyy-mm-dd",
                defval: "",
              });
            }

            let idx = parseInt(App.state.currentDataIndex) || 0;
            if (idx >= s.data.length) idx = 0;
            if (idx < 0) idx = 0;

            App.state.currentDataIndex = idx;

            if (!skipRender) {
              this.renderPage(idx);
              this.updateUI();
            } else {
              this.updateUI();
            }
          },

          changeSheet: function (sheetName) {
            const s = App.state.dataSource;
            s.currentSheet = sheetName;

            if (s.isActive && s.workbook) {
              const worksheet = s.workbook.Sheets[sheetName];
              const jsonHeader = XLSX.utils.sheet_to_json(worksheet, {
                header: 1,
              });
              s.data = [];
              s.headers = [];
              if (jsonHeader.length > 0) {
                s.headers = jsonHeader[0].map((h) => String(h || "").trim());

                s.data = XLSX.utils.sheet_to_json(worksheet, {
                  raw: false,
                  dateNF: "yyyy-mm-dd",
                  defval: "",
                });
              }
            }

            this.updateUI();
            this.updateNavUI();
          },

          calculateTotalPages: function () {
            const s = App.state.dataSource;
            const cfg = App.paper.getSettings();

            const canvasState = this.getCanvasState();

            if (App.state.paperType === "label" && App.state.label.mode === "preview") {
              const baseCount = s.isActive && s.data.length > 0 ? s.data.length : 1;
              const totalItems = baseCount * cfg.labelQuantity;
              const itemsPerPage = Math.max(1, cfg.labelCols * cfg.labelRows);
              return Math.max(1, Math.ceil(totalItems / itemsPerPage));
            }

            if (s.isActive && canvasState.hasBinding && s.workbook) {
              const objs = App.canvas.getObjects();
              let boundSheetName = null;

              const findBoundSheet = (target) => {
                if (target.dataBinding && target.dataBinding.type === "variable" && target.dataBinding.sheet) {
                  return target.dataBinding.sheet;
                }
                if (target.isTable && target.tableData && target.tableData.cells) {
                  for (let r of target.tableData.cells) {
                    for (let c of r) {
                      if (c.dataBinding && c.dataBinding.type === "variable" && c.dataBinding.sheet) return c.dataBinding.sheet;
                    }
                  }
                }
                return null;
              };

              for (const o of objs) {
                boundSheetName = findBoundSheet(o);
                if (boundSheetName) break;
              }

              if (boundSheetName && s.workbook.Sheets[boundSheetName]) {
                if (!this._sheetCache) this._sheetCache = {};
                if (!this._sheetCache[boundSheetName]) {
                  this._sheetCache[boundSheetName] = XLSX.utils.sheet_to_json(s.workbook.Sheets[boundSheetName]);
                }
                const len = this._sheetCache[boundSheetName].length;
                if (len > 0) return len;
              }

              if (s.data.length > 0) return s.data.length;
            }

            if (App.state.paperType === "label" && App.state.label.mode === "design") return 1;

            if (canvasState.maxSerialCount > 1) return canvasState.maxSerialCount;

            return 1;
          },

          close: async function () {
            App.state.dataSource = {
              fileHandle: null,
              fileHandleId: null,
              fileName: "",
              workbook: null,
              sheetNames: [],
              currentSheet: "",
              data: [],
              headers: [],
              isActive: false,
            };
            this.updateUI();
            this.renderPage(0);
            this.updateNavUI();
          },

          updateUI: function () {
            const s = App.state.dataSource;
            const noData = document.getElementById("noDataState");
            const loaded = document.getElementById("dataLoadedState");
            const fileNameEl = document.getElementById("dsFileName");
            const sheetSel = document.getElementById("dsSheetSelect");
            const rowCount = document.getElementById("dsRowCount");
            const fieldList = document.getElementById("dsFieldList");

            if (!s.isActive) {
              noData.classList.remove("hidden");
              loaded.classList.add("hidden");
              return;
            }

            noData.classList.add("hidden");
            loaded.classList.remove("hidden");
            loaded.classList.add("flex");

            fileNameEl.innerText = s.fileName;
            sheetSel.innerHTML = "";
            s.sheetNames.forEach((name) => {
              const opt = document.createElement("option");
              opt.value = name;
              opt.innerText = name;
              if (name === s.currentSheet) opt.selected = true;
              sheetSel.appendChild(opt);
            });

            rowCount.innerText = `${s.data.length} 条数据`;

            fieldList.innerHTML = "";
            if (s.headers.length === 0) {
              fieldList.innerHTML = '<li class="text-center text-gray-400 py-4 text-xs">暂无字段</li>';
            } else {
              s.headers.forEach((h) => {
                const li = document.createElement("li");
                li.className = "text-xs bg-white border border-gray-200 rounded px-2 py-1.5 text-slate-600 font-mono flex items-center gap-2";
                li.innerHTML = `<i class="ph ph-brackets-curly text-slate-300"></i> ${h}`;
                li.draggable = true;
                li.dataset.field = h;
                li.dataset.sheet = s.currentSheet;
                fieldList.appendChild(li);
              });
            }
          },
          batchUpdateBinding: function () {
            const s = App.state.dataSource;
            if (!s.isActive || !s.currentSheet) return Utils.toast("请先加载数据源", "error");

            const targetSheet = s.currentSheet;
            const validFields = s.headers;

            if (!validFields || validFields.length === 0) return Utils.toast("目标工作表为空或无字段", "error");

            let count = 0;

            const tryUpdate = (binding) => {
              if (binding && binding.type === "variable") {
                if (validFields.includes(binding.field)) {
                  if (binding.sheet !== targetSheet) {
                    binding.sheet = targetSheet;
                    return true;
                  }
                }
              }
              return false;
            };

            if (App.state.paperType === "label" && App.state.label.mode === "preview") {
              const designJSON = App.state.label.designContent;
              if (!designJSON || !designJSON.objects) return;

              designJSON.objects.forEach((obj) => {
                if (tryUpdate(obj.dataBinding)) count++;

                if (obj.isTable && obj.tableData && obj.tableData.cells) {
                  obj.tableData.cells.flat().forEach((cell) => {
                    if (tryUpdate(cell.dataBinding)) count++;
                  });
                }
              });

              if (count > 0) {
                App.label.renderPreview();
                Utils.toast(`已更新${count}个字段`);
              } else {
                Utils.toast("未找到可匹配字段或无需更新", "info");
              }
              return;
            }

            const objs = App.canvas.getObjects();
            objs.forEach((obj) => {
              let updated = false;

              if (tryUpdate(obj.dataBinding)) {
                updated = true;
              }

              if (obj.isTable && obj.tableData && obj.tableData.cells) {
                obj.tableData.cells.flat().forEach((cell) => {
                  if (tryUpdate(cell.dataBinding)) updated = true;
                });

                if (updated) {
                  App.tableEditor._replaceTableOnCanvas(obj, obj.tableData);
                  updated = false;
                  count++;
                }
              }

              if (updated) count++;
            });

            if (count > 0) {
              this.refreshBindingState();
              App.ui.updateInspector();
              App.history.saveState();
              Utils.toast(`已更新 ${count} 个字段`);
            } else {
              Utils.toast("未找到可匹配字段或无需更新", "info");
            }
          },

          renderPage: async function (pageIndex) {
            const s = App.state.dataSource;
            if (App.state.paperType === "label" && App.state.label.mode === "preview") return;
            const max = this.calculateTotalPages();
            pageIndex = Math.max(0, Math.min(pageIndex, max - 1));
            if (max === 0) pageIndex = 0;
            App.state.currentDataIndex = pageIndex;
            if (!this._sheetCache) this._sheetCache = {};

            if (s.isActive && s.workbook) {
              const objs = App.canvas.getObjects();
              const sheetsToCache = new Set();

              // 收集所有需要的工作表
              objs.forEach((obj) => {
                if (obj.dataBinding?.type === "variable" && obj.dataBinding.sheet) {
                  sheetsToCache.add(obj.dataBinding.sheet);
                }
                if (obj.isTable && obj.tableData?.cells) {
                  obj.tableData.cells.flat().forEach((cell) => {
                    if (cell.dataBinding?.type === "variable" && cell.dataBinding.sheet) {
                      sheetsToCache.add(cell.dataBinding.sheet);
                    }
                  });
                }
              });

              // 预先缓存所有工作表
              sheetsToCache.forEach((sheetName) => {
                if (!this._sheetCache[sheetName]) {
                  const ws = s.workbook.Sheets[sheetName];
                  if (ws) {
                    this._sheetCache[sheetName] = XLSX.utils.sheet_to_json(ws, {
                      raw: false,
                      dateNF: "yyyy-mm-dd",
                      defval: "",
                    });
                  }
                }
              });
            }

            const objs = App.canvas.getObjects();
            const updateTasks = [];
            for (const obj of objs) {
              if (obj.type === "image" && obj.dataBinding && obj.dataBinding.type === "variable") {
                if (obj.type === "image" && obj.dataBinding && obj.dataBinding.type === "variable") {
                  const originalSheet = obj.dataBinding.sheet;
                  const filename = this._getBoundValue(obj, pageIndex);

                  if (obj.dataBinding.sheet !== originalSheet) {
                    obj.dataBinding.sheet = originalSheet;
                  }

                  if (obj._lastRenderedFile !== filename || !obj._imgLoaded) {
                    updateTasks.push(this._updateImageAsync(obj, filename));
                  }
                  continue;
                }
              }

              if (obj.isTable && obj.tableData) {
                this._updateTableData(obj, pageIndex);
                continue;
              }

              let newRaw = null;
              let hasNewData = false;
              if (obj.isDynamicPageNum && obj.pageConfig) {
                const currentPage = pageIndex + (obj.pageConfig.startFrom || 1);
                const totalPages = max || 1;
                newRaw = obj.pageConfig.format.replace("{page}", currentPage).replace("{total}", totalPages);
                hasNewData = true;
              } else if (obj.isSerialNumber && obj.serialConfig) {
                newRaw = App.tools._calculateSerialNumber(obj.serialConfig, pageIndex);
                hasNewData = true;
              } else if (obj.isDynamicDate && obj.dateConfig) {
                newRaw = Utils.formatDate(new Date(), null, obj.dateConfig);
                hasNewData = true;
              } else if (obj.dataBinding?.type === "variable") {
                const val = this._getBoundValue(obj, pageIndex);
                if (val !== null) {
                  newRaw = String(val);
                  hasNewData = true;
                }
              }

              if (hasNewData) {
                obj.rawContent = newRaw;
                const task = App.content.render(obj);
                if (task instanceof Promise) {
                  updateTasks.push(task);
                }
              } else if (obj.syncMode === "ref") {
                App.content.render(obj);
              }
            }

            if (updateTasks.length > 0) {
              await Promise.all(updateTasks);
            }

            App.canvas.requestRenderAll();
            this.updateNavUI();
          },

          _getBoundValue: function (obj, pageIndex) {
            const binding = obj.dataBinding;
            if (!binding || binding.type !== "variable" || !binding.field) return null;

            const s = App.state.dataSource;
            const targetSheet = binding.sheet || s.currentSheet;

            if (!this._sheetCache[targetSheet]) {
              const ws = s.workbook?.Sheets[targetSheet];
              if (ws) {
                this._sheetCache[targetSheet] = XLSX.utils.sheet_to_json(ws, {
                  raw: false,
                  dateNF: "yyyy-mm-dd",
                  defval: "",
                });
              } else {
                return null;
              }
            }

            const rowData = this._sheetCache[targetSheet][pageIndex];
            if (!rowData) return "";

            const val = rowData[binding.field];
            return val !== undefined && val !== null ? String(val) : "";
          },

          _updateTableData: function (tableObj, pageIndex) {
            if (!tableObj.tableData || !tableObj.tableData.cells) return false;

            let tableChanged = false;

            tableObj.tableData.cells.forEach((row) => {
              row.forEach((cell) => {
                const mockObj = { dataBinding: cell.dataBinding };
                const val = this._getBoundValue(mockObj, pageIndex);
                if (val !== null) {
                  if (cell.text !== val) {
                    cell.text = val;
                    tableChanged = true;
                  }
                }
                if (cell.syncMode === "ref" && cell.refId) {
                  const refVal = App.content.getSharedValue(cell.refId);
                  if (refVal !== undefined && cell.text !== refVal) {
                    cell.text = refVal;
                    tableChanged = true;
                  }
                }
              });
            });

            if (tableChanged) {
              App.tableEditor._replaceTableOnCanvas(tableObj, tableObj.tableData);
            }

            return tableChanged;
          },
          _updateImageAsync: async function (obj, filename) {
            obj._lastRenderedFile = filename;
            obj._imgLoaded = true;

            let blobUrl = null;

            if (filename && obj.imgDirId) {
              try {
                const blob = await this.getImageBlob(filename, obj.imgDirId);
                if (blob) {
                  blobUrl = URL.createObjectURL(blob);
                }
              } catch (e) {
                console.warn("Load img failed", e);
              }
            }

            if (!blobUrl) {
              const errSvg = `<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100" viewBox="0 0 100 100" fill="#f3f4f6">
                            <rect width="100" height="100" fill="#f3f4f6" stroke="#d1d5db" stroke-width="2"/>
                            <text x="50" y="50" font-family="sans-serif" font-size="10" fill="#9ca3af" text-anchor="middle">加载失败</text>
                            <text x="50" y="62" font-family="sans-serif" font-size="10" fill="#9ca3af" text-anchor="middle">${filename || "未找到绑定字段"}</text></svg>`;
              blobUrl = "data:image/svg+xml;charset=utf-8," + encodeURIComponent(errSvg);
            }

            return new Promise((resolve) => {
              const targetVisualWidth = obj.getScaledWidth();

              const { left, top, angle, originX, originY } = obj;

              obj.setSrc(blobUrl, (newImg) => {
                newImg.set({
                  left,
                  top,
                  angle,
                  originX,
                  originY,
                });
                if (newImg.width > 0) {
                  const newScale = targetVisualWidth / newImg.width;
                  newImg.scaleX = newScale;
                  newImg.scaleY = newScale;
                }

                resolve();
              });
            });
          },
          _updateBarcodeAsync: async function (obj) {
            try {
              const newObj = await App.barcode.createOrUpdate(obj, obj.barcodeConfig);
              App.ui._replaceObject(obj, newObj);
            } catch (err) {
              console.warn("VDP Barcode Update Failed:", err);
            }
          },

          nav: async function (action, val) {
            const isLabelPreview = App.state.paperType === "label" && App.state.label.mode === "preview";

            if (isLabelPreview) {
              const cfg = App.paper.getSettings();
              const ds = App.state.dataSource;
              let totalCount = cfg.labelQuantity;
              if (ds.isActive && ds.data.length > 0) {
                totalCount = ds.data.length * cfg.labelQuantity;
              }
              const itemsPerPage = cfg.labelCols * cfg.labelRows;
              const maxPages = Math.ceil(totalCount / itemsPerPage);
              let current = App.state.label.previewPage || 0;

              let next = current;
              switch (action) {
                case "first":
                  next = 0;
                  break;
                case "prev":
                  next = current - 1;
                  break;
                case "next":
                  next = current + 1;
                  break;
                case "last":
                  next = maxPages - 1;
                  break;
                case "goto":
                  next = parseInt(val) - 1;
                  break;
              }

              App.state.label.previewPage = Math.max(0, Math.min(next, maxPages - 1));
              await App.label.renderPreview();
              return;
            }

            const current = App.state.currentDataIndex;
            const max = this.calculateTotalPages();
            let next = current;

            switch (action) {
              case "first":
                next = 0;
                break;
              case "prev":
                next = current - 1;
                break;
              case "next":
                next = current + 1;
                break;
              case "last":
                next = max - 1;
                break;
              case "goto":
                next = parseInt(val) - 1;
                break;
            }
            this.renderPage(next);
          },

          updateNavUI: function () {
            const max = this.calculateTotalPages();

            let current = App.state.currentDataIndex;
            if (current >= max) {
              current = max - 1;
              App.state.currentDataIndex = current;
            }
            if (current < 0) current = 0;

            const navBar = document.getElementById("dataNavBar");
            const input = document.getElementById("vdpIndexInput");
            const total = document.getElementById("vdpTotal");

            if (max > 1) {
              navBar.classList.remove("hidden");

              if (App.state.paperType === "label" && App.state.label.mode === "preview") {
                input.value = (App.state.label.previewPage || 0) + 1;
              } else {
                input.value = current + 1;
              }
              total.innerText = max;
            } else {
              navBar.classList.add("hidden");
            }
          },

          refreshBindingState: function () {
            this._sheetCache = {};
            this.renderPage(App.state.currentDataIndex);
          },

          initAutoRefresh: function () {
            const check = Utils.throttle(() => this.checkFileUpdate(), 1000);
            window.addEventListener("focus", check);
            document.addEventListener("visibilitychange", () => {
              if (document.visibilityState === "visible") check();
            });
          },

          checkFileUpdate: async function () {
            const s = App.state.dataSource;
            if (!s.isActive || !s.fileHandle || !s.workbook) return;
            try {
              const perm = await s.fileHandle.queryPermission({
                mode: "read",
              });
              if (perm !== "granted") return;

              const file = await s.fileHandle.getFile();
              if (file.lastModified > s.lastModified + 1000) {
                Utils.toast("数据源已更新！");
                await this.loadFromHandle(s.fileHandle, s.fileHandleId);
              }
            } catch (e) {}
          },

          syncFromProject: async function (meta) {
            if (!meta || !meta.fileHandleId) {
              this.close();
              return;
            }
            const { fileHandleId, fileName, currentSheet } = meta;
            App.state.dataSource.currentSheet = currentSheet;

            try {
              const handle = await idbKeyval.get(fileHandleId);
              if (handle) {
                await this.loadFromHandle(handle, fileHandleId);
              } else {
                Utils.toast(`无法找到关联文件: ${fileName}`, "error");
                this.close();
              }
            } catch (e) {
              console.error("DB Error", e);
              this.close();
            }
          },
          selectImageDir: async function () {
            const act = App.canvas.getActiveObject();
            if (!act || act.type !== "image") return Utils.toast("请先选中一个图片对象", "error");
            try {
              const handle = await window.showDirectoryPicker({
                id: "vdp_images_dir_common",
                mode: "read",
              });
              let finalHandleId = null;
              try {
                const entries = await idbKeyval.entries();
                for (const [key, storedHandle] of entries) {
                  if (storedHandle && storedHandle.kind === "directory" && typeof storedHandle.isSameEntry === "function") {
                    const isSame = await handle.isSameEntry(storedHandle);
                    if (isSame) {
                      finalHandleId = key;
                      break;
                    }
                  }
                }
              } catch (checkErr) {
                console.warn("检查重复文件夹句柄失败，将创建新 ID", checkErr);
              }

              if (!finalHandleId) {
                finalHandleId = Utils.generateUniqueId();
                await idbKeyval.set(finalHandleId, handle);
              } else {
                await idbKeyval.set(finalHandleId, handle);
              }

              if (!App.state.dataSource.imgDirCache) {
                App.state.dataSource.imgDirCache = {};
              }
              App.state.dataSource.imgDirCache[finalHandleId] = handle;
              act.set({
                imgDirId: finalHandleId,
                imgDirName: handle.name,
              });
              Utils.toast(`已绑定文件夹: ${handle.name}`);
              const binding = act.dataBinding;
              if (binding && binding.type === "variable") {
                const pageIndex = App.state.currentDataIndex || 0;
                const val = this._getBoundValue(act, pageIndex);
                if (val) {
                  await this._updateImageAsync(act, val);
                  App.canvas.renderAll();
                }
              }

              App.ui.updateInspector();
              App.history.saveState();
            } catch (err) {
              if (err.name !== "AbortError") {
                console.error(err);
                Utils.toast("无法访问文件夹", "error");
              }
            }
          },

          restoreImageDir: async function (savedId) {
            if (!savedId) return;
            try {
              const handle = await idbKeyval.get(savedId);
              if (handle) {
                this.imgDirId = savedId;
                App.state.dataSource.imgDirHandle = handle;
              }
            } catch (e) {
              console.warn("Restore ImgDir Failed", e);
            }
          },

          getImageBlob: async function (filename, dirId) {
            if (!filename || !dirId) return null;
            if (!App.state.dataSource.imgDirCache) {
              App.state.dataSource.imgDirCache = {};
            }
            let handle = App.state.dataSource.imgDirCache[dirId];
            if (!handle) {
              try {
                handle = await idbKeyval.get(dirId);
                if (handle) {
                  App.state.dataSource.imgDirCache[dirId] = handle;
                }
              } catch (e) {
                console.warn("读取文件夹句柄失败", e);
              }
            }

            if (!handle) return null;
            let perm = "prompt";
            try {
              perm = await handle.queryPermission({ mode: "read" });
            } catch (e) {
              console.warn("Permission query failed", e);
            }

            if (perm !== "granted") {
              if (this.isRequestingPerm) return null;
              this.isRequestingPerm = true;
              const granted = await this.requestPermissionUI(handle);
              this.isRequestingPerm = false;
              if (!granted) return null;
            }

            try {
              const fileHandle = await handle.getFileHandle(filename);
              return await fileHandle.getFile();
            } catch (e) {
              return null;
            }
          },
        },

        // --- 纸张与网格系统 ---
        paper: {
          // 纸张类型默认参数配置
          defaults: {
            blank: {
              label: "空白纸",
            },
            ruled: {
              label: "横线纸",
              rowCount: 20,
              strokeWidth: 1,
              gridColor: "#e11d48",
              doubleFirst: true,
              doubleLast: true,
              ruledClosed: false,
            },
            grid: {
              label: "方格纸",
              gridColumns: 24,
              strokeWidth: 1,
              gridColor: "#e11d48",
              doubleBorder: true,
              gridDashed: false,
            },
            composition: {
              label: "作文纸",
              columnCount: 12,
              rowCount: 15,
              strokeWidth: 1,
              gridColor: "#e11d48",
              doubleBorder: true,
            },
            english: {
              label: "英文纸",
              rowCount: 10,
              englishLineGap: 3,
              englishGroupGap: 10,
              englishOffset: 0,
              strokeWidth: 1,
            },
            music: {
              label: "乐谱纸",
              staffCount: 12,
              staffLineGap: 2.5,
              staffGroupGap: 12,
              strokeWidth: 1,
              staffLineCount: 5,
              gridColor: "#8a91a8",
            },
            tianzige: {
              label: "田字格",
              tianSize: 18,
              tianInnerScale: 0.5,
              strokeWidth: 1,
              doubleBorder: true,
              gridDashed: true,
            },
            mizige: {
              label: "米字格",
              tianSize: 18,
              tianInnerScale: 0.5,
              strokeWidth: 1,
              doubleBorder: true,
              gridDashed: true,
            },
            huizige: {
              label: "回字格",
              tianSize: 18,
              tianInnerScale: 0.4,
              strokeWidth: 1,
              doubleBorder: true,
              huiInnerW: 8,
              huiInnerH: 10,
              gridDashed: true,
            },
            jiugongge: {
              label: "宫格纸",
              tianSize: 18,
              tianInnerScale: 0.4,
              strokeWidth: 1,
              doubleBorder: true,
              jiuCols: 3,
              jiuRows: 3,
            },
            dots: {
              label: "点阵纸",
              dotSpace: 5,
              dotSize: 0.5,
              gridColor: "#e11d48",
              marginTop: 0,
              marginBottom: 0,
              marginLeft: 0,
              marginRight: 0,
              otStagger: false,
            },
            triangle: {
              label: "等距网格",
              geoSize: 10,
              strokeWidth: 1,
              gridColor: "#e11d48",
              marginTop: 0,
              marginBottom: 0,
              marginLeft: 0,
              marginRight: 0,
            },
            hexagon: {
              label: "六边形网格",
              strokeWidth: 1,
              gridColor: "#e11d48",
              marginTop: 0,
              marginBottom: 0,
              marginLeft: 0,
              marginRight: 0,
            },
            label: {
              label: "标签打印",
              labelWidth: 105,
              labelHeight: 74.2,
              labelCols: 2,
              labelRows: 4,
              labelGapH: 0,
              labelGapV: 0,
              marginTop: 0,
              marginBottom: 0,
              marginLeft: 0,
              marginRight: 0,
              labelQuantity: 1,
            },
          },

          renderers: {
            // 0.空白纸渲染器
            blank: function (cfg, canvas) {
              return;
            },
            // 1. 横线纸渲染器
            ruled: function (cfg, canvas, opts = {}) {
              if (cfg.rowCount <= 0) return;

              const GAP = 3;
              const thickW = cfg.strokeWidth + 2;

              const padTop = cfg.doubleFirst ? GAP + thickW / 2 : cfg.strokeWidth / 2;
              const padBottom = cfg.doubleLast ? GAP + thickW / 2 : cfg.strokeWidth / 2;
              const padX = cfg.ruledClosed && cfg.ruledClosedDouble ? GAP + thickW / 2 : cfg.strokeWidth / 2;

              const startX = Math.max(cfg.marginLeft, padX);
              const endX = App.state.baseWidth - Math.max(cfg.marginRight, padX);
              const startY = Math.max(cfg.marginTop, padTop) + (opts.startYOffset || 0);
              const contentHeight = App.state.baseHeight - Math.max(cfg.marginBottom, padBottom) - startY;

              if (endX - startX <= 0 || contentHeight <= 0) return;

              const lineHeight = contentHeight / cfg.rowCount;
              const gridLines = [];
              const dashArr = cfg.gridDashed ? [cfg.gridDashArray, cfg.gridDashArray] : null;

              // 计算闭合边框的坐标边界
              const outerTop = cfg.doubleFirst ? startY - GAP : startY;
              const outerBottom = cfg.doubleLast ? startY + cfg.rowCount * lineHeight + GAP : startY + cfg.rowCount * lineHeight;
              const innerTop = cfg.doubleFirst ? startY + GAP : startY;
              const innerBottom = cfg.doubleLast ? startY + cfg.rowCount * lineHeight - GAP : startY + cfg.rowCount * lineHeight;

              let xOuterL = startX,
                xOuterR = endX;
              let xInnerL = startX,
                xInnerR = endX;

              if (cfg.ruledClosed && cfg.ruledClosedDouble) {
                xOuterL = startX - GAP;
                xOuterR = endX + GAP;
                xInnerL = startX + GAP;
                xInnerR = endX - GAP;
              }

              const addLine = (y, w, xStart, xEnd, extra = {}) => {
                gridLines.push(
                  new fabric.Line([xStart, y, xEnd, y], {
                    stroke: cfg.gridColor,
                    strokeWidth: w,
                    selectable: false,
                    evented: false,
                    isGrid: true,
                    strokeLineCap: "butt",
                    excludeFromExport: true,
                    originX: "center",
                    originY: "center",
                    ...extra,
                  })
                );
              };

              for (let i = 0; i <= cfg.rowCount; i++) {
                const y = startY + i * lineHeight;
                if (i === 0 && cfg.doubleFirst) {
                  addLine(y - GAP, thickW, xOuterL, xOuterR);
                  addLine(y + GAP, Math.max(1, cfg.strokeWidth), xInnerL, xInnerR);
                } else if (i === cfg.rowCount && cfg.doubleLast) {
                  addLine(y - GAP, Math.max(1, cfg.strokeWidth), xInnerL, xInnerR);
                  addLine(y + GAP, thickW, xOuterL, xOuterR);
                } else {
                  addLine(
                    y,
                    cfg.strokeWidth,
                    xInnerL,
                    xInnerR,
                    dashArr && i > 0 && i < cfg.rowCount
                      ? {
                          strokeDashArray: dashArr,
                        }
                      : {}
                  );
                }
              }

              if (cfg.ruledClosed) {
                const edgeBase = {
                  stroke: cfg.gridColor,
                  selectable: false,
                  evented: false,
                  isGrid: true,
                  excludeFromExport: true,
                  originX: "center",
                  originY: "center",
                  strokeLineCap: "butt",
                };
                const extendDist = thickW / 2;
                const outerY1 = outerTop - extendDist;
                const outerY2 = outerBottom + extendDist;

                const drawEdge = (x, side) => {
                  if (cfg.ruledClosedDouble) {
                    const outerX = side === "left" ? x - GAP : x + GAP;
                    const innerX = side === "left" ? x + GAP : x - GAP;
                    const innerY1 = innerTop - Math.max(1, cfg.strokeWidth) / 2;
                    const innerY2 = innerBottom + Math.max(1, cfg.strokeWidth) / 2;
                    return [
                      new fabric.Line([outerX, outerY1, outerX, outerY2], {
                        ...edgeBase,
                        strokeWidth: thickW,
                      }),
                      new fabric.Line([innerX, innerY1, innerX, innerY2], {
                        ...edgeBase,
                        strokeWidth: Math.max(1, cfg.strokeWidth),
                      }),
                    ];
                  }
                  return [
                    new fabric.Line([x, outerY1, x, outerY2], {
                      ...edgeBase,
                      strokeWidth: Math.max(1, cfg.strokeWidth),
                    }),
                  ];
                };
                [...drawEdge(startX, "left"), ...drawEdge(endX, "right")].forEach((l) => gridLines.push(l));
              }

              gridLines.forEach((l) => {
                canvas.add(l);
                canvas.sendToBack(l);
              });
            },

            // 2. 英文纸渲染器
            english: function (cfg, canvas) {
              const startX = cfg.marginLeft;
              const endX = App.state.baseWidth - cfg.marginRight;
              const startY = cfg.marginTop + cfg.englishOffset;
              const usableHeight = App.state.baseHeight - startY - cfg.marginBottom;
              if (usableHeight <= 0 || endX - startX <= 0) return;

              const lineGap = Math.max(cfg.englishLineGap, 1);
              const groupGap = Math.max(0, cfg.englishGroupGap ?? cfg.englishLineGap);
              const cellHeight = lineGap * 3;
              const maxGroups = Math.max(0, Math.floor((usableHeight + groupGap) / (cellHeight + groupGap)));
              const staffCount = Math.min(cfg.rowCount, maxGroups);
              if (staffCount <= 0) return;

              const dashArr = cfg.gridDashed ? [cfg.gridDashArray, cfg.gridDashArray] : null;
              const lines = [];

              for (let s = 0; s < staffCount; s++) {
                const base = startY + s * (cellHeight + groupGap);
                for (let i = 0; i < 4; i++) {
                  const y = base + i * lineGap;
                  lines.push(
                    new fabric.Line([startX, y, endX, y], {
                      stroke: cfg.gridColor,
                      strokeWidth: cfg.strokeWidth,
                      strokeDashArray: i === 2 || !dashArr ? null : dashArr,
                      selectable: false,
                      evented: false,
                      isGrid: true,
                      excludeFromExport: true,
                      originX: "center",
                      originY: "center",
                    })
                  );
                }
              }
              lines.forEach((l) => {
                canvas.add(l);
                canvas.sendToBack(l);
              });
            },

            // 3. 方格纸渲染器
            grid: function (cfg, canvas) {
              const startX = cfg.marginLeft;
              const endX = App.state.baseWidth - cfg.marginRight;
              const startY = cfg.marginTop;
              const endY = App.state.baseHeight - cfg.marginBottom;
              if (endX - startX <= 0 || endY - startY <= 0) return;

              const cols = Math.max(1, cfg.gridColumns || 1);
              const cellSizeX = (endX - startX) / cols;
              let rows = Math.max(1, Math.round((endY - startY) / cellSizeX));
              let cellSize = (endY - startY) / rows;
              cellSize = Math.min(cellSize, cellSizeX);
              rows = Math.max(1, Math.round((endY - startY) / cellSize));
              cellSize = (endY - startY) / rows;

              const gridW = cellSize * cols;
              const gridH = endY - startY;
              const dash = cfg.gridDashed ? [cfg.gridDashArray, cfg.gridDashArray] : null;
              const lines = [];

              for (let i = 1; i < cols; i++) {
                const x = startX + i * cellSize;
                lines.push(
                  new fabric.Line([x, startY, x, startY + gridH], {
                    stroke: cfg.gridColor,
                    strokeWidth: cfg.strokeWidth,
                    strokeDashArray: dash,
                    selectable: false,
                    evented: false,
                    isGrid: true,
                    excludeFromExport: true,
                    originX: "center",
                    originY: "center",
                    strokeLineCap: "butt",
                  })
                );
              }
              for (let j = 1; j < rows; j++) {
                const y = startY + j * cellSize;
                lines.push(
                  new fabric.Line([startX, y, startX + gridW, y], {
                    stroke: cfg.gridColor,
                    strokeWidth: cfg.strokeWidth,
                    strokeDashArray: dash,
                    selectable: false,
                    evented: false,
                    isGrid: true,
                    excludeFromExport: true,
                    originX: "center",
                    originY: "center",
                    strokeLineCap: "butt",
                  })
                );
              }

              this._drawBorder(canvas, startX, startY, gridW, gridH, cfg);

              lines.forEach((l) => {
                canvas.add(l);
                canvas.sendToBack(l);
              });
            },

            // 4. 作文纸渲染器
            composition: function (cfg, canvas) {
              if (cfg.rowCount <= 0) return;
              const startX = cfg.marginLeft;
              const startY = cfg.marginTop;
              const availW = App.state.baseWidth - cfg.marginLeft - cfg.marginRight;
              const availH = App.state.baseHeight - cfg.marginTop - cfg.marginBottom;

              if (availW <= 0 || availH <= 0) return;

              const colCount = Math.max(1, cfg.columnCount);
              const rowCount = Math.max(1, cfg.rowCount);

              const cellW = availW / colCount;
              const totalRowH = availH / rowCount;

              const cellH = totalRowH * 0.75;

              const lines = [];
              const hLineOpts = {
                stroke: cfg.gridColor,
                strokeWidth: cfg.strokeWidth,
                selectable: false,
                evented: false,
                isGrid: true,
                excludeFromExport: true,
                originX: "center",
                originY: "center",
                strokeLineCap: "butt",
              };

              for (let r = 0; r < rowCount; r++) {
                const currentTop = startY + r * totalRowH;
                const currentBottom = currentTop + cellH;

                for (let c = 1; c < colCount; c++) {
                  const x = startX + c * cellW;
                  lines.push(new fabric.Line([x, currentTop, x, currentBottom], hLineOpts));
                }

                lines.push(new fabric.Line([startX, currentTop, startX + availW, currentTop], hLineOpts));
                lines.push(new fabric.Line([startX, currentBottom, startX + availW, currentBottom], hLineOpts));
              }

              this._drawBorder(canvas, startX, startY, availW, availH, cfg);

              lines.forEach((l) => {
                canvas.add(l);
                canvas.sendToBack(l);
              });
            },

            //5.乐谱纸渲染器
            music: function (cfg, canvas) {
              const startX = cfg.marginLeft;
              const endX = App.state.baseWidth - cfg.marginRight;
              const availHeight = App.state.baseHeight - cfg.marginTop - cfg.marginBottom;
              if (availHeight <= 0 || endX - startX <= 0) return;

              let lineGap = Math.max(1, cfg.staffLineGap);
              let groupGap = Math.max(0, cfg.staffGroupGap);

              const lineCount = Math.max(1, cfg.staffLineCount);
              const spaceCount = Math.max(0, lineCount - 1);
              const staffHeight = lineGap * spaceCount;

              let totalHeight = cfg.staffCount * staffHeight + (cfg.staffCount - 1) * groupGap;

              if (totalHeight > availHeight) {
                const scale = availHeight / totalHeight;
                lineGap *= scale;
                groupGap *= scale;
              }

              const finalStaffHeight = lineGap * spaceCount;
              const startY = cfg.marginTop + (availHeight - (cfg.staffCount * finalStaffHeight + (cfg.staffCount - 1) * groupGap)) / 2;

              const lines = [];

              for (let s = 0; s < cfg.staffCount; s++) {
                const top = startY + s * (finalStaffHeight + groupGap);

                for (let i = 0; i < lineCount; i++) {
                  const y = top + i * lineGap;
                  lines.push(
                    new fabric.Line([startX, y, endX, y], {
                      stroke: cfg.gridColor,
                      strokeWidth: cfg.strokeWidth,
                      selectable: false,
                      evented: false,
                      isGrid: true,
                      excludeFromExport: true,
                      originX: "center",
                      originY: "center",
                    })
                  );
                }
              }
              lines.forEach((l) => {
                canvas.add(l);
                canvas.sendToBack(l);
              });
            },

            // --- 辅助：田字格/米字格/回字格/九宫格通用绘制 ---
            drawTianBase: function (cfg, canvas, options = {}) {
              const borderPad = cfg.doubleBorder ? 4 + cfg.strokeWidth : cfg.strokeWidth / 2;
              const startX = Math.max(cfg.marginLeft, borderPad);
              const startY = Math.max(cfg.marginTop, borderPad);
              const endX = App.state.baseWidth - Math.max(cfg.marginRight, borderPad);
              const endY = App.state.baseHeight - Math.max(cfg.marginBottom, borderPad);

              if (endX - startX <= 0 || endY - startY <= 0) return;

              let baseSize = Math.max(6, cfg.tianSize);
              let cols = Math.max(1, Math.round((endX - startX) / baseSize));
              let rows = Math.max(1, Math.round((endY - startY) / baseSize));
              let size = Math.min((endX - startX) / cols, (endY - startY) / rows);
              rows = Math.max(1, Math.round((endY - startY) / size));
              size = (endY - startY) / rows;
              cols = Math.max(1, Math.round((endX - startX) / size));
              size = Math.min(size, (endX - startX) / cols);
              const gridW = cols * size;
              const gridH = rows * size;

              const scale = cfg.tianInnerScale || 0.4;
              const calculatedWidth = cfg.strokeWidth * scale;
              const innerWidth = Math.max(0.3, Math.min(calculatedWidth, cfg.strokeWidth - 0.1));
              const innerDash = cfg.gridDashed ? [cfg.gridDashArray, cfg.gridDashArray] : null;

              const lines = [];
              // 绘制外框网格线
              for (let c = 1; c < cols; c++) {
                const x = startX + c * size;
                lines.push(
                  new fabric.Line([x, startY, x, startY + gridH], {
                    stroke: cfg.gridColor,
                    strokeWidth: cfg.strokeWidth,
                    selectable: false,
                    evented: false,
                    isGrid: true,
                    excludeFromExport: true,
                    originX: "center",
                    originY: "center",
                    strokeLineCap: "butt",
                  })
                );
              }
              for (let r = 1; r < rows; r++) {
                const y = startY + r * size;
                lines.push(
                  new fabric.Line([startX, y, startX + gridW, y], {
                    stroke: cfg.gridColor,
                    strokeWidth: cfg.strokeWidth,
                    selectable: false,
                    evented: false,
                    isGrid: true,
                    excludeFromExport: true,
                    originX: "center",
                    originY: "center",
                    strokeLineCap: "butt",
                  })
                );
              }

              const innerOpts = {
                selectable: false,
                evented: false,
                isGrid: true,
                excludeFromExport: true,
                originX: "center",
                originY: "center",
                strokeLineCap: "butt",
              };

              // 绘制内部结构
              for (let c = 0; c < cols; c++) {
                for (let r = 0; r < rows; r++) {
                  const x = startX + c * size;
                  const y = startY + r * size;
                  const cx = x + size / 2;
                  const cy = y + size / 2;

                  if (options.subGrid) {
                    const nCols = Math.max(1, cfg.jiuCols);
                    const nRows = Math.max(1, cfg.jiuRows);
                    if (nCols > 1) {
                      const stepX = size / nCols;
                      for (let i = 1; i < nCols; i++) {
                        const lx = x + stepX * i;
                        lines.push(
                          new fabric.Line([lx, y, lx, y + size], {
                            stroke: cfg.gridColor,
                            strokeWidth: innerWidth,
                            strokeDashArray: innerDash,
                            ...innerOpts,
                          })
                        );
                      }
                    }
                    if (nRows > 1) {
                      const stepY = size / nRows;
                      for (let j = 1; j < nRows; j++) {
                        const ly = y + stepY * j;
                        lines.push(
                          new fabric.Line([x, ly, x + size, ly], {
                            stroke: cfg.gridColor,
                            strokeWidth: innerWidth,
                            strokeDashArray: innerDash,
                            ...innerOpts,
                          })
                        );
                      }
                    }
                  }

                  if (options.cross !== false) {
                    lines.push(
                      new fabric.Line([x, cy, x + size, cy], {
                        stroke: cfg.gridColor,
                        strokeWidth: innerWidth,
                        strokeDashArray: innerDash,
                        ...innerOpts,
                      })
                    );
                    lines.push(
                      new fabric.Line([cx, y, cx, y + size], {
                        stroke: cfg.gridColor,
                        strokeWidth: innerWidth,
                        strokeDashArray: innerDash,
                        ...innerOpts,
                      })
                    );
                  }
                  if (options.diagonals) {
                    lines.push(
                      new fabric.Line([x, y, x + size, y + size], {
                        stroke: cfg.gridColor,
                        strokeWidth: innerWidth,
                        strokeDashArray: innerDash,
                        ...innerOpts,
                      })
                    );
                    lines.push(
                      new fabric.Line([x, y + size, x + size, y], {
                        stroke: cfg.gridColor,
                        strokeWidth: innerWidth,
                        strokeDashArray: innerDash,
                        ...innerOpts,
                      })
                    );
                  }
                  if (options.innerSquare) {
                    const safeW = Math.min(cfg.huiInnerW, size);
                    const safeH = Math.min(cfg.huiInnerH, size);
                    lines.push(
                      new fabric.Rect({
                        left: cx,
                        top: cy,
                        width: safeW,
                        height: safeH,
                        fill: "transparent",
                        stroke: cfg.gridColor,
                        strokeWidth: innerWidth,
                        strokeDashArray: innerDash,
                        ...innerOpts,
                      })
                    );
                  }
                }
              }

              this._drawBorder(canvas, startX, startY, gridW, gridH, cfg);
              lines.forEach((l) => {
                canvas.add(l);
                canvas.sendToBack(l);
              });
            },

            // 6. 点阵纸渲染器
            dots: function (cfg, canvas) {
              const startX = cfg.marginLeft;
              const startY = cfg.marginTop;
              const endX = App.state.baseWidth - cfg.marginRight;
              const endY = App.state.baseHeight - cfg.marginBottom;
              const w = endX - startX;
              const h = endY - startY;

              if (w <= 0 || h <= 0) return;

              const space = Math.max(2, cfg.dotSpace);
              const r = cfg.dotSize / 2;
              const epsilon = 0.01;

              const rowHeight = cfg.dotStagger ? (space * Math.sqrt(3)) / 2 : space;
              const cols = Math.ceil(w / space);
              const rows = Math.ceil(h / rowHeight);

              const contentW = cols * space;
              const contentH = rows * rowHeight;
              const offsetX = (w - contentW) / 2 + (cfg.dotStagger ? space / 4 : 0);
              const offsetY = (h - contentH) / 2;

              let pathData = "";

              for (let row = -1; row <= rows + 1; row++) {
                const isStagger = cfg.dotStagger && row % 2 !== 0;
                const staggerX = isStagger ? space / 2 : 0;

                for (let col = -1; col <= cols + 1; col++) {
                  const cx = startX + offsetX + col * space + staggerX;
                  const cy = startY + offsetY + row * rowHeight;

                  // 过滤超出边距的点
                  if (cx - r < startX - epsilon || cx + r > endX + epsilon || cy - r < startY - epsilon || cy + r > endY + epsilon) {
                    continue;
                  }

                  const cxF = cx.toFixed(2);
                  const cy1 = (cy - r).toFixed(2);
                  const cy2 = (cy + r).toFixed(2);
                  const rF = r.toFixed(2);
                  pathData += `M ${cxF} ${cy1} A ${rF} ${rF} 0 1 1 ${cxF} ${cy2} A ${rF} ${rF} 0 1 1 ${cxF} ${cy1} `;
                }
              }

              this._addPathToCanvas(canvas, pathData, cfg, {
                objectCaching: false,
                stroke: null,
                strokeWidth: 0,
                fill: cfg.gridColor,
              });
            },

            // 7. 三角形网格渲染器
            triangle: function (cfg, canvas) {
              const startX = cfg.marginLeft;
              const startY = cfg.marginTop;
              const endX = App.state.baseWidth - cfg.marginRight;
              const endY = App.state.baseHeight - cfg.marginBottom;
              const w = endX - startX;
              const h = endY - startY;

              if (w <= 0 || h <= 0) return;

              const side = Math.max(2, cfg.geoSize);
              const triHeight = (Math.sqrt(3) / 2) * side;
              const cols = Math.ceil(w / side) + 2;
              const rows = Math.ceil(h / triHeight) + 2;

              let pathData = "";

              const addClippedLine = (x1, y1, x2, y2) => {
                const line = Utils.clipLine(x1, y1, x2, y2, startX, startY, endX, endY);
                if (line) {
                  pathData += `M ${line.x1.toFixed(2)} ${line.y1.toFixed(2)} L ${line.x2.toFixed(2)} ${line.y2.toFixed(2)} `;
                }
              };

              for (let row = -1; row < rows; row++) {
                const yBase = startY + row * triHeight;
                const offsetX = row % 2 === 0 ? 0 : side / 2;
                for (let col = -1; col < cols; col++) {
                  const cx = startX + col * side + offsetX;
                  if (cx < startX - side && cx > endX + side && yBase < startY - triHeight && yBase > endY + triHeight) continue;

                  addClippedLine(cx, yBase, cx - side / 2, yBase + triHeight);
                  addClippedLine(cx - side / 2, yBase + triHeight, cx + side / 2, yBase + triHeight);
                  addClippedLine(cx + side / 2, yBase + triHeight, cx, yBase);
                }
              }

              const dash = cfg.gridDashed ? [cfg.gridDashArray, cfg.gridDashArray] : null;
              this._addPathToCanvas(canvas, pathData, cfg, {
                objectCaching: false,
                fill: "transparent",
                strokeLineCap: "square",
                strokeDashArray: dash,
              });
            },

            // 8. 六边形网格渲染器
            hexagon: function (cfg, canvas) {
              const startX = cfg.marginLeft;
              const startY = cfg.marginTop;
              const endX = App.state.baseWidth - cfg.marginRight;
              const endY = App.state.baseHeight - cfg.marginBottom;
              const w = endX - startX;
              const h = endY - startY;

              if (w <= 0 || h <= 0) return;

              const r = cfg.geoSize;
              const hexW = Math.sqrt(3) * r;
              const vertDist = 1.5 * r;
              const cols = Math.ceil(w / hexW) + 2;
              const rows = Math.ceil(h / vertDist) + 2;

              let pathData = "";

              const addClippedLine = (x1, y1, x2, y2) => {
                const line = Utils.clipLine(x1, y1, x2, y2, startX, startY, endX, endY);
                if (line) {
                  pathData += `M ${line.x1.toFixed(2)} ${line.y1.toFixed(2)} L ${line.x2.toFixed(2)} ${line.y2.toFixed(2)} `;
                }
              };

              for (let row = -1; row < rows; row++) {
                for (let col = -1; col < cols; col++) {
                  const xOffset = row % 2 !== 0 ? hexW / 2 : 0;
                  const cx = startX + col * hexW + xOffset;
                  const cy = startY + row * vertDist;

                  if (cx < startX - hexW || cx > endX + hexW || cy < startY - r || cy > endY + r) continue;

                  const pts = [];
                  for (let i = 0; i < 6; i++) {
                    const angle = (Math.PI / 180) * (30 + 60 * i);
                    pts.push({
                      x: cx + r * Math.cos(angle),
                      y: cy + r * Math.sin(angle),
                    });
                  }
                  for (let i = 0; i < 6; i++) {
                    addClippedLine(pts[i].x, pts[i].y, pts[(i + 1) % 6].x, pts[(i + 1) % 6].y);
                  }
                }
              }

              const dash = cfg.gridDashed ? [cfg.gridDashArray, cfg.gridDashArray] : null;
              this._addPathToCanvas(canvas, pathData, cfg, {
                objectCaching: false,
                fill: "transparent",
                strokeLineCap: "square",
                strokeDashArray: dash,
              });
            },

            label: function (cfg, canvas) {
              if (App.state.label.mode !== "design") return;
              // 只是简单画个边框表示标签边界
              const w = App.state.baseWidth;
              const h = App.state.baseHeight;
              canvas.add(
                new fabric.Rect({
                  left: 0,
                  top: 0,
                  width: w,
                  height: h,
                  fill: "transparent",
                  strokeWidth: 1,
                  selectable: false,
                  evented: false,
                  isGrid: true,
                })
              );
            },
            // --- 通用路径添加方法 ---
            _addPathToCanvas: function (canvas, pathData, cfg, styleOpts) {
              if (!pathData || pathData.length === 0) return;
              const opts = {
                fill: "transparent",
                stroke: cfg.gridColor,
                strokeWidth: cfg.strokeWidth,
                selectable: false,
                evented: false,
                isGrid: true,
                excludeFromExport: true,
                objectCaching: false,
                noScaleCache: true,
                strokeLineCap: "round",
                strokeLineJoin: "round",
                ...(styleOpts || {}),
              };
              const path = new fabric.Path(pathData, opts);
              canvas.add(path);
              canvas.sendToBack(path);
            },

            tianzige: function (cfg, canvas) {
              this.drawTianBase(cfg, canvas, {
                cross: true,
              });
            },
            mizige: function (cfg, canvas) {
              this.drawTianBase(cfg, canvas, {
                cross: true,
                diagonals: true,
              });
            },
            huizige: function (cfg, canvas) {
              this.drawTianBase(cfg, canvas, {
                cross: true,
                innerSquare: true,
                squareRatio: cfg.tianInnerScale || 0.5,
              });
            },
            jiugongge: function (cfg, canvas) {
              this.drawTianBase(cfg, canvas, {
                subGrid: true,
                cross: false,
                diagonals: false,
                innerSquare: false,
              });
            },

            // --- 边框绘制方法 ---
            _drawBorder: function (canvas, x, y, w, h, cfg) {
              if (cfg.doubleBorder) this._drawDoubleFrame(canvas, x, y, w, h, cfg);
              else this._drawSingleFrame(canvas, x, y, w, h, cfg);
            },

            _drawSingleFrame: function (canvas, x, y, w, h, cfg) {
              canvas.add(
                new fabric.Rect({
                  fill: "transparent",
                  stroke: cfg.gridColor,
                  selectable: false,
                  evented: false,
                  isGrid: true,
                  excludeFromExport: true,
                  originX: "left",
                  originY: "top",
                  objectCaching: false,
                  strokeLineCap: "square",
                  strokeLineJoin: "miter",
                  left: x,
                  top: y,
                  width: w,
                  height: h,
                  strokeWidth: cfg.strokeWidth,
                })
              );
            },

            _drawDoubleFrame: function (canvas, x, y, w, h, cfg) {
              const GAP = 3;
              const thickW = cfg.strokeWidth + 2;
              const thinW = Math.max(1, cfg.strokeWidth);
              const common = {
                fill: "transparent",
                stroke: cfg.gridColor,
                selectable: false,
                evented: false,
                isGrid: true,
                excludeFromExport: true,
                originX: "center",
                originY: "center",
                strokeLineJoin: "miter",
                strokeLineCap: "square",
                objectCaching: false,
              };
              const centerX = x + w / 2;
              const centerY = y + h / 2;

              canvas.add(
                new fabric.Rect({
                  ...common,
                  left: centerX,
                  top: centerY,
                  width: w,
                  height: h,
                  strokeWidth: thinW,
                })
              );
              const offset = GAP + thinW / 2 + thickW / 2;
              canvas.add(
                new fabric.Rect({
                  ...common,
                  left: centerX,
                  top: centerY,
                  width: w + offset * 2,
                  height: h + offset * 2,
                  strokeWidth: thickW,
                })
              );
            },
          },

          // 纸张初始化
          init: function () {
            const select = document.getElementById("paperType");
            if (select) {
              select.innerHTML = "";
              Object.keys(this.defaults).forEach((key) => {
                const opt = document.createElement("option");
                opt.value = key;
                opt.innerText = this.defaults[key].label;
                select.appendChild(opt);
              });
            }

            const initialType = select.value || "blank";
            this.changeType(initialType, true);
            this.updateSize();
          },

          changeType: function (type, applyDefaults = false) {
            App.state.paperType = type;
            document.querySelectorAll("[data-paper-types]").forEach((el) => {
              const types = (el.dataset.paperTypes || "").split(",").map((t) => t.trim());
              el.classList.toggle("hidden", !types.includes(type));
            });
            if (type === "label") {
              document.getElementById("labelModeToggle").classList.remove("hidden");
              App.state.label.mode = "design";
              App.state.label.designContent = null;
              App.label.updateToggleButtonUI();
            } else {
              document.getElementById("labelModeToggle").classList.add("hidden");
              if (App.state.label.mode === "preview") App.label.enterDesign();
              const fitLabel = document.getElementById("fitLabelSize");
              if (fitLabel) fitLabel.checked = false;
            }

            if (applyDefaults && this.defaults[type]) {
              const specificConfig = this.defaults[type];
              const baseDefaults = {
                marginTop: 25,
                marginBottom: 25,
                marginLeft: 20,
                marginRight: 20,
                paperBgColor: "#ffffff",
                gridColor: "#e11d48",
                strokeWidth: 1,
                doubleFirst: false,
                doubleLast: false,
                ruledClosed: false,
                gridDashed: false,
              };
              const finalConfig = { ...baseDefaults, ...specificConfig };
              Object.keys(finalConfig).forEach((key) => {
                if (key === "label") return;
                const el = document.getElementById(key);
                if (el) el.type === "checkbox" ? (el.checked = !!finalConfig[key]) : (el.value = finalConfig[key]);
              });
            }

            this.updateSettings();
            this.updateSize();
          },

          updateSettings: function () {
            const rc = document.getElementById("rowCount");
            if (rc) document.getElementById("rowCountDisplay").value = rc.value;
            const cc = document.getElementById("columnCount");
            if (cc) document.getElementById("columnCountDisplay").value = cc.value;
            const gc = document.getElementById("gridColumns");
            if (gc) document.getElementById("gridColDisplay").value = gc.value;
            App.state.hasUnsavedChanges = true;
            if (App.state.paperType !== "label") {
              this.drawPaper();
            } else if (App.state.label.mode === "design") {
              App.paper.updateSize();
            } else {
              App.label.renderPreview();
            }
          },

          getSettings: function () {
            const el = (id) => document.getElementById(id);
            const val = (id, def) => (el(id) ? el(id).value : def);
            const mmVal = (id, def) => {
              if (!el(id)) return def;
              const n = parseFloat(el(id).value);
              return isNaN(n) ? def : n;
            };
            const intVal = (id, def) => {
              const n = parseInt(val(id, def), 10);
              return isNaN(n) ? def : n;
            };
            const floatVal = (id, def) => {
              const n = parseFloat(val(id, def));
              return isNaN(n) ? def : n;
            };
            const chk = (id) => (el(id) ? el(id).checked : false);

            const cfg = {
              customW: intVal("customW", 210),
              customH: intVal("customH", 297),
              type: val("paperType", "ruled"),
              marginTop: mmVal("marginTop", 25) * CONFIG.MM_TO_PX,
              marginBottom: mmVal("marginBottom", 25) * CONFIG.MM_TO_PX,
              marginLeft: mmVal("marginLeft", 20) * CONFIG.MM_TO_PX,
              marginRight: mmVal("marginRight", 20) * CONFIG.MM_TO_PX,
              rowCount: intVal("rowCount", 20),
              gridColor: val("gridColor", "#e11d48"),
              strokeWidth: floatVal("strokeWidth", 1),
              doubleFirst: chk("doubleFirst"),
              paperOrientation: chk("paperOrientation"),
              dual: chk("paperDual"),
              doubleLast: chk("doubleLast"),
              gridDashed: chk("gridDashed"),
              gridDashArray: intVal("gridDashArray", 4),
              paperBgColor: val("paperBgColor", "#ffffff"),
              englishOffset: mmVal("englishOffset", 0) * CONFIG.MM_TO_PX,
              englishLineGap: mmVal("englishLineGap", 6) * CONFIG.MM_TO_PX,
              englishGroupGap: mmVal("englishGroupGap", 6) * CONFIG.MM_TO_PX,
              columnCount: intVal("columnCount", 12),
              gridColumns: intVal("gridColumns", 24),
              staffCount: intVal("staffCount", 8),
              staffLineGap: mmVal("staffLineGap", 3) * CONFIG.MM_TO_PX,
              staffGroupGap: mmVal("staffGroupGap", 12) * CONFIG.MM_TO_PX,
              staffLineCount: intVal("staffLineCount", 5),
              tianSize: mmVal("tianSize", 20) * CONFIG.MM_TO_PX,
              geoSize: mmVal("geoSize", 10) * CONFIG.MM_TO_PX,
              tianInnerScale: floatVal("tianInnerScale", 0.5),
              ruledClosed: chk("ruledClosed"),
              dotStagger: chk("dotStagger"),
              ruledClosedDouble: chk("ruledClosedDouble"),
              doubleBorder: chk("doubleBorder"),
              huiInnerW: mmVal("huiInnerW", 10) * CONFIG.MM_TO_PX,
              huiInnerH: mmVal("huiInnerH", 10) * CONFIG.MM_TO_PX,
              dotSpace: mmVal("dotSpace", 5) * CONFIG.MM_TO_PX,
              dotSize: mmVal("dotSize", 1) * CONFIG.MM_TO_PX,
              jiuCols: intVal("jiuCols", 3),
              jiuRows: intVal("jiuRows", 3),
              labelWidth: floatVal("labelWidth", 50),
              labelHeight: floatVal("labelHeight", 30),
              labelCols: intVal("labelCols", 3),
              labelRows: intVal("labelRows", 7),
              labelGapH: floatVal("labelGapH", 2.5),
              labelGapV: floatVal("labelGapV", 2.5),
              labelQuantity: intVal("labelQuantity", 1),
              showCropMarks: chk("showCropMarks"),
            };

            if (chk("fitLabelSize")) {
              cfg.labelCols = cfg.labelRows = 1;
              cfg.showCropMarks = false;
              cfg.marginTop = cfg.marginBottom = cfg.marginLeft = cfg.marginRight = cfg.labelGapH = cfg.labelGapV = 0;
            }

            return cfg;
          },

          updateSize: function () {
            const el = (id) => document.getElementById(id);
            const type = el("paperType").value;
            const sizeKey = el("paperSize").value;
            const fitLabel = el("fitLabelSize") && el("fitLabelSize").checked;
            const isDesign = type === "label" && App.state.label.mode === "design";
            App.state.paperType = type;
            if (el("paperOptions")) {
              ["paperOptions", "showMarks", "labelLayout"].forEach((k) => {
                const element = el(k);
                if (element) element.style.display = type === "label" && fitLabel ? "none" : "";
              });
            }

            let w, h;
            const isLand = el("paperOrientation").checked;
            if (isDesign) {
              const cfg = this.getSettings();
              [w, h] = [cfg.labelWidth, cfg.labelHeight];
            } else {
              if (type === "label" && fitLabel) {
                w = parseFloat(el("labelWidth").value) || 50;
                h = parseFloat(el("labelHeight").value) || 30;
              } else {
                let pw, ph;
                if (sizeKey === "CUSTOM") {
                  pw = parseFloat(el("customW").value) || 210;
                  ph = parseFloat(el("customH").value) || 297;
                } else {
                  const sizeDef = CONFIG.SIZES[sizeKey] || CONFIG.SIZES["A4"];
                  pw = sizeDef.w;
                  ph = sizeDef.h;
                }

                [w, h] = isLand ? [Math.max(pw, ph), Math.min(pw, ph)] : [Math.min(pw, ph), Math.max(pw, ph)];
              }
            }

            const dualWrapper = el("dualOptionWrapper");
            if (dualWrapper) {
              if (type !== "label" && isLand) {
                dualWrapper.classList.remove("hidden");
              } else {
                dualWrapper.classList.add("hidden");
                if (el("paperDual").checked) el("paperDual").checked = false;
              }
            }

            const labelText = `${isDesign ? "标签设计" : fitLabel && type === "label" ? "单张标签" : sizeKey} (${w} x ${h} mm)`;
            if (el("canvasSizeLabel")) el("canvasSizeLabel").innerText = labelText;
            App.state.currentPaper = { w, h };
            App.state.baseWidth = w * CONFIG.MM_TO_PX;
            App.state.baseHeight = h * CONFIG.MM_TO_PX;
            App.zoom.autoFit();
            if (type === "label" && App.state.label.mode === "preview") {
              App.label.renderPreview();
            } else {
              this.drawPaper();
            }
            App.ruler.draw();
          },

          drawPaper: function () {
            const cfg = this.getSettings();
            const canvas = App.canvas;

            canvas.remove(...canvas.getObjects().filter((o) => o.isGrid));
            canvas.setBackgroundColor(cfg.paperBgColor, canvas.requestRenderAll.bind(canvas));

            const renderer = this.renderers[cfg.type] || this.renderers.ruled;

            try {
              if (cfg.dual && App.state.baseWidth > App.state.baseHeight) {
                const originalBaseWidth = App.state.baseWidth;
                const halfWidth = originalBaseWidth / 2;
                const originalAdd = canvas.add.bind(canvas);

                App.state.baseWidth = halfWidth;
                renderer.call(this.renderers, cfg, canvas);

                canvas.add = function (...objects) {
                  objects.forEach((obj) => {
                    if (obj) {
                      obj.left += halfWidth;
                      if (obj.type === "line") {
                        obj.setCoords();
                      }
                    }
                  });
                  originalAdd(...objects);
                };

                renderer.call(this.renderers, cfg, canvas);

                canvas.add = originalAdd;
                App.state.baseWidth = originalBaseWidth;

                const midLine = new fabric.Line([halfWidth, 0, halfWidth, App.state.baseHeight], {
                  stroke: "#ccc",
                  strokeWidth: 1,
                  strokeDashArray: [10, 10],
                  selectable: false,
                  evented: false,
                  isGrid: true,
                  isCutLine: true,
                  originX: "center",
                  originY: "center",
                });
                canvas.add(midLine);
                canvas.sendToBack(midLine);
              } else {
                renderer.call(this.renderers, cfg, canvas);
              }
            } catch (e) {
              console.warn("Render Error:", e);
            }
            canvas.requestRenderAll();
          },

          drawGrid: function () {
            if (App.state.paperType === "label" && App.state.label.mode === "preview") {
              App.label.renderPreview();
            } else {
              this.drawPaper();
            }
          },

          clearBackground: function () {
            if (!App.canvas.backgroundImage) return;
            App.canvas.setBackgroundImage(null, () => {
              App.canvas.renderAll();
              App.state.editingBackground = false;
              App.canvas.discardActiveObject();

              App.ui.updateInspector();
              App.ui.updateLayerList();
              App.history.saveState();

              Utils.toast("背景图片已移除");
            });
          },
          autoLayoutLabels: function () {
            const type = document.getElementById("paperType").value;
            if (type !== "label") return;

            const el = (id) => document.getElementById(id);
            const val = (id) => parseFloat(el(id).value) || 0;

            const sizeKey = el("paperSize").value;
            let sheetW, sheetH;

            if (sizeKey === "CUSTOM") {
              sheetW = val("customW");
              sheetH = val("customH");
            } else {
              const s = CONFIG.SIZES[sizeKey];
              sheetW = s.w;
              sheetH = s.h;
            }
            const isLand = el("paperOrientation").checked;
            const finalSheetW = isLand ? Math.max(sheetW, sheetH) : Math.min(sheetW, sheetH);
            const finalSheetH = isLand ? Math.min(sheetW, sheetH) : Math.max(sheetW, sheetH);

            const marginTop = val("marginTop");
            const marginBottom = val("marginBottom");
            const marginLeft = val("marginLeft");
            const marginRight = val("marginRight");

            const labelW = val("labelWidth");
            const labelH = val("labelHeight");
            const gapH = val("labelGapH");
            const gapV = val("labelGapV");

            if (labelW <= 0 || labelH <= 0) return;

            const availW = finalSheetW - marginLeft - marginRight;
            const availH = finalSheetH - marginTop - marginBottom;

            const cols = Math.floor((availW + gapH) / (labelW + gapH));
            const rows = Math.floor((availH + gapV) / (labelH + gapV));

            el("labelCols").value = Math.max(1, cols);
            el("labelRows").value = Math.max(1, rows);

            App.paper.updateSettings();
          },
          calcLabelSizeFromGrid: function () {
            const el = (id) => document.getElementById(id);
            const val = (id) => parseFloat(el(id).value) || 0;

            const sizeKey = el("paperSize").value;
            let sheetW, sheetH;

            if (sizeKey === "CUSTOM") {
              sheetW = val("customW");
              sheetH = val("customH");
            } else {
              const s = CONFIG.SIZES[sizeKey];
              sheetW = s.w;
              sheetH = s.h;
            }
            const isLand = el("paperOrientation").checked;
            const finalSheetW = isLand ? Math.max(sheetW, sheetH) : Math.min(sheetW, sheetH);
            const finalSheetH = isLand ? Math.min(sheetW, sheetH) : Math.max(sheetW, sheetH);

            const marginTop = val("marginTop");
            const marginBottom = val("marginBottom");
            const marginLeft = val("marginLeft");
            const marginRight = val("marginRight");
            const gapH = val("labelGapH");
            const gapV = val("labelGapV");

            const cols = parseInt(el("labelCols").value) || 1;
            const rows = parseInt(el("labelRows").value) || 1;

            if (cols < 1 || rows < 1) return Utils.toast("行列数必须大于0", "error");
            const availW = finalSheetW - marginLeft - marginRight;
            const availH = finalSheetH - marginTop - marginBottom;

            const totalGapW = (cols - 1) * gapH;
            const totalGapH = (rows - 1) * gapV;

            let newW = (availW - totalGapW) / cols;
            let newH = (availH - totalGapH) / rows;

            newW = Math.floor(newW * 10) / 10;
            newH = Math.floor(newH * 10) / 10;

            if (newW <= 0 || newH <= 0) {
              return Utils.toast("计算结果无效，请检查边距或间距设置", "error");
            }

            el("labelWidth").value = newW;
            el("labelHeight").value = newH;

            this.updateSettings();
          },
        },

        // --- 缩放管理 ---
        zoom: {
          change: function (delta, point) {
            const oldScale = App.state.zoom;
            const newScale = Math.max(0.1, Math.min(5, oldScale + delta));
            if (newScale === oldScale) return;

            this.apply(newScale);

            if (point) {
              const ct = document.getElementById("scrollContainer");
              const factor = newScale / oldScale;
              ct.scrollLeft = (ct.scrollLeft + point.x) * factor - point.x;
              ct.scrollTop = (ct.scrollTop + point.y) * factor - point.y;
            }
          },

          autoFit: function () {
            const ct = document.getElementById("scrollContainer");
            const isLabelDesign = App.state.paperType === "label" && App.state.label.mode === "design";
            const maxScale = isLabelDesign ? 5.0 : 1.2;
            const scale = Math.min(maxScale, (ct.clientWidth - 60) / App.state.baseWidth, (ct.clientHeight - 60) / App.state.baseHeight);
            this.apply(scale);
            setTimeout(() => {
              const mt = parseFloat(document.getElementById("zoomViewport").style.marginTop) || 40;
              const h = App.state.baseHeight * scale;
              const w = App.state.baseWidth * scale;
              ct.scrollTop = (h + mt + 20 - ct.clientHeight) / 2;
              ct.scrollLeft = (w - ct.clientWidth) / 2 + 30;
            }, 0);
          },

          apply: function (scale) {
            App.state.zoom = scale;
            const w = Math.round(App.state.baseWidth * scale);
            const h = Math.round(App.state.baseHeight * scale);

            App.canvas
              .setDimensions({
                width: w,
                height: h,
              })
              .setZoom(scale);

            const vp = document.getElementById("zoomViewport");
            const ct = document.getElementById("scrollContainer");
            if (vp && ct) {
              vp.style.width = w + "px";
              vp.style.height = h + "px";

              const mt = Math.max(40, (ct.clientHeight - h) / 2);
              vp.style.marginTop = mt + "px";
            }

            document.getElementById("zoomPercent").innerText = Math.round(scale * 100) + "%";
            App.canvas.requestRenderAll();
            App.ruler.draw();
          },
        },

        // --- 事件处理模块 ---
        events: {
          initEvents: function () {
            const container = document.getElementById("scrollContainer");
            const canvasWrap = document.getElementById("canvasWrapper");

            let startX = 0,
              startY = 0,
              scrollLeft = 0,
              scrollTop = 0;
            let dragOrigin = null,
              isDragThresholdPassed = false;

            const updateSelectionQueue = (e) => {
              if (App.state.isReplacingObject) return;
              const { selected, deselected } = e;
              if (selected) {
                selected.forEach((o) => {
                  if (!App.state.selectionQueue.includes(o)) {
                    App.state.selectionQueue.push(o);
                  }

                  const isLocked = o.lockMovementX;
                  const isDynamic = o.isDynamicDate || o.isDynamicPageNum || o.isSerialNumber || (o.dataBinding && o.dataBinding.type === "variable");
                  o.set("editable", !isLocked && !isDynamic);
                });
              }
              if (deselected)
                deselected.forEach((o) => {
                  const idx = App.state.selectionQueue.indexOf(o);
                  if (idx > -1) App.state.selectionQueue.splice(idx, 1);
                });
              App.ui.updateInspector();
            };

            const handleLiveTransform = (e) => {
              const t = e.target;

              if (e.transform?.action === "scale" && t.isTable) t.__tableScaling = true;

              if (["i-text", "textbox", "text"].includes(t.type) && e.transform?.action === "scale") {
                if (Math.abs(t.scaleX - t.scaleY) < 0.01 && Math.abs(t.scaleX - 1) > 0.001) {
                  const newSize = t.fontSize * t.scaleX;
                  t.set({
                    fontSize: newSize,
                    scaleX: 1,
                    scaleY: 1,
                  });
                  if (t.type === "textbox") t.width *= t.scaleX;

                  const propSize = document.getElementById("propSize");
                  if (propSize) propSize.value = Utils.px2pt(newSize);
                }
              }

              if (!this._uiUpdateRaf) {
                this._uiUpdateRaf = requestAnimationFrame(() => {
                  App.ui.updateGeo(null, null, t);
                  this._uiUpdateRaf = null;
                });
              }

              if (dragOrigin && !isDragThresholdPassed && e.transform?.action === "drag") {
                if (Math.abs(t.left - dragOrigin.left) > 3 || Math.abs(t.top - dragOrigin.top) > 3) isDragThresholdPassed = true;
                else
                  t.set({
                    left: dragOrigin.left,
                    top: dragOrigin.top,
                  });
              }
            };

            const handleObjectModified = (e) => {
              const t = e.target;
              if (!t) return;
              if (t.isTable && t.__tableScaling) {
                t.__tableScaling = false;
                App.tableEditor.normalizeScaledTable(t);
              }
              if (t.isBarcode && t.barcodeConfig) {
                if (Math.abs(t.scaleX - 1) > 0.01 || Math.abs(t.scaleY - 1) > 0.01) {
                  App.barcode.handleResize(t);
                  return;
                }
              }
              if (t.type === "textbox") {
                const finalW = Math.round(t.width * t.scaleX);
                const finalH = Math.round(t.height * t.scaleY);
                const finalFontSize = t.fontSize * t.scaleY;

                t.set({
                  width: Math.max(finalW, 50),
                  fontSize: finalFontSize,
                  scaleX: 1,
                  scaleY: 1,
                });

                if (finalH > t.height) t.set("height", finalH);
                t.__manualHeight = finalH;
                t.setCoords();
              }
              App.ui.updateInspector();
              App.canvas.requestRenderAll();
            };

            // ============================================================
            // 2. Fabric Canvas 事件绑定
            // ============================================================
            App.canvas.on({
              "mouse:down": (opt) => {
                const target = opt.target;
                const isAlt = opt.e.altKey;

                // 记录拖拽起始点
                if (target && !isAlt && !target.isGrid) {
                  dragOrigin = {
                    left: target.left,
                    top: target.top,
                  };
                  isDragThresholdPassed = false;
                } else {
                  dragOrigin = null;
                }

                // 处理画布平移 vs 框选
                if (!target || target.isGrid) {
                  if (isAlt) {
                    // Alt+拖动 = 框选模式
                    App.state.isPanning = false;
                    App.canvas.selection = true;
                    App.canvas.defaultCursor = "default";
                  } else {
                    // 默认拖动 = 平移画布
                    App.state.isPanning = true;
                    App.canvas.selection = false;
                    startX = opt.e.clientX;
                    startY = opt.e.clientY;
                    scrollLeft = container.scrollLeft;
                    scrollTop = container.scrollTop;
                    App.canvas.setCursor("grabbing");
                  }
                }
              },
              "mouse:up": () => {
                dragOrigin = null;
                isDragThresholdPassed = false;
                if (App.state.isPanning) {
                  App.state.isPanning = false;
                  App.canvas.selection = true;
                  App.canvas.defaultCursor = "default";
                  App.canvas.setCursor("default");
                }
              },
              "mouse:dblclick": (opt) => {
                if (opt.target && opt.target.isTable) App.tableEditor.open(opt.target);
              },
              "selection:created": updateSelectionQueue,
              "selection:updated": updateSelectionQueue,
              "selection:cleared": () => {
                if (App.state.isReplacingObject) return;
                App.state.selectionQueue = [];
                App.ui.updateInspector();
              },

              "text:editing:entered": (e) => {
                const t = e.target;
                if (t.syncMode === "ref" && t.refId) {
                  const parent = App.content.findObjectBySharedId(t.refId);
                  if (parent && parent.rawContent !== undefined) {
                    t.text = String(parent.rawContent);
                  } else {
                    t.text = t.rawContent !== undefined ? String(t.rawContent) : t.text;
                  }
                } else if (t.rawContent !== undefined) {
                  t.text = String(t.rawContent);
                }

                if (t.hiddenTextarea) t.hiddenTextarea.value = t.text;
                App.canvas.requestRenderAll();
              },

              "text:editing:exited": (e) => {
                const t = e.target;
                t.rawContent = t.text;
                App.content.setRawContent(t, t.text);
                App.ui.updateInspector();
                App.history.saveState();
              },

              "object:moving": handleLiveTransform,
              "object:scaling": handleLiveTransform,
              "object:rotating": handleLiveTransform,
              "object:resizing": handleLiveTransform,
              "object:modified": handleObjectModified,
            });

            // ============================================================
            // 3. 容器 DOM 事件 (平移、缩放、点击空白)
            // ============================================================

            // 画布平移
            document.addEventListener(
              "mousemove",
              (e) => {
                if (App.state.isPanning) {
                  e.preventDefault();
                  container.scrollLeft = scrollLeft - (e.clientX - startX);
                  container.scrollTop = scrollTop - (e.clientY - startY);
                }
              },
              {
                passive: false,
              }
            );

            // 滚轮缩放
            container.addEventListener(
              "wheel",
              (e) => {
                if (e.ctrlKey || e.metaKey || !App.state.isPanning) {
                  e.preventDefault();
                  e.stopPropagation();
                  const rect = container.getBoundingClientRect();
                  App.zoom.change(e.deltaY > 0 ? -0.1 : 0.1, {
                    x: e.clientX - rect.left,
                    y: e.clientY - rect.top,
                  });
                }
              },
              {
                passive: false,
              }
            );

            // 点击空白处取消选中
            container.addEventListener("mousedown", (e) => {
              if (["scrollContainer", "zoomViewport", "canvasWrapper"].includes(e.target.id) && App.canvas.getActiveObject()) {
                App.canvas.discardActiveObject();
                App.canvas.requestRenderAll();
                App.ui.updateInspector();
              }
            });

            // 标尺与自适应
            container.addEventListener(
              "scroll",
              Utils.throttle(() => App.ruler.draw(), 10)
            );
            window.addEventListener(
              "resize",
              Utils.throttle(() => App.zoom.autoFit(), 200)
            );

            // ============================================================
            // 4. 拖拽数据源 (Drag & Drop)
            // ============================================================
            const fieldListContainer = document.getElementById("dsFieldList");
            if (fieldListContainer) {
              fieldListContainer.addEventListener("dragstart", (e) => {
                // 防止拖拽到图标
                const target = e.target.closest("li");
                if (target && target.dataset.field) {
                  const data = {
                    sheet: target.dataset.sheet,
                    field: target.dataset.field,
                  };
                  e.dataTransfer.setData("application/paper-field", JSON.stringify(data));
                  e.dataTransfer.effectAllowed = "copy";
                }
              });
            }

            canvasWrap.addEventListener("dragover", (e) => {
              e.preventDefault();
              e.dataTransfer.dropEffect = "copy";
            });

            canvasWrap.addEventListener("drop", (e) => {
              e.preventDefault();
              const rawData = e.dataTransfer.getData("application/paper-field");
              if (!rawData) return;

              try {
                const { sheet, field } = JSON.parse(rawData);

                // 计算落点坐标
                const rect = App.canvas.getElement().getBoundingClientRect();
                const zoom = App.canvas.getZoom();
                const x = (e.clientX - rect.left) / zoom;
                const y = (e.clientY - rect.top) / zoom;

                // 获取预览数据
                let initialText = field;
                const ds = App.state.dataSource;
                if (ds.isActive && ds.data.length > 0) {
                  const row = ds.data[App.state.currentDataIndex || 0];
                  const val = row[field];
                  if (val !== undefined && val !== null) initialText = String(val);
                }

                // 创建文本对象 (使用 SimHei)
                const textObj = new fabric.IText(initialText, {
                  left: x,
                  top: y,
                  fontSize: Utils.pt2px(20),
                  fontFamily: "SimHei",
                  fill: "#666666",
                  originX: "left",
                  originY: "top",
                });

                textObj.dataBinding = {
                  type: "variable",
                  sheet,
                  field,
                };

                App.tools._addToCanvas(textObj);
                App.dataSource.refreshBindingState();
              } catch (err) {
                console.error("Drop error", err);
              }
            });

            // ============================================================
            // 5. 全局 UI 事件 (原底部脚本内容)
            // ============================================================

            // 文件上传输入框绑定
            const bindInput = (id, handler) => {
              const el = document.getElementById(id);
              if (el) {
                // 使用 function 保留 this 上下文指向 input 元素
                el.onchange = function () {
                  handler.call(this);
                };
              }
            };

            bindInput("imgUpload", function () {
              App.tools.handleImageUpload(this);
            });
            bindInput("projectImportInput", function () {
              App.io.loadProject(this.files[0]);
            });
            bindInput("imgReplaceInput", function () {
              App.tools.replaceActiveImage(this);
            });

            // 模态框点击背景关闭
            const bindModalClose = (id) => {
              const el = document.getElementById(id);
              if (el) {
                el.onclick = (e) => {
                  if (e.target.id === id) App.ui.hideModal(id);
                };
              }
            };
            bindModalClose("welcomeModal");
            bindModalClose("contactModal");
            bindModalClose("sponsorModal");

            // 全屏状态图标切换
            document.addEventListener("fullscreenchange", () => {
              const icon = document.getElementById("fsIcon");
              if (icon) {
                icon.className = `ph ph-corners-${document.fullscreenElement ? "in" : "out"} text-lg`;
              }
              setTimeout(() => {
                App.zoom.autoFit();
                App.ruler.init();
              }, 100);
            });

            window.addEventListener("beforeunload", (e) => {
              if (App.state.hasUnsavedChanges) {
                e.preventDefault();
                e.returnValue = "未保存更改";
                return "未保存更改";
              }
            });
          },

          // --- 初始化绑定 ---
          initHotkeys: function () {
            const isInput = () => ["INPUT", "TEXTAREA"].includes(document.activeElement?.tagName) || document.activeElement?.contentEditable === "true";
            hotkeys("ctrl+z,command+z", (e) => {
              if (!isInput()) {
                e.preventDefault();
                App.history.undo();
              }
            });

            hotkeys("ctrl+l,command+l", (e) => {
              e.preventDefault();
              App.tools.toggleLock();
            });

            hotkeys("ctrl+y,command+y", (e) => {
              if (!isInput()) {
                e.preventDefault();
                App.history.redo();
              }
            });
            hotkeys("ctrl+s,command+s", (e) => {
              e.preventDefault();
              App.io.saveProject();
            });
            hotkeys("ctrl+o,command+o", (e) => {
              e.preventDefault();
              document.getElementById("projectImportInput").click();
            });
            hotkeys("ctrl+p,command+p", (e) => {
              e.preventDefault();
              App.io.print();
            });
            hotkeys("del,backspace", (e) => {
              if (!isInput()) {
                e.preventDefault();
                App.tools.deleteActive();
              }
            });
            hotkeys("ctrl+c,command+c", (e) => {
              if (window.getSelection().toString().length > 0) {
                return;
              }

              if (!isInput() && App.canvas.getActiveObject()) {
                e.preventDefault();
                App.io.copy();
              }
            });
            hotkeys("ctrl+v,command+v", (e) => {
              if (!isInput() && App.state.clipboard) {
                e.preventDefault();
                App.io.paste();
              }
            });
            hotkeys("up,down,left,right", (e, h) => {
              if (!isInput() && App.canvas.getActiveObject()) {
                e.preventDefault();
                App.tools.nudge(h.key);
              }
            });
            hotkeys("ctrl+g,command+g", (e) => {
              e.preventDefault();
              App.tools.group();
            });
            hotkeys("ctrl+shift+g,command+shift+g", (e) => {
              e.preventDefault();
              App.tools.ungroup();
            });
          },
        },

        // --- 本地字体加载 ---
        loadLocalFonts: async function () {
          if (App.state.localFontsLoaded || !window.queryLocalFonts) return;
          try {
            App.state.localFontsLoaded = true;
            const fonts = await window.queryLocalFonts();
            App.state.availabelFonts = fonts; // 保存供转曲使用

            const sortedFonts = fonts.sort((a, b) => a.family.localeCompare(b.family));
            const targetIds = ["propFont", "floatFontFamily"];

            targetIds.forEach((id) => {
              const select = document.getElementById(id);
              if (!select) return;
              const seen = new Set([...select.options].map((o) => o.value));
              if (!seen.has("---sep---")) select.add(new Option("--- 本地字体 ---", "---sep---", true, true));

              for (const f of sortedFonts) {
                if (!seen.has(f.family)) {
                  seen.add(f.family);
                  const opt = new Option(f.fullName, f.family);
                  opt.style.fontFamily = f.family;
                  select.add(opt);
                }
              }
            });
          } catch (e) {
            console.warn("Font Access Error", e);
            App.state.localFontsLoaded = false;
          }
        },

        // --- 画布工具集 ---
        tools: {
          _getCenter: () => ({
            left: App.state.baseWidth / 2,
            top: App.state.baseHeight / 2,
          }),

          _addToCanvas: function (obj) {
            App.canvas.add(obj);
            App.canvas.setActiveObject(obj);
            App.canvas.requestRenderAll();
            App.ui.updateLayerList();
            App.history.saveState();
          },

          addText: function () {
            this._addToCanvas(
              new fabric.IText("双击编辑文本", {
                ...this._getCenter(),
                fontSize: Utils.pt2px(20),
                fontFamily: "SimSun",
                fill: App.paper.getSettings().gridColor,
                originY: "center",
                originX: "left",
                textAlign: "left",
                prefix: "",
                suffix: "",
              })
            );
          },

          addParagraph: function () {
            const textbox = new fabric.Textbox("在此输入段落文本...\n支持自动换行。", {
              left: 100,
              top: 100,
              width: App.state.baseWidth - Utils.mm2px(50),
              fontSize: Utils.pt2px(20),
              fontFamily: "FangSong",
              fill: "#333",
              splitByGrapheme: true,
              lockScalingFlip: true,
              minWidth: 50,
            });

            const ctrl = textbox.controls;
            ctrl.ml.actionHandler = ctrl.mr.actionHandler = fabric.controlsUtils.scalingX;
            ctrl.mt.actionHandler = ctrl.mb.actionHandler = fabric.controlsUtils.scalingY;
            textbox.__manualHeight = textbox.height;

            textbox.on("editing:exited", function () {
              if (this.__manualHeight && this.height < this.__manualHeight) {
                this.set("height", this.__manualHeight);
                this.setCoords();
                App.canvas.requestRenderAll();
              }
            });
            textbox.on("changed", function () {
              if (this.height > this.__manualHeight) this.__manualHeight = this.height;
            });
            this._addToCanvas(textbox);
          },

          addDate: function () {
            const cfg = App.paper.getSettings();
            const isDyn = App.state.dataSource.isActive || App.state.paperType === "label";
            const opts = isDyn
              ? {
                  text: "时间预览",
                  left: App.state.baseWidth / 2,
                  top: App.state.baseHeight - Utils.mm2px(20),
                  originX: "center",
                  font: "Arial",
                  fill: "#000000",
                  size: 12,
                  editable: false,
                }
              : {
                  text: "____年__月__日",

                  left: App.state.baseWidth - cfg.marginRight,
                  top: Math.max(Utils.mm2px(5), cfg.marginTop - 35),
                  originX: "right",
                  font: "KaiTi",
                  fill: cfg.gridColor || "#000000",
                  size: 14,
                  editable: true,
                };

            const obj = new fabric.IText(opts.text, {
              left: opts.left,
              top: opts.top,
              originX: opts.originX,
              originY: "center",
              fontSize: Utils.pt2px(opts.size),
              fontFamily: opts.font,
              fill: opts.fill,
              editable: opts.editable,
            });

            if (isDyn) {
              obj.isDynamicDate = true;
              obj.dateConfig = {
                showDate: true,
                showTime: true,
                dateFormat: "YYYY-MM-DD",
                timeFormat: "HH:mm:ss",
                offsetDays: 0,
                offsetMinutes: 0,
              };
              obj.set("text", Utils.formatDate(new Date(), null, obj.dateConfig));
            }

            this._addToCanvas(obj);
            App.ui.updateInspector();
          },

          addPageNum: function () {
            const hasDataSource = App.state.dataSource.isActive || App.state.paperType === "label";
            const cfg = App.paper.getSettings();

            const pageObj = new fabric.IText(hasDataSource ? "第 1 页" : "第   页", {
              left: App.state.baseWidth / 2,
              top: App.state.baseHeight - Utils.mm2px(20),
              fontSize: Utils.pt2px(20),
              fontFamily: "SimSun",
              fill: cfg.gridColor,
              originX: "center",
              originY: "center",
              editable: false,
            });

            if (hasDataSource) {
              pageObj.isDynamicPageNum = true;
              pageObj.pageConfig = {
                format: "第 {page} 页",
                startFrom: 1,
              };
            }

            this._addToCanvas(pageObj);
            App.ui.updateInspector();
          },

          addLine: function () {
            const cfg = App.paper.getSettings();
            const contentWidth = App.state.baseWidth - cfg.marginLeft - cfg.marginRight;

            this._addToCanvas(
              new fabric.Line([0, 0, contentWidth, 0], {
                left: App.state.baseWidth / 2,
                top: App.state.baseHeight / 2,
                stroke: cfg.gridColor,
                strokeWidth: 2,
                originX: "center",
                originY: "center",
              })
            );
          },

          addShape: function (type) {
            const comm = {
              ...this._getCenter(),
              fill: App.paper.getSettings().gridColor,
              strokeWidth: 0,
              originX: "center",
              originY: "center",
            };
            let obj;
            if (type === "rect")
              obj = new fabric.Rect({
                ...comm,
                width: 100,
                height: 100,
              });
            else if (type === "circle")
              obj = new fabric.Circle({
                ...comm,
                radius: 50,
              });
            else if (type === "triangle")
              obj = new fabric.Triangle({
                ...comm,
                width: 100,
                height: 100,
              });
            else if (type === "diamond") {
              const w = 100;
              const h = 100;
              const points = [
                { x: w / 2, y: 0 },
                { x: w, y: h / 2 },
                { x: w / 2, y: h },
                { x: 0, y: h / 2 },
              ];
              obj = new fabric.Polygon(points, {
                ...comm,
                width: w,
                height: h,
                fill: comm.fill,
              });
            } else if (type === "star") {
              const pts = [];
              for (let i = 0; i < 10; i++) {
                const r = i % 2 === 0 ? 50 : 19.1;
                const a = (Math.PI * i) / 5 - Math.PI / 2;
                pts.push({
                  x: Math.cos(a) * r,
                  y: Math.sin(a) * r,
                });
              }
              obj = new fabric.Polygon(pts, {
                ...comm,
                fill: comm.fill,
              });
            }
            if (obj) this._addToCanvas(obj);
          },

          handleImageUpload: function (input) {
            if (input.files?.[0]) {
              const reader = new FileReader();
              reader.onload = (e) =>
                fabric.Image.fromURL(e.target.result, (img) => {
                  const canvasW = App.state.baseWidth;
                  const canvasH = App.state.baseHeight;

                  const targetW = canvasW * 0.8;
                  const targetH = canvasH * 0.8;

                  const scaleX = targetW / img.width;
                  const scaleY = targetH / img.height;
                  const scale = Math.min(scaleX, scaleY);

                  img.scale(scale);

                  img.set({
                    left: canvasW / 2,
                    top: canvasH / 2,
                    originX: "center",
                    originY: "center",
                  });

                  this._addToCanvas(img);
                  input.value = "";
                });
              reader.readAsDataURL(input.files[0]);
            }
          },
          addSerialNumber: function () {
            const hasDataSource = App.state.dataSource.isActive || App.state.paperType === "label";

            const serialObj = new fabric.IText("1", {
              left: App.state.baseWidth / 2,
              top: App.state.baseHeight / 2,
              fontSize: Utils.pt2px(20),
              fontFamily: "Arial",
              fill: "#333333",
              originX: "center",
              originY: "center",
              editable: false,
            });

            serialObj.isSerialNumber = true;

            serialObj.serialConfig = {
              startValue: "1",
              step: 1,
              repeat: 1,
              changeType: "increment",
              generateCount: hasDataSource ? 1 : 10,
            };

            this._addToCanvas(serialObj);
            App.ui.updateInspector();
          },

          _calculateSerialNumber: function (config, index) {
            const cyclePosition = Math.floor(index / config.repeat);
            const startStr = String(config.startValue);
            const regex = /(\d+)(?=\D*$)/;
            const match = startStr.match(regex);
            if (!match) return startStr;
            const originalNumStr = match[0];
            const startNum = parseInt(originalNumStr, 10);
            const padLen = originalNumStr.length;
            const limit = Math.pow(10, padLen);
            let currentNum;
            if (config.changeType === "increment") {
              currentNum = startNum + cyclePosition * config.step;
            } else {
              let rawNum = startNum - cyclePosition * config.step;
              currentNum = ((rawNum % limit) + limit) % limit;
            }
            const currentNumStr = String(currentNum).padStart(padLen, "0");
            return startStr.replace(regex, currentNumStr);
          },

          replaceActiveImage: function (input) {
            if (!input.files || !input.files[0]) return;
            const file = input.files[0];

            let act = App.canvas.getActiveObject();
            let isBgMode = false;

            if (!act && App.state.editingBackground && App.canvas.backgroundImage) {
              act = App.canvas.backgroundImage;
              isBgMode = true;
            }

            if (!act || (act.type !== "image" && !isBgMode)) {
              input.value = "";
              return Utils.toast("请先选中图片", "error");
            }

            if (isBgMode && App.state.paperType === "label" && App.state.label.mode === "preview") {
              App.label.enterDesign();

              act = App.canvas.backgroundImage;
            }

            const onImageUpdated = (imgObj) => {
              if (isBgMode) {
                const w = App.state.baseWidth;
                const h = App.state.baseHeight;

                // 原逻辑看似是 scaleX/scaleY 直接拉伸适配，或者按比例。

                imgObj.scaleX = w / imgObj.width;
                imgObj.scaleY = h / imgObj.height;
                imgObj.left = w / 2;
                imgObj.top = h / 2;
                imgObj.originX = "center";
                imgObj.originY = "center";

                Utils.toast("背景已更新");
              } else {
                Utils.toast("图片已替换");
              }
            };

            if (isBgMode && !act) {
              const reader = new FileReader();
              reader.onload = (e) => {
                fabric.Image.fromURL(e.target.result, (img) => {
                  App.canvas.setBackgroundImage(img, () => {
                    onImageUpdated(img);
                    App.state.editingBackground = true;
                    App.ui.updateInspector();
                    App.history.saveState();
                  });
                });
              };
              reader.readAsDataURL(file);
            } else {
              this._updateImageSrc(act, file, onImageUpdated);
            }

            input.value = "";
          },

          setAsBackground: function () {
            const act = App.canvas.getActiveObject();
            if (act && act.type === "image") {
              App.canvas.setBackgroundImage(
                act,
                () => {
                  App.canvas.remove(act);

                  if (App.canvas.backgroundImage) {
                    App.canvas.backgroundImage.printBackground = true;
                  }

                  App.canvas.requestRenderAll();
                  App.state.editingBackground = true;
                  App.ui.updateInspector();
                  App.history.saveState();
                  Utils.toast("已设为背景");
                },
                {
                  ...act.toObject(["originX", "originY", "left", "top", "scaleX", "scaleY", "angle", "opacity"]),
                }
              );
            } else Utils.toast("请先选中一张图片", "error");
          },

          togglePrintBackground: function (checked) {
            if (App.canvas.backgroundImage) {
              App.canvas.backgroundImage.printBackground = checked;
              App.history.saveState();
            }
          },
          fillPaper: function () {
            const act = App.canvas.getActiveObject();
            if (!act || act.type !== "image") return Utils.toast("请先选中一张图片", "error");

            const w = App.state.baseWidth;
            const h = App.state.baseHeight;
            act.set({
              angle: 0,
              left: w / 2,
              top: h / 2,
              originX: "center",
              originY: "center",
              scaleX: w / act.width,
              scaleY: h / act.height,
            });

            act.setCoords();
            App.canvas.requestRenderAll();
            App.ui.updateInspector();
            App.history.saveState();
          },

          deleteActive: function () {
            const act = App.canvas.getActiveObject();
            if (!act) return;
            if (act.type === "activeSelection") {
              const objects = act.getObjects();
              const toDelete = objects.filter((o) => !o.lockMovementX);
              const lockedCount = objects.length - toDelete.length;
              if (toDelete.length > 0) {
                toDelete.forEach((o) => App.canvas.remove(o));
                if (lockedCount > 0) Utils.toast(`已删除 ${toDelete.length} 个对象，${lockedCount} 个锁定对象被保留`);
              } else {
                Utils.toast("所选对象全部已锁定，无法删除", "error");
              }
              App.canvas.discardActiveObject();
            } else {
              if (act.lockMovementX) {
                Utils.toast("对象已锁定，无法删除", "error");
                return;
              }

              App.canvas.remove(act);
              App.canvas.discardActiveObject();
            }

            App.ui.updateLayerList();
            App.ui.updateInspector();
            App.history.saveState();
          },

          nudge: function (dir) {
            const act = App.canvas.getActiveObject();
            if (!act) return;
            if (dir === "up") act.top -= 2;
            else if (dir === "down") act.top += 2;
            if (dir === "left") act.left -= 2;
            else if (dir === "right") act.left += 2;
            act.setCoords();
            App.canvas.requestRenderAll();
            App.ui.updateGeo(null, null, act);
          },

          updateSmartCorner: function (key, value) {
            const act = App.canvas.getActiveObject();
            if (!act || (act.type !== "rect" && !act.isSmartRect)) return;

            let cfg = act.cornerConfig || {
              tl: 0,
              tr: 0,
              bl: 0,
              br: 0,
              style: "round",
            };

            if (key === "all") {
              const v = parseInt(value) || 0;
              cfg.tl = cfg.tr = cfg.bl = cfg.br = v;
              ["tl", "tr", "bl", "br"].forEach((k) => (document.getElementById("corner" + k.toUpperCase()).value = v));
              document.getElementById("masterRadiusVal").innerText = v;
            } else if (key === "style") cfg.style = value;
            else cfg[key] = parseInt(value) || 0;

            const w = act.getScaledWidth();
            const h = act.getScaledHeight();
            const pathData = Utils.generateSmartRectPath(w, h, cfg, cfg.style);
            const center = act.getCenterPoint();
            const safeProps = act.toObject(["fill", "stroke", "strokeWidth", "opacity", "angle", "strokeDashArray", "strokeLineCap", "strokeLineJoin", "shadow", "globalCompositeOperation"]);
            const propsToRemove = ["type", "width", "height", "scaleX", "scaleY", "left", "top", "path", "pathOffset"];
            propsToRemove.forEach((prop) => delete safeProps[prop]);

            const newObj = new fabric.Path(pathData, {
              ...safeProps,
              isSmartRect: true,
              cornerConfig: cfg,
              scaleX: 1,
              scaleY: 1,
              originX: "center",
              originY: "center",
              left: center.x,
              top: center.y,
            });

            const idx = App.canvas.getObjects().indexOf(act);
            App.canvas.discardActiveObject();
            App.canvas.remove(act);
            App.canvas.insertAt(newObj, idx, true);
            App.canvas.setActiveObject(newObj);
            App.canvas.requestRenderAll();

            App.ui.updateInspector();
            App.history.saveState();
          },
          rotate: function (delta) {
            const act = App.canvas.getActiveObject();
            if (!act) return;
            let newAngle = (act.angle || 0) + delta;
            newAngle = newAngle % 360;
            act.rotate(newAngle);
            act.setCoords();
            App.canvas.requestRenderAll();
            App.ui.updateGeo("angle", newAngle);
            App.history.saveState();
            App.ui.updateInspector();
          },
          flip: function (dir) {
            const act = App.canvas.getActiveObject();
            if (!act) return;
            const prop = dir === "x" ? "flipX" : "flipY";
            if (act.type === "activeSelection") {
              const grp = act.toGroup();
              grp.set(prop, !grp[prop]);
              App.canvas.setActiveObject(grp.toActiveSelection());
            } else act.set(prop, !act[prop]);
            App.canvas.requestRenderAll();
            App.history.saveState();
          },
          addBarcode: async function () {
            const config = {
              ...App.barcode.defaults,
            };
            try {
              const obj = await App.barcode.createOrUpdate(null, config);
              this._addToCanvas(obj);
            } catch (e) {
              Utils.toast("创建条码失败: " + e.message, "error");
            }
          },
          group: function () {
            const act = App.canvas.getActiveObject();
            if (!act || act.type !== "activeSelection") return;

            act.toGroup();

            App.canvas.requestRenderAll();
            App.ui.updateLayerList();
            App.ui.updateInspector();
            App.history.saveState();
          },

          ungroup: function () {
            const act = App.canvas.getActiveObject();

            if (!act || act.type !== "group") return;
            if (act.isTable || act.isBarcode) {
              Utils.toast("特殊组件无法解组", "info");
              return;
            }

            act.toActiveSelection();

            App.canvas.requestRenderAll();
            App.ui.updateLayerList();
            App.ui.updateInspector();
            App.history.saveState();
          },
          toggleLock: function () {
            const act = App.canvas.getActiveObject();
            if (!act) return;
            const isLocked = act.lockMovementX;
            const newState = !isLocked;
            const setLockState = (obj, state) => {
              obj.lockMovementX = state;
              obj.lockMovementY = state;
              obj.lockRotation = state;
              obj.lockScalingX = state;
              obj.lockScalingY = state;
              obj.hasControls = !state;
              obj.selectable = true;
              obj.hoverCursor = state ? "not-allowed" : "move";
              if (["i-text", "textbox", "text"].includes(obj.type)) {
                const isDynamic = obj.isDynamicDate || obj.isDynamicPageNum || obj.isSerialNumber || (obj.dataBinding && obj.dataBinding.type === "variable");
                obj.set("editable", !state && !isDynamic);
              }
            };
            if (act.type === "activeSelection") {
              act.forEachObject((o) => setLockState(o, newState));
              setLockState(act, newState);
            } else {
              setLockState(act, newState);
            }

            App.canvas.requestRenderAll();
            App.ui.updateInspector();
            App.history.saveState();
            Utils.toast(newState ? "对象已锁定" : "对象已解锁");
          },
          _updateImageSrc: function (fabricObj, file, callback) {
            const reader = new FileReader();
            reader.onload = (e) => {
              fabricObj.setSrc(e.target.result, () => {
                if (callback) callback(fabricObj);

                fabricObj.setCoords();
                App.canvas.requestRenderAll();
                App.ui.updateInspector();
                App.history.saveState();
              });
            };
            reader.readAsDataURL(file);
          },
        },

        // --- 表格编辑器 ---
        tableEditor: {
          state: {
            rows: 3,
            cols: 3,
            colWidths: [100, 100, 100],
            rowHeights: [44, 44, 44],
            data: [],
            selected: [],
            resizing: null,
            resizeIndex: -1,
            resizeStartVal: 0,
            resizeStartSize: 0,
            isSelecting: false,
            selectAnchor: null,
            editingTarget: null,
            zoom: 1, // 新增：编辑器缩放比例
          },
          els: {},

          init: function () {
            this.cacheDom();
            this.attachEvents();
          },

          cacheDom: function () {
            const get = (id) => document.getElementById(id);
            this.els = {
              modal: get("tableModal"),
              gridBody: get("tableGridBody"),
              wrapper: get("tableWrapper"),
              editArea: get("tableEditArea"),
              floatMenu: get("tableFloatMenu"),
              insertBtn: get("tableInsertBtn"),
              cancelBtn: get("tableCancelBtn"),
              // ... 其他原有元素 ...
              floatFont: get("floatFontFamily"),
              floatSize: get("floatFontSize"),
              floatBold: get("floatBoldBtn"),
              floatBorderW: get("floatBorderWidth"),
              floatBorderC: get("floatBorderColorInput"),
              floatBorderInd: get("floatBorderColorInd"),
              floatBg: get("floatBgInput"),
              floatBgInd: get("floatBgIndicator"),
              floatText: get("floatTextInput"),
              floatTextInd: get("floatTextIndicator"),
              floatMerge: get("floatMergeBtn"),
              floatSplit: get("floatSplitBtn"),
              floatDataBindWrapper: get("floatDataBindWrapper"),
              floatDataBind: get("floatDataBind"),
              editorZoom: get("tableEditorZoom"),
              editorZoomVal: get("tableEditorZoomVal"),
              inputRows: get("tableEditorRowsInput"),
              inputCols: get("tableEditorColsInput"),
            };
          },

          attachEvents: function () {
            const e = this.els;
            if (!e.modal) return;

            e.insertBtn?.addEventListener("click", () => this.insertIntoCanvas());
            e.cancelBtn?.addEventListener("click", () => this.close());
            e.floatMerge?.addEventListener("click", () => this.mergeSelection());
            e.floatSplit?.addEventListener("click", () => this.splitSelection());
            e.floatBold?.addEventListener("click", () => this.toggleStyle("bold"));
            e.floatDataBind?.addEventListener("change", () => {
              this.applyDataBinding(e.floatDataBind.value);
            });

            const bindInput = (el, key, indicator) => {
              el?.addEventListener(el.tagName === "SELECT" ? "change" : "input", () => {
                const val = el.type === "number" ? parseFloat(el.value) : el.value;
                this.applyStyle({
                  [key]: val,
                });
                if (indicator) indicator.style.backgroundColor = el.value;
              });
            };
            bindInput(e.floatBg, "bg", e.floatBgInd);
            bindInput(e.floatText, "textColor", e.floatTextInd);
            bindInput(e.floatBorderC, "borderColor", e.floatBorderInd);
            bindInput(e.floatBorderW, "borderWidth");
            bindInput(e.floatSize, "fontSize");
            bindInput(e.floatFont, "fontFamily");

            if (e.gridBody) {
              e.gridBody.addEventListener("mousedown", (ev) => this.handleMouseDown(ev));
              e.gridBody.addEventListener("input", (ev) => this.handleCellInput(ev));
              e.gridBody.addEventListener("contextmenu", (ev) => ev.preventDefault());
            }

            document.addEventListener("mousemove", (ev) => this.handleMouseMove(ev));
            document.addEventListener("mouseup", () => this.handleMouseUp());

            e.editArea?.addEventListener("mousedown", (ev) => {
              if (ev.target === e.editArea) this.clearSelection();
            });
            if (e.inputRows) {
              e.inputRows.addEventListener("change", (ev) => {
                let val = parseInt(ev.target.value);
                if (val < 1) val = 1;
                this.resizeTable(val, this.state.cols);
              });
            }
            if (e.inputCols) {
              e.inputCols.addEventListener("change", (ev) => {
                let val = parseInt(ev.target.value);
                if (val < 1) val = 1;
                this.resizeTable(this.state.rows, val);
              });
            }
          },
          resizeTable: function (targetRows, targetCols) {
            const s = this.state;

            targetRows = Math.min(100, Math.max(1, targetRows));
            targetCols = Math.min(60, Math.max(1, targetCols));

            const oldRows = s.rows;
            const oldCols = s.cols;

            if (targetRows > oldRows) {
              for (let i = 0; i < targetRows - oldRows; i++) {
                s.data.push(
                  Array(s.cols)
                    .fill(null)
                    .map(() => this.createCell())
                );
                s.rowHeights.push(44);
              }
            } else if (targetRows < oldRows) {
              s.data.length = targetRows;
              s.rowHeights.length = targetRows;
            }
            s.rows = targetRows;

            if (targetCols > oldCols) {
              s.data.forEach((row) => {
                for (let i = 0; i < targetCols - oldCols; i++) {
                  row.push(this.createCell());
                }
              });
              for (let i = 0; i < targetCols - oldCols; i++) {
                s.colWidths.push(100);
              }
            } else if (targetCols < oldCols) {
              s.data.forEach((row) => {
                row.length = targetCols;
              });
              s.colWidths.length = targetCols;
            }
            s.cols = targetCols;

            this.updateInputs();
            this.renderGrid();
          },
          updateInputs: function () {
            if (this.els.inputRows) this.els.inputRows.value = this.state.rows;
            if (this.els.inputCols) this.els.inputCols.value = this.state.cols;
          },
          setZoom: function (val) {
            const v = parseFloat(val);
            this.state.zoom = v;
            if (this.els.wrapper) {
              this.els.wrapper.style.transform = `scale(${v})`;
              this.els.wrapper.style.transformOrigin = "center top";
            }
            if (this.els.editorZoomVal) {
              this.els.editorZoomVal.innerText = Math.round(v * 100) + "%";
            }
            if (this.els.editorZoom) {
              this.els.editorZoom.value = v;
            }
            this.updateFloatMenu();
          },

          changeZoom: function (delta) {
            let newZoom = this.state.zoom + delta;
            newZoom = Math.max(0.5, Math.min(3, newZoom));
            this.setZoom(newZoom);
          },

          createCell: function () {
            return {
              text: "",
              bg: "transparent",
              textColor: "#0f172a",
              fontFamily: "SourceHanSerifCN-Bold",
              fontSize: 14,
              align: "center",
              colspan: 1,
              rowspan: 1,
              hidden: false,
              bold: false,
              italic: false,
              borderWidth: 0.5,
              borderColor: "#666666",
              dataBinding: null,
              refId: null,
              syncMode: "none",
            };
          },
          applyDataBinding: function (val) {
            const cells = this.getSelectedCells();
            if (!cells.length) return;
            const ds = App.state.dataSource;
            let binding = null;
            let refId = null;
            let syncMode = "none";
            let previewText = "";
            if (val) {
              if (val.startsWith("ref:")) {
                refId = val.substring(4);
                syncMode = "ref";
                previewText = App.content.getSharedValue(refId) || `{${refId}}`;
              } else if (ds.isActive) {
                const [sheet, field] = val.split(":");
                binding = {
                  type: "variable",
                  sheet,
                  field,
                };
                if (ds.data.length > 0) {
                  const row = ds.data[App.state.currentDataIndex || 0];
                  if (row) previewText = String(row[field] || "");
                } else {
                  previewText = `{${field}}`;
                }
              }
            }

            cells.forEach(({ cell }) => {
              cell.dataBinding = null;
              cell.refId = null;
              cell.syncMode = "none";
              if (syncMode === "ref") {
                cell.refId = refId;
                cell.syncMode = "ref";
                cell.text = previewText;
              } else if (binding) {
                cell.dataBinding = binding;
                cell.text = previewText;
              }
            });
            this.renderGrid();
          },
          open: function (target = null) {
            this.state.selected = [];
            this.setZoom(1);

            this.updateFloatMenu();
            if (target?.isTable && target.tableData) {
              this.state.editingTarget = target;
              const d = target.tableData;
              this.state.rows = d.rows;
              this.state.cols = d.cols;
              this.state.colWidths = d.colWidths || Array(d.cols).fill(d.cellWidth || 100);
              this.state.rowHeights = d.rowHeights || Array(d.rows).fill(d.cellHeight || 44);
              this.state.data = this.normalizeCells(d.cells);
              this.els.insertBtn.innerHTML = '<i class="ph ph-check-circle text-lg"></i> 更新表格';
            } else {
              this.state.editingTarget = null;
              this.resetData(3, 3);
              this.els.insertBtn.innerHTML = '<i class="ph ph-plus-circle text-lg"></i> 插入表格';
            }
            this.updateInputs();
            this.renderGrid();
            this.els.modal.classList.remove("hidden");
            this.els.modal.classList.add("flex");
          },

          close: function () {
            this.els.modal.classList.add("hidden");
            this.els.modal.classList.remove("flex");
            this.clearSelection();
            this.state.editingTarget = null;
          },

          resetData: function (rows, cols) {
            this.state.rows = rows;
            this.state.cols = cols;
            this.state.colWidths = Array(cols).fill(100);
            this.state.rowHeights = Array(rows).fill(44);
            this.state.data = Array(rows)
              .fill(null)
              .map(() =>
                Array(cols)
                  .fill(null)
                  .map(() => this.createCell())
              );
          },

          addCR: function (type, pos) {
            const s = this.state;
            if (type === "row") {
              const newRow = Array(s.cols)
                .fill(null)
                .map(() => this.createCell());
              if (pos === "top") {
                s.data.unshift(newRow);
                s.rowHeights.unshift(44);
              } else {
                s.data.push(newRow);
                s.rowHeights.push(44);
              }
              s.rows++;
            } else {
              s.data.forEach((row) => {
                const cell = this.createCell();
                if (pos === "left") row.unshift(cell);
                else row.push(cell);
              });
              if (pos === "left") s.colWidths.unshift(100);
              else s.colWidths.push(100);
              s.cols++;
            }
            this.updateInputs();
            this.renderGrid();
          },

          deleteCR: function (type) {
            const sels = this.getSelectedCells();
            if (!sels.length) return Utils.toast("请先选择单元格", "error");
            const indices = new Set();
            sels.forEach((s) => indices.add(type === "row" ? s.row : s.col));
            const sortedIndices = Array.from(indices).sort((a, b) => b - a);

            if (type === "row" && this.state.rows - sortedIndices.length < 1) return Utils.toast("至少保留一行", "error");
            if (type === "col" && this.state.cols - sortedIndices.length < 1) return Utils.toast("至少保留一列", "error");

            if (type === "row") {
              sortedIndices.forEach((idx) => {
                this.state.data.splice(idx, 1);
                this.state.rowHeights.splice(idx, 1);
              });
              this.state.rows -= sortedIndices.length;
            } else {
              sortedIndices.forEach((idx) => {
                this.state.colWidths.splice(idx, 1);
                this.state.data.forEach((row) => row.splice(idx, 1));
              });
              this.state.cols -= sortedIndices.length;
            }
            this.clearSelection();
            this.updateInputs();
            this.renderGrid();
            Utils.toast(`已删除 ${sortedIndices.length} ${type === "row" ? "行" : "列"}`);
          },

          renderGrid: function () {
            const body = this.els.gridBody;
            if (!body) return;
            body.innerHTML = "";
            this.state.data.forEach((row, r) => {
              const tr = document.createElement("tr");
              row.forEach((cell, c) => {
                if (cell.hidden) return;
                const td = document.createElement("td");
                let w = 0,
                  h = 0;
                for (let i = 0; i < cell.colspan; i++) w += this.state.colWidths[c + i];
                for (let i = 0; i < cell.rowspan; i++) h += this.state.rowHeights[r + i];
                td.dataset.row = r;
                td.dataset.col = c;
                td.rowSpan = cell.rowspan;
                td.colSpan = cell.colspan;
                td.innerText = cell.text || "";
                td.contentEditable = true;
                Object.assign(td.style, {
                  backgroundColor: cell.bg,
                  color: cell.textColor,
                  textAlign: cell.align,
                  fontFamily: cell.fontFamily,
                  fontSize: cell.fontSize + "px",
                  fontWeight: cell.bold ? "bold" : "normal",
                  border: `${cell.borderWidth ?? 1}px solid ${cell.borderColor ?? "#cbd5e1"}`,
                  width: w + "px",
                  height: h + "px",
                  minWidth: "20px",
                });
                tr.appendChild(td);
              });
              body.appendChild(tr);
            });
            this.paintSelection();
          },

          handleMouseMove: function (e) {
            if (this.state.resizing) {
              e.preventDefault();

              const zoom = this.state.zoom || 1;
              const currentVal = this.state.resizing.includes("col") ? e.clientX : e.clientY;
              const startVal = this.state.resizeStartVal;

              // 如果是 left/top 边缘，鼠标向负方向移动时，尺寸应该增加，所以要反向计算
              let delta = (currentVal - startVal) / zoom;
              if (this.state.resizing === "col-left" || this.state.resizing === "row-top") {
                delta = -delta;
              }

              const newSize = Math.max(20, this.state.resizeStartSize + delta);

              if (this.state.resizing.includes("col")) {
                this.state.colWidths[this.state.resizeIndex] = newSize;
                const cells = this.els.gridBody.querySelectorAll(`td[data-col="${this.state.resizeIndex}"]`);
                cells.forEach((cell) => {
                  if (cell.style.display !== "none" && cell.colSpan === 1) {
                    cell.style.width = newSize + "px";
                  }
                });
              } else {
                this.state.rowHeights[this.state.resizeIndex] = newSize;
                const rows = this.els.gridBody.children;
                const targetRow = rows[this.state.resizeIndex];
                if (targetRow) {
                  Array.from(targetRow.children).forEach((cell) => {
                    if (cell.rowSpan === 1) {
                      cell.style.height = newSize + "px";
                    }
                  });
                }
              }
              return;
            }

            const td = e.target.closest("td");
            if (this.state.isSelecting && td && this.els.gridBody.contains(td)) {
              this.selectRange(this.state.selectAnchor, {
                r: +td.dataset.row,
                c: +td.dataset.col,
              });
              return;
            }

            if (!td || !this.els.gridBody.contains(td)) {
              document.body.style.cursor = "default";
              return;
            }

            const rect = td.getBoundingClientRect();
            const hitTest = 6;

            const onRight = Math.abs(e.clientX - rect.right) < hitTest;
            const onBottom = Math.abs(e.clientY - rect.bottom) < hitTest;

            const isFirstCol = parseInt(td.dataset.col) === 0;
            const isFirstRow = parseInt(td.dataset.row) === 0;
            const onLeft = isFirstCol && Math.abs(e.clientX - rect.left) < hitTest;
            const onTop = isFirstRow && Math.abs(e.clientY - rect.top) < hitTest;

            if (onRight || onLeft) {
              td.style.cursor = "col-resize";
              td.dataset.edge = onRight ? "right" : "left";
            } else if (onBottom || onTop) {
              td.style.cursor = "row-resize";
              td.dataset.edge = onBottom ? "bottom" : "top";
            } else {
              td.style.cursor = "text";
              delete td.dataset.edge;
            }
          },

          handleMouseDown: function (e) {
            const td = e.target.closest("td");

            if (!td || (e.button !== 0 && e.button !== 2)) return;

            const edge = td.dataset.edge;

            if (edge && e.button === 0) {
              e.preventDefault();

              let colIdx = parseInt(td.dataset.col);
              let rowIdx = parseInt(td.dataset.row);

              if (edge === "right") colIdx += (parseInt(td.colSpan) || 1) - 1;

              if (edge === "bottom") rowIdx += (parseInt(td.rowSpan) || 1) - 1;

              if (edge === "right" || edge === "left") {
                this.state.resizing = edge === "left" ? "col-left" : "col";
                this.state.resizeStartVal = e.clientX;
                this.state.resizeIndex = colIdx;
                this.state.resizeStartSize = this.state.colWidths[colIdx];
                document.body.style.cursor = "col-resize";
              } else {
                this.state.resizing = edge === "top" ? "row-top" : "row";
                this.state.resizeStartVal = e.clientY;
                this.state.resizeIndex = rowIdx;
                this.state.resizeStartSize = this.state.rowHeights[rowIdx];
                document.body.style.cursor = "row-resize";
              }
            } else {
              this.state.isSelecting = true;
              this.state.selectAnchor = {
                r: +td.dataset.row,
                c: +td.dataset.col,
              };
              this.selectRange(this.state.selectAnchor, this.state.selectAnchor);
            }
          },

          handleMouseUp: function () {
            if (this.state.resizing) {
              this.state.resizing = null;
              document.body.style.cursor = "default";
              this.renderGrid();
            }
            if (this.state.isSelecting) {
              this.state.isSelecting = false;
              this.updateFloatMenu();
            }
          },

          selectRange: function (start, end) {
            const minR = Math.min(start.r, end.r),
              maxR = Math.max(start.r, end.r);
            const minC = Math.min(start.c, end.c),
              maxC = Math.max(start.c, end.c);
            this.state.selected = [];
            for (let r = minR; r <= maxR; r++)
              for (let c = minC; c <= maxC; c++)
                this.state.selected.push({
                  row: r,
                  col: c,
                });
            this.paintSelection();
          },

          paintSelection: function () {
            const selMap = new Set(this.state.selected.map((s) => `${s.row},${s.col}`));
            this.els.gridBody.querySelectorAll("td").forEach((td) => td.classList.toggle("selected", selMap.has(`${td.dataset.row},${td.dataset.col}`)));
          },

          clearSelection: function () {
            this.state.selected = [];
            this.paintSelection();
            this.updateFloatMenu();
          },

          updateFloatMenu: function () {
            const menu = this.els.floatMenu;
            const ds = App.state.dataSource;
            const sharedKeys = App.content.getAvailableSharedIds();
            if (this.state.selected.length === 0) {
              menu.classList.add("hidden");
              return;
            }

            const selectedTds = this.els.gridBody.querySelectorAll("td.selected");
            if (selectedTds.length === 0) return;
            let minTop = Infinity,
              minLeft = Infinity,
              maxRight = -Infinity;
            selectedTds.forEach((td) => {
              const r = td.getBoundingClientRect();
              if (r.top < minTop) minTop = r.top;
              if (r.left < minLeft) minLeft = r.left;
              if (r.right > maxRight) maxRight = r.right;
            });
            const containerRect = this.els.editArea.getBoundingClientRect();
            menu.style.top = minTop - containerRect.top + this.els.editArea.scrollTop + "px";
            menu.style.left = minLeft + (maxRight - minLeft) / 2 - containerRect.left + this.els.editArea.scrollLeft + "px";
            menu.classList.remove("hidden");
            const isSingleSelection = this.state.selected.length === 1;
            const hasDataSource = ds.isActive && ds.headers.length > 0;
            const hasSharedVars = sharedKeys.length > 0;
            const bindWrapper = this.els.floatDataBindWrapper;
            const bindSelect = this.els.floatDataBind;
            if (isSingleSelection && (hasDataSource || hasSharedVars) && bindWrapper && bindSelect) {
              bindWrapper.classList.remove("hidden");
              const cellData = this.getSelectedCells()[0].cell;
              const currentSheet = ds.currentSheet;
              bindSelect.innerHTML = '<option value="">不绑定数据</option>';
              if (hasDataSource) {
                ds.headers.forEach((header) => {
                  const optionValue = `${currentSheet}:${header}`;
                  const opt = document.createElement("option");
                  opt.value = optionValue;
                  opt.innerText = header;
                  if (cellData.dataBinding && cellData.dataBinding.sheet === currentSheet && cellData.dataBinding.field === header) {
                    opt.selected = true;
                  }
                  groupExcel.appendChild(opt);
                });
                bindSelect.appendChild(groupExcel);
              }

              if (hasSharedVars) {
                const groupShared = document.createElement("optgroup");
                groupShared.label = "共享字段";
                sharedKeys.forEach((key) => {
                  const optionValue = `ref:${key}`;
                  const opt = document.createElement("option");
                  opt.value = optionValue;
                  opt.innerText = key;
                  if (cellData.syncMode === "ref" && cellData.refId === key) {
                    opt.selected = true;
                  }
                  groupShared.appendChild(opt);
                });
                bindSelect.appendChild(groupShared);
              }
            } else if (bindWrapper) {
              bindWrapper.classList.add("hidden");
            }

            const firstCell = this.getSelectedCells()[0]?.cell;
            if (firstCell) {
              const sync = (el, val, ind) => {
                if (!el) return;
                if (el.type === "color" || el.hasAttribute("data-coloris")) {
                  el.value = val === "transparent" || val === "rgba(0, 0, 0, 0)" ? "#ffffff" : val;
                } else {
                  el.value = val;
                }

                if (ind) {
                  ind.style.backgroundColor = val;
                  ind.style.boxShadow = !val || val === "transparent" || val === "#ffffff" ? "inset 0 0 0 1px #cbd5e1" : "none";
                }
              };
              sync(this.els.floatBg, firstCell.bg, this.els.floatBgInd);
              sync(this.els.floatText, firstCell.textColor, this.els.floatTextInd);
              sync(this.els.floatBorderC, firstCell.borderColor, this.els.floatBorderInd);
              if (this.els.floatBorderW) this.els.floatBorderW.value = firstCell.borderWidth;
              if (this.els.floatSize) this.els.floatSize.value = firstCell.fontSize;
              if (this.els.floatFont) this.els.floatFont.value = firstCell.fontFamily;
              if (this.els.floatBold) {
                this.els.floatBold.classList.toggle("text-slate-900", !!firstCell.bold);
                this.els.floatBold.classList.toggle("bg-gray-100", !!firstCell.bold);
              }
            }
          },

          handleCellInput: function (e) {
            const td = e.target;
            const cell = this.state.data[td.dataset.row]?.[td.dataset.col];
            if (cell) cell.text = td.innerText;
          },
          getSelectedCells: function () {
            return this.state.selected
              .map((p) => ({
                ...p,
                cell: this.state.data[p.row]?.[p.col],
              }))
              .filter((i) => i.cell && !i.cell.hidden);
          },
          applyStyle: function (updates) {
            this.getSelectedCells().forEach(({ cell }) => Object.assign(cell, updates));
            this.renderGrid();
          },
          toggleStyle: function (key) {
            const cells = this.getSelectedCells();
            if (!cells.length) return;
            const val = !cells[0].cell[key];
            cells.forEach(({ cell }) => (cell[key] = val));
            this.renderGrid();
          },

          mergeSelection: function () {
            const cells = this.getSelectedCells();
            if (cells.length < 2) return Utils.toast("请选择至少两个单元格", "error");
            const rows = cells.map((c) => c.row),
              cols = cells.map((c) => c.col);
            const minRow = Math.min(...rows),
              maxRow = Math.max(...rows),
              minCol = Math.min(...cols),
              maxCol = Math.max(...cols);
            if ((maxRow - minRow + 1) * (maxCol - minCol + 1) !== cells.length) return Utils.toast("请选择矩形区域", "error");
            if (cells.some(({ cell }) => cell.rowspan > 1 || cell.colspan > 1)) return Utils.toast("区域含已合并单元格", "error");

            const base = this.state.data[minRow][minCol];
            let mergedText = base.text;
            cells.forEach((c, idx) => {
              if (idx > 0 && c.cell.text.trim()) mergedText += " " + c.cell.text;
            });
            base.text = mergedText;
            base.rowspan = maxRow - minRow + 1;
            base.colspan = maxCol - minCol + 1;

            for (let r = minRow; r <= maxRow; r++) {
              for (let c = minCol; c <= maxCol; c++) {
                if (r === minRow && c === minCol) continue;
                this.state.data[r][c].hidden = true;
                this.state.data[r][c].text = "";
              }
            }
            this.state.selected = [
              {
                row: minRow,
                col: minCol,
              },
            ];
            this.renderGrid();
            this.updateFloatMenu();
          },

          splitSelection: function () {
            const target = this.getSelectedCells()[0];
            if (!target || (target.cell.rowspan === 1 && target.cell.colspan === 1)) return;
            const { row, col } = target;
            const cell = target.cell;
            const maxRow = row + cell.rowspan - 1;
            const maxCol = col + cell.colspan - 1;
            cell.rowspan = 1;
            cell.colspan = 1;
            for (let r = row; r <= maxRow; r++) for (let c = col; c <= maxCol; c++) if (r !== row || c !== col) this.state.data[r][c] = this.createCell();
            this.state.selected = [
              {
                row,
                col,
              },
            ];
            this.renderGrid();
            this.updateFloatMenu();
          },

          normalizeCells: function (cells) {
            return cells
              ? cells.map((row) =>
                  row.map((c) => ({
                    ...this.createCell(),
                    ...c,
                  }))
                )
              : [];
          },

          insertIntoCanvas: function () {
            if (!App.canvas) return;
            const config = {
              rows: this.state.rows,
              cols: this.state.cols,
              colWidths: [...this.state.colWidths],
              rowHeights: [...this.state.rowHeights],
              cells: JSON.parse(JSON.stringify(this.state.data)),
            };

            if (!this.state.editingTarget && App.state.paperType === "label" && App.state.label.mode === "design") {
              const totalW = config.colWidths.reduce((a, b) => a + b, 0);
              const totalH = config.rowHeights.reduce((a, b) => a + b, 0);

              const targetW = App.state.baseWidth * 0.9;
              const targetH = App.state.baseHeight * 0.9;

              const scaleX = targetW / totalW;
              const scaleY = targetH / totalH;
              const scale = Math.min(scaleX, scaleY);

              if (scale !== 1) {
                config.colWidths = config.colWidths.map((w) => w * scale);
                config.rowHeights = config.rowHeights.map((h) => h * scale);
                config.cells.forEach((row) => {
                  row.forEach((cell) => {
                    if (cell.fontSize) {
                      cell.fontSize = Math.max(4, Math.round(cell.fontSize * scale * 10) / 10);
                    }
                    if (cell.borderWidth) {
                      cell.borderWidth = Math.max(0.1, cell.borderWidth * scale);
                    }
                  });
                });
              }
            }

            if (this.state.editingTarget) {
              this._replaceTableOnCanvas(this.state.editingTarget, config);
              Utils.toast("表格已更新");
            } else {
              App.tools._addToCanvas(this.buildFabricTable(config));
              Utils.toast("表格已插入");
            }
            if (App.dataSource) App.dataSource.refreshBindingState();
            this.close();
          },

          buildFabricTable: function (config) {
            const objs = [];
            const colAcc = [0];
            config.colWidths.forEach((w, i) => colAcc.push(colAcc[i] + w));
            const rowAcc = [0];
            config.rowHeights.forEach((h, i) => rowAcc.push(rowAcc[i] + h));
            const totalW = colAcc[colAcc.length - 1],
              totalH = rowAcc[rowAcc.length - 1];
            const offsetX = totalW / 2,
              offsetY = totalH / 2;

            for (let r = 0; r < config.rows; r++) {
              for (let c = 0; c < config.cols; c++) {
                const cell = config.cells[r][c];
                if (!cell || cell.hidden) continue;
                const cellW = colAcc[c + cell.colspan] - colAcc[c];
                const cellH = rowAcc[r + cell.rowspan] - rowAcc[r];
                const left = colAcc[c] + cellW / 2 - offsetX;
                const top = rowAcc[r] + cellH / 2 - offsetY;

                objs.push(
                  new fabric.Rect({
                    left,
                    top,
                    width: cellW,
                    height: cellH,
                    fill: cell.bg || "#ffffff",
                    stroke: cell.borderColor || "#000",
                    strokeWidth: cell.borderWidth ?? 1,
                    originX: "center",
                    originY: "center",
                  })
                );

                if (cell.text && cell.text.trim()) {
                  const padding = Math.min(8, cellW * 0.15);
                  const textWidth = Math.max(0, cellW - padding);

                  objs.push(
                    new fabric.Textbox(cell.text, {
                      left,
                      top,
                      width: textWidth,
                      fontSize: cell.fontSize || 14,
                      fontFamily: cell.fontFamily || "SourceHanSerifCN-Bold",
                      fontWeight: cell.bold ? "bold" : "normal",
                      fontStyle: cell.italic ? "italic" : "normal",
                      fill: cell.textColor || "#000",
                      textAlign: cell.align || "center",
                      originX: "center",
                      originY: "center",
                      splitByGrapheme: true,
                      editable: false,
                    })
                  );
                }
              }
            }
            objs.push(
              new fabric.Rect({
                left: 0,
                top: 0,
                width: totalW,
                height: totalH,
                fill: "transparent",
                strokeWidth: 0,
                originX: "center",
                originY: "center",
                excludeFromExport: true,
              })
            );

            return new fabric.Group(objs, {
              left: App.state.baseWidth / 2,
              top: App.state.baseHeight / 2,
              originX: "center",
              originY: "center",
              isTable: true,
              tableData: config,
              lockScalingX: false,
              lockScalingY: false,
              hasControls: true,
              hasBorders: true,
              lockUniScaling: false,
            });
          },

          _replaceTableOnCanvas: function (target, data) {
            const center = target.getCenterPoint();
            const preserved = {
              angle: target.angle,
              scaleX: target.scaleX,
              scaleY: target.scaleY,
              opacity: target.opacity,
            };
            const newGroup = this.buildFabricTable(data);
            newGroup.set({
              left: center.x,
              top: center.y,
              ...preserved,
            });
            const idx = App.canvas.getObjects().indexOf(target);
            App.canvas.remove(target);
            App.canvas.insertAt(newGroup, idx >= 0 ? idx : undefined, true);
            App.canvas.setActiveObject(newGroup);
            App.canvas.requestRenderAll();
            App.ui.updateLayerList();
            App.history.saveState();
            this.state.editingTarget = newGroup;
          },

          normalizeScaledTable: function (tableObj) {
            if (!tableObj?.isTable || !tableObj.tableData) return;

            const sX = tableObj.scaleX || 1;
            const sY = tableObj.scaleY || 1;

            if (Math.abs(sX - 1) < 0.001 && Math.abs(sY - 1) < 0.001) return;

            const d = JSON.parse(JSON.stringify(tableObj.tableData));
            if (!d.colWidths) d.colWidths = Array(d.cols).fill(d.cellWidth || 100);
            if (!d.rowHeights) d.rowHeights = Array(d.rows).fill(d.cellHeight || 44);

            d.colWidths = d.colWidths.map((w) => w * sX);
            d.rowHeights = d.rowHeights.map((h) => h * sY);

            if (d.cells)
              d.cells.forEach((row) =>
                row.forEach((cell) => {
                  if (cell && cell.fontSize) {
                    cell.fontSize = Math.max(4, Math.round(cell.fontSize * sX * 10) / 10);
                  }
                  if (cell.borderWidth) {
                    const rawWidth = cell.borderWidth * Math.min(sX, sY);
                    cell.borderWidth = Math.max(0.1, Math.round(rawWidth * 10) / 10);
                  }
                })
              );

            tableObj.scaleX = 1;
            tableObj.scaleY = 1;
            this._replaceTableOnCanvas(tableObj, d);
          },
          updateActiveTableStyle: function (styleUpdates) {
            const act = App.canvas.getActiveObject();
            if (!act || !act.isTable || !act.tableData) return;

            act.tableData.cells.forEach((row) => {
              row.forEach((cell) => {
                Object.assign(cell, styleUpdates);
              });
            });

            const transform = act.toObject(["left", "top", "scaleX", "scaleY", "angle", "opacity", "originX", "originY"]);

            const newGroup = this.buildFabricTable(act.tableData);
            newGroup.set(transform);

            const idx = App.canvas.getObjects().indexOf(act);
            App.canvas.discardActiveObject();
            App.canvas.remove(act);
            App.canvas.insertAt(newGroup, idx, true);
            App.canvas.setActiveObject(newGroup);
            App.canvas.requestRenderAll();

            App.history.saveState();
          },
        },

        // --- 条码生成与管理 ---
        barcode: {
          defaults: {
            type: "code128",
            text: "12345678910",
            scaleX: 2,
            scaleY: 1,
            color: "#000000",
            includeText: true,
            textAlign: "center",
            barheight: 10,
            showText: true,
            ecc: "Q",
            fontSize: 10,
            textGap: 0,
          },

          errorIconPath: "./static/barcode-error.svg",

          is2DType: function (type) {
            return ["qrcode", "microqrcode", "datamatrix", "gs1datamatrix", "azteccode", "maxicode", "pdf417", "micropdf417", "hanxin", "dotcode", "gridmatrix"].includes(type);
          },

          generateSVG: function (config) {
            try {
              if (!config.text || String(config.text).trim() === "") throw new Error("数据为空");
              const is2D = this.is2DType(config.type);
              const opts = {
                bcid: config.type,
                text: config.text,
                scale: config.scaleX || 2,
                textxalign: config.textAlign || "center",
                barcolor: config.color.replace("#", ""),
                textcolor: config.color.replace("#", ""),
              };
              if (!is2D) {
                opts.height = parseInt(config.barheight) || 10;
                opts.includetext = config.showText;
                opts.textsize = parseInt(config.fontSize) || 10;
                opts.textyoffset = parseInt(config.textGap) || 0;
              }

              if (config.type === "qrcode" || config.type === "microqrcode") {
                opts.eclevel = config.ecc || "L";
              }

              const svg = bwipjs.toSVG(opts);
              return { svg, error: null };
            } catch (e) {
              return { svg: null, error: e.message };
            }
          },

          createErrorObj: function (targetObj, config, errorMsg) {
            return new Promise((resolve) => {
              fabric.loadSVGFromURL(this.errorIconPath, (objects, options) => {
                let errObj;
                if (!objects || objects.length === 0) {
                  errObj = new fabric.Textbox("ERROR", { width: 100, fontSize: 14, backgroundColor: "#fee2e2" });
                } else {
                  errObj = fabric.util.groupSVGElements(objects, options);
                }

                const safeConfig = JSON.parse(JSON.stringify(config));
                errObj.set({
                  isBarcode: true,
                  barcodeConfig: safeConfig,
                  originX: "center",
                  originY: "center",
                  lockUniScaling: false,
                });
                if (targetObj) {
                  errObj.set({
                    left: targetObj.left,
                    top: targetObj.top,
                    angle: targetObj.angle,
                    dataBinding: targetObj.dataBinding,
                    scaleX: targetObj.scaleX,
                    scaleY: targetObj.scaleY,
                  });
                } else {
                  const center = App.tools._getCenter();
                  errObj.set({ left: center.left, top: center.top });
                }
                resolve(errObj);
              });
            });
          },

          createOrUpdate: async function (targetObj, config, shouldResetScale = false) {
            const res = this.generateSVG(config);
            if (res.error) return this.createErrorObj(targetObj, config, res.error);
            return new Promise((resolve) => {
              fabric.loadSVGFromString(res.svg, (objects, options) => {
                const loadedObj = fabric.util.groupSVGElements(objects, options);
                const commonProps = {
                  isBarcode: true,
                  barcodeConfig: JSON.parse(JSON.stringify(config)),
                  originX: "center",
                  originY: "center",
                  lockUniScaling: this.is2DType(config.type),
                };
                if (targetObj) {
                  loadedObj.set({
                    left: targetObj.left,
                    top: targetObj.top,
                    angle: targetObj.angle,
                    scaleX: shouldResetScale ? 1 : targetObj.scaleX,
                    scaleY: shouldResetScale ? 1 : targetObj.scaleY,
                  });
                  loadedObj.rawContent = targetObj.rawContent;
                  loadedObj.prefixRaw = targetObj.prefixRaw !== undefined ? targetObj.prefixRaw : targetObj.prefix || "";
                  loadedObj.suffixRaw = targetObj.suffixRaw !== undefined ? targetObj.suffixRaw : targetObj.suffix || "";
                  loadedObj.prefix = loadedObj.prefixRaw;
                  loadedObj.suffix = loadedObj.suffixRaw;
                  loadedObj.set({
                    dataBinding: targetObj.dataBinding,
                    sharedId: targetObj.sharedId,
                    refId: targetObj.refId,
                    syncMode: targetObj.syncMode,

                    isSerialNumber: targetObj.isSerialNumber,
                    serialConfig: targetObj.serialConfig,
                    isDynamicDate: targetObj.isDynamicDate,
                    dateConfig: targetObj.dateConfig,
                    isDynamicPageNum: targetObj.isDynamicPageNum,
                    pageConfig: targetObj.pageConfig,
                  });
                } else {
                  const center = App.tools._getCenter();
                  loadedObj.set({
                    left: center.left,
                    top: center.top,
                    rawContent: config.text,
                    prefixRaw: "",
                    suffixRaw: "",
                    prefix: "",
                    suffix: "",
                    syncMode: "none",
                  });
                }

                Object.assign(loadedObj, commonProps);
                resolve(loadedObj);
              });
            });
          },

          handleResize: function (target) {
            const cfg = target.barcodeConfig;
            const is2D = this.is2DType(cfg.type);
            let newScaleX = (cfg.scaleX || 2) * target.scaleX;
            newScaleX = Math.max(1, Math.min(10, newScaleX));
            let newHeight = cfg.barheight;
            if (!is2D) {
              newHeight = (cfg.barheight || 10) * target.scaleY;
              newHeight = Math.max(1, Math.min(150, newHeight));
            } else {
            }

            cfg.scaleX = newScaleX;
            cfg.barheight = newHeight;
            this.createOrUpdate(target, cfg, true).then((newObj) => {
              App.ui._replaceObject(target, newObj);
              if (App.canvas.getActiveObject() === newObj) {
                const elH = document.getElementById("bcBarHeight");
                if (elH) elH.value = Math.round(newHeight);
              }
            });
          },

          toggleOptions: function (type) {
            const is2D = this.is2DType(type);
            document.getElementById("bc1DOptions").classList.toggle("hidden", is2D);
            const show2DPanel = type === "qrcode" || type === "microqrcode";
            document.getElementById("bc2DOptions").classList.toggle("hidden", !show2DPanel);
          },

          toggleSharedMode: function (isChecked) {
            const textArea = document.getElementById("bcText");
            const select = document.getElementById("bcSharedSelect");
            if (isChecked) {
              textArea.classList.add("hidden");
              select.classList.remove("hidden");
              App.ui.refreshSharedSelectForBarcode();
            } else {
              textArea.classList.remove("hidden");
              select.classList.add("hidden");
              const act = App.canvas.getActiveObject();
              if (act) textArea.value = act.rawContent || "";
            }
            this.applySettings();
          },
          applySettings: async function () {
            const act = App.canvas.getActiveObject();
            if (!act || !act.isBarcode) return;
            const getVal = (id) => document.getElementById(id).value;
            const getChk = (id) => document.getElementById(id).checked;
            const newVisualConfig = {
              type: getVal("bcType"),
              color: getVal("bcColor"),
              showText: getChk("bcShowText"),
              textAlign: getVal("bcTextAlign"),
              barheight: parseInt(getVal("bcBarHeight")) || 10,
              fontSize: parseInt(getVal("bcFontSize")) || 10,
              textGap: parseInt(getVal("bcTextGap")) || 0,
              ecc: getVal("bcEcc"),
              scaleX: act.barcodeConfig.scaleX || 2,
            };
            if (act.barcodeConfig.type !== newVisualConfig.type) {
              newVisualConfig.scaleX = 2;
            }

            act.barcodeConfig = { ...act.barcodeConfig, ...newVisualConfig };
            const useShared = getChk("bcUseShared");
            const isVariable = act.dataBinding && act.dataBinding.type === "variable";
            const isAuto = act.isSerialNumber || act.isDynamicDate || act.isDynamicPageNum;
            if (!isVariable && !isAuto) {
              if (useShared) {
                const refId = getVal("bcSharedSelect");
                if (refId) {
                  act.syncMode = "ref";
                  act.refId = refId;
                }
              } else {
                act.syncMode = "none";
                act.refId = null;
                act.rawContent = getVal("bcText");
              }
            }

            await App.content.render(act);
            this.toggleOptions(newVisualConfig.type);
            App.history.saveState();
          },
        },

        // --- UI 管理 ---
        ui: {
          setDataType: function (type) {
            const act = App.canvas.getActiveObject();
            if (!act || (!["i-text", "textbox", "text"].includes(act.type) && !act.isBarcode && act.type !== "image")) return;
            if (act.syncMode === "ref") {
              act.syncMode = "none";
              act.refId = null;
            }

            delete act.dataBinding;
            act.isSerialNumber = false;
            act.isDynamicDate = false;
            if (!act.isBarcode && act.type !== "image") act.set("editable", true);
            let newValue = null;
            if (type === "static") {
              newValue = act.rawContent || "";
            } else if (type === "variable") {
              const ds = App.state.dataSource;
              act.dataBinding = {
                type: "variable",
                sheet: ds.currentSheet || (ds.sheetNames.length ? ds.sheetNames[0] : ""),
                field: ds.headers.length ? ds.headers[0] : "",
              };
              if (!act.isBarcode && act.type !== "image") act.set("editable", false);
              if (ds.isActive && ds.data.length > 0 && act.dataBinding.field) {
                const row = ds.data[App.state.currentDataIndex || 0];
                newValue = row ? String(row[act.dataBinding.field] || "") : "";
              } else {
                newValue = act.dataBinding.field ? `{${act.dataBinding.field}}` : act.isBarcode ? "123456" : "变量预览";
              }
            } else if (type === "serial") {
              act.isSerialNumber = true;
              if (!act.serialConfig) {
                act.serialConfig = {
                  startValue: "1",
                  step: 1,
                  repeat: 1,
                  changeType: "increment",
                  generateCount: 10,
                };
              }
              if (!act.isBarcode) act.set("editable", false);
              newValue = App.tools._calculateSerialNumber(act.serialConfig, App.state.currentDataIndex || 0);
            } else if (type === "date") {
              act.isDynamicDate = true;
              if (!act.dateConfig) {
                act.dateConfig = {
                  showDate: true,
                  showTime: false,
                  dateFormat: "YYYY-MM-DD",
                  timeFormat: "HH:mm:ss",
                  offsetDays: 0,
                  offsetMinutes: 0,
                };
              }
              if (!act.isBarcode) act.set("editable", false);
              newValue = Utils.formatDate(new Date(), null, act.dateConfig);
            }

            if (newValue !== null) {
              act.rawContent = newValue;
              App.content.render(act);
            }

            if (act.isEditing && typeof act.exitEditing === "function") act.exitEditing();
            setTimeout(() => App.ui.updateInspector(), 0);
            App.history.saveState();
          },
          updateGeo: function (key, val, targetObj = null) {
            const act = targetObj || App.canvas.getActiveObject();
            if (!act) return;
            if (val === undefined || val === null) {
              const p = act.getPointByOrigin("left", "top");
              document.getElementById("propX").value = Utils.px2mm(p.x).toFixed(1);
              document.getElementById("propY").value = Utils.px2mm(p.y).toFixed(1);
              document.getElementById("propAngle").value = Math.round(act.angle);
              document.getElementById("propW").value = Utils.px2mm(act.getScaledWidth()).toFixed(1);
              document.getElementById("propH").value = Utils.px2mm(act.getScaledHeight()).toFixed(1);
            } else {
              const numVal = parseFloat(val);
              if (isNaN(numVal)) return;
              if (key === "angle") act.set("angle", numVal);
              else {
                const pxVal = Utils.mm2px(numVal);
                if (key === "left" || key === "top") {
                  let cx = parseFloat(document.getElementById("propX").value),
                    cy = parseFloat(document.getElementById("propY").value);
                  act.setPositionByOrigin(new fabric.Point(Utils.mm2px(key === "left" ? numVal : cx), Utils.mm2px(key === "top" ? numVal : cy)), "left", "top");
                } else if (key === "width") act.type === "textbox" ? act.set("width", pxVal) : act.set("scaleX", pxVal / act.width);
                else if (key === "height") act.set("scaleY", pxVal / act.height);
              }
              if (act.isTable && (key === "width" || key === "height")) {
                act.setCoords();
                App.tableEditor.normalizeScaledTable(act);
                return;
              }
              act.setCoords();
              App.canvas.requestRenderAll();
              App.history.saveState();
            }
          },

          setProp: function (key, val) {
            const act = App.canvas.getActiveObject();
            if (act) {
              if (act.isTable) {
                const map = {};
                if (key === "fontFamily") map.fontFamily = val;
                if (key === "fontSize") map.fontSize = val;
                if (key === "fill") map.textColor = val;
                if (key === "textAlign") map.align = val;
                if (key === "stroke") map.borderColor = val;
                if (key === "strokeWidth") map.borderWidth = parseFloat(val);

                if (Object.keys(map).length > 0) {
                  App.tableEditor.updateActiveTableStyle(map);
                }
                return;
              }

              if (key === "textAlign" && ["i-text", "textbox", "text"].includes(act.type)) {
                let anchorPoint;
                if (val === "left") {
                  anchorPoint = act.getPointByOrigin("left", "top");
                } else if (val === "right") {
                  anchorPoint = act.getPointByOrigin("right", "top");
                } else {
                  anchorPoint = act.getPointByOrigin("center", "top");
                }

                act.set("textAlign", val);
                act.set("originX", val);

                act.setPositionByOrigin(anchorPoint, val, "top");

                act.setCoords();
              } else {
                if (key === "strokeWidth" && val > 0 && (!act.stroke || act.stroke === "transparent")) {
                  act.set("stroke", "#666666");
                  const colorPicker = document.getElementById("shapeStroke") || document.getElementById("lineColor");
                  if (colorPicker) colorPicker.value = "#666666";
                }

                act.type === "activeSelection" ? act.forEachObject((o) => o.set(key, val)) : act.set(key, val);
              }

              App.canvas.requestRenderAll();
              App.history.saveState();

              App.ui.updateGeo(null, null, act);
            }
          },

          updateLineDash: function () {
            const act = App.canvas.getActiveObject();
            if (!act || act.type !== "line") return;
            const v = parseFloat(document.getElementById("lineDashVal").value) || 5;
            act.set("strokeDashArray", document.getElementById("lineDashCheck").checked ? [v, v] : null);
            App.canvas.requestRenderAll();
            App.history.saveState();
          },

          toggleStyle: function (style) {
            const act = App.canvas.getActiveObject();
            if (!act) return;
            if (act.isTable) {
              const cell = act.tableData.cells[0][0];
              let update = {};
              if (style === "bold") update.bold = !cell.bold;
              if (style === "italic") update.italic = !cell.italic;

              if (Object.keys(update).length > 0) {
                App.tableEditor.updateActiveTableStyle(update);
                document.getElementById("btnBold").classList.toggle("active", update.bold !== undefined ? update.bold : cell.bold);
                document.getElementById("btnItalic").classList.toggle("active", update.italic !== undefined ? update.italic : cell.italic);
              }
              return;
            }
            if (style === "bold") act.set("fontWeight", act.fontWeight === "bold" ? "normal" : "bold");
            else if (style === "italic") act.set("fontStyle", act.fontStyle === "italic" ? "normal" : "italic");
            else if (style === "underline") act.set("underline", !act.underline);
            App.canvas.requestRenderAll();
            this.updateInspector();
            App.history.saveState();
          },
          toggleVertical: function () {
            const act = App.canvas.getActiveObject();
            if (!act || !["i-text", "text", "textbox"].includes(act.type)) return;

            const isVert = !!act.isVertical;
            const text = act.text || "";

            if (!isVert) {
              act._prevLineHeight = act.lineHeight;
              act._prevTextAlign = act.textAlign;

              const paragraphs = text.split("\n");
              const vertParagraphs = paragraphs.map((p) => {
                return p.split("").join("\n");
              });
              const vertText = vertParagraphs.join("\n\n");

              act.set({
                text: vertText,
                isVertical: true,
                textAlign: "center",
                lineHeight: 1,
                width: act.type === "textbox" ? act.width : undefined,
              });
            } else {
              const vertParagraphs = text.split(/\n\n/);
              const horizParagraphs = vertParagraphs.map((p) => {
                return p.replace(/\n/g, "");
              });
              const horizText = horizParagraphs.join("\n");

              act.set({
                text: horizText,
                isVertical: false,
                textAlign: act._prevTextAlign || "left",
                lineHeight: act._prevLineHeight || 1.2,
              });
            }

            act.setCoords();
            App.canvas.requestRenderAll();
            this.updateInspector();
            App.history.saveState();
          },

          updateShapeDash: function () {
            const act = App.canvas.getActiveObject();
            if (!act) return;
            const isChecked = document.getElementById("shapeDashCheck").checked;
            const v = parseInt(document.getElementById("shapeDashVal").value) || 5;
            act.set("strokeDashArray", isChecked ? [v, v] : null);
            App.canvas.requestRenderAll();
            App.history.saveState();
          },

          toggleShapeFill: function () {
            const act = App.canvas.getActiveObject();
            if (!act) return;
            const noFill = document.getElementById("shapeNoFill").checked;
            const wrapper = document.getElementById("shapeFillWrapper");
            if (act.isTable) {
              if (noFill) {
                App.tableEditor.updateActiveTableStyle({
                  bg: "transparent",
                });
                wrapper.classList.add("opacity-50", "pointer-events-none");
              } else {
                const color = document.getElementById("shapeFill").value || "#ffffff";
                App.tableEditor.updateActiveTableStyle({
                  bg: color,
                });
                wrapper.classList.remove("opacity-50", "pointer-events-none");
              }
              return;
            }

            if (noFill) {
              if (act.fill !== "transparent") act._lastColor = act.fill;
              act.set("fill", "transparent");
              wrapper.classList.add("opacity-50", "pointer-events-none");
              if (!act.strokeWidth || act.strokeWidth === 0) {
                const defaultStroke = "#666666";
                const defaultWidth = 0.5;
                act.set({
                  stroke: defaultStroke,
                  strokeWidth: defaultWidth,
                });

                const elColor = document.getElementById("shapeStroke");
                const elWidth = document.getElementById("shapeStrokeWidth");
                if (elColor) elColor.value = defaultStroke;
                if (elWidth) elWidth.value = defaultWidth;
              }
            } else {
              const color = act._lastColor || document.getElementById("shapeFill").value || "#666666";
              act.set("fill", color);
              wrapper.classList.remove("opacity-50", "pointer-events-none");
              document.getElementById("shapeFill").value = color;
            }
            App.canvas.requestRenderAll();
            App.history.saveState();
          },

          setShapeFill: function (val) {
            const act = App.canvas.getActiveObject();
            if (!act) return;
            if (act.isTable) {
              App.tableEditor.updateActiveTableStyle({
                bg: val,
              });
              document.getElementById("shapeNoFill").checked = false;
              document.getElementById("shapeFillWrapper").classList.remove("opacity-50", "pointer-events-none");
              return;
            }

            act.set("fill", val);
            act._lastColor = val;

            document.getElementById("shapeNoFill").checked = false;
            document.getElementById("shapeFillWrapper").classList.remove("opacity-50", "pointer-events-none");

            App.canvas.requestRenderAll();
            App.history.saveState();
          },

          updateToolbarState: function () {
            const act = App.canvas.getActiveObject();
            let count = 0;
            let type = "";

            if (act) {
              type = act.type;
              if (type === "activeSelection") {
                count = act.getObjects().length;
              } else {
                count = 1;
              }
            }

            const canTune = count >= 1;
            document.querySelectorAll(".tune-btn").forEach((btn) => (btn.disabled = !canTune));

            const canAlign = count >= 2;
            document.querySelectorAll(".align-btn").forEach((btn) => (btn.disabled = !canAlign));

            const canDistribute = count >= 3;
            document.querySelectorAll(".dist-btn").forEach((btn) => (btn.disabled = !canDistribute));

            const btnGroup = document.getElementById("btnGroup");
            const btnUngroup = document.getElementById("btnUngroup");

            if (btnGroup) {
              btnGroup.disabled = type !== "activeSelection";
            }

            if (btnUngroup) {
              const isGenericGroup = type === "group" && !act.isTable && !act.isBarcode;
              btnUngroup.disabled = !isGenericGroup;
            }
            const btnLock = document.getElementById("btnLock");
            if (btnLock) {
              btnLock.disabled = !act;
              if (act) {
                const isLocked = act.lockMovementX;
                btnLock.innerHTML = isLocked ? '<i class="ph ph-lock-key text-red-600"></i>' : '<i class="ph ph-lock-key-open"></i>';
                btnLock.classList.toggle("bg-red-50", !!isLocked);
              }
            }
          },

          updateInspector: function () {
            const ui = this._getUIProxy();
            const act = App.canvas.getActiveObject();

            if (act) App.state.editingBackground = false;
            const hasBgImage = !!App.canvas.backgroundImage;
            if (!hasBgImage && App.state.editingBackground) App.state.editingBackground = false;
            const isBgEdit = App.state.editingBackground && hasBgImage;
            const hasSelection = !!act || isBgEdit;

            this.updateToolbarState();

            const allPanels = [
              "selectionControls",
              "dataTypeTabs",
              "affixProps",
              "geoProps",
              "transProps",
              "textProps",
              "imgProps",
              "lineProps",
              "shapeProps",
              "tableProps",
              "rectCornerControl",
              "dataProps",
              "barcodeProps",
              "dateProps",
              "pageNumProps",
              "serialProps",
              "sharedProps",
            ];
            allPanels.forEach((id) => ui(id).show(false));
            document.getElementById("dataTypeTabs")?.classList.replace("grid-cols-2", "grid-cols-4");
            ui("noSelection").show(!hasSelection);
            if (!hasSelection) {
              this.updateLayerList();
              return;
            }

            ui("selectionControls").show(true);

            const propLockBtn = document.getElementById("propLockBtn");
            const propLockIcon = document.getElementById("propLockIcon");
            const propLockText = document.getElementById("propLockText");

            if (propLockBtn && act) {
              const isLocked = act.lockMovementX;
              propLockIcon.className = isLocked ? "ph ph-lock-key text-red-600 text-lg" : "ph ph-lock-key-open text-lg";
              propLockText.innerText = isLocked ? "已锁定" : "未锁定";
              propLockText.className = isLocked ? "text-[10px] text-red-600 font-bold" : "text-[10px] text-slate-400";
            }

            if (isBgEdit) {
              this._renderBackgroundProps(ui, App.canvas.backgroundImage);
            } else if (act) {
              ui("geoProps").show(true);
              ui("transProps").show(true);
              this.updateGeo(null, null, act);
              ui("propOpacity").val(act.opacity || 1);
              ui("opacityVal").text(Math.round((act.opacity || 1) * 100) + "%");

              const supportsAffix = ["i-text", "textbox", "text"].includes(act.type) || act.isBarcode;
              ui("affixProps").show(supportsAffix);
              if (supportsAffix) {
                ui("propPrefix").val(act.prefixRaw !== undefined ? act.prefixRaw : act.prefix || "");
                ui("propSuffix").val(act.suffixRaw !== undefined ? act.suffixRaw : act.suffix || "");
              }

              const supportsDataBinding = ["i-text", "textbox", "text"].includes(act.type) || act.isBarcode;
              let currentType = "static";

              if (supportsDataBinding) {
                ui("dataTypeTabs").show(true);

                if (act.dataBinding && act.dataBinding.type === "variable") currentType = "variable";
                else if (act.isSerialNumber) currentType = "serial";
                else if (act.isDynamicDate) currentType = "date";

                ["static", "variable", "serial", "date"].forEach((type) => {
                  const btn = document.getElementById(`dtBtn-${type}`);
                  if (btn) {
                    const isActive = type === currentType;
                    btn.className = isActive
                      ? "py-1.5 text-center rounded-md transition text-[10px] font-bold bg-white text-red-600 shadow-sm ring-1 ring-black/5"
                      : "py-1.5 text-center rounded-md transition text-[10px] font-bold text-slate-500 hover:text-slate-700 hover:bg-gray-200/50";
                  }
                });

                if (currentType === "variable") {
                  ui("dataProps").show(true);
                  this._updateVDPUI(ui, act);
                } else if (currentType === "serial") {
                  ui("serialProps").show(true);
                  const cfg = act.serialConfig || {};
                  ui("serialStartValue").val(cfg.startValue);
                  ui("serialStep").val(cfg.step);
                  ui("serialRepeat").val(cfg.repeat);
                  ui("serialChangeType").val(cfg.changeType);

                  const wrapper = document.getElementById("serialGenerateCountWrapper");
                  if (wrapper) {
                    const isLabelMode = App.state.paperType === "label";
                    if (isLabelMode) {
                      wrapper.classList.add("hidden");
                    } else {
                      wrapper.classList.remove("hidden");
                      // 确保回显当前配置的生成数量，如果没有则默认为 10
                      ui("serialGenerateCount").val(cfg.generateCount || 10);
                    }
                  }
                  this.updateSerialPreview(cfg);
                } else if (currentType === "date") {
                  ui("dateProps").show(true);
                  const cfg = act.dateConfig || {};
                  const dSel = document.getElementById("dateFormat");
                  const tSel = document.getElementById("timeFormat");
                  if (dSel && dSel.options.length === 0) {
                    DATE_FMT_OPTS.forEach((o) => dSel.add(new Option(o.l, o.v)));
                    TIME_FMT_OPTS.forEach((o) => tSel.add(new Option(o.l, o.v)));
                  }
                  ui("dateShowDate").check(cfg.showDate);
                  ui("dateShowTime").check(cfg.showTime);
                  ui("dateFormat").val(cfg.dateFormat);
                  ui("timeFormat").val(cfg.timeFormat);
                  ui("dateOffsetDays").val(cfg.offsetDays || 0);
                  ui("dateOffsetMinutes").val(cfg.offsetMinutes || 0);
                  document.getElementById("dateFormatWrapper").classList.toggle("hidden", !cfg.showDate);
                  document.getElementById("timeFormatWrapper").classList.toggle("hidden", !cfg.showTime);
                }
              }

              if (act.isBarcode) {
                this._updateBarcodePanel(ui, act, currentType);
              } else if (["i-text", "textbox", "text"].includes(act.type)) {
                this._updateTextPanel(ui, act);
              } else if (act.type === "activeSelection") {
                this._handleMultiSelection(ui, act);
              } else if (act.isTable) {
                this._updateTablePanel(ui, act);
              } else if (act.type === "image") {
                this._updateImagePanel(ui, act, false);
              } else if (act.type === "line") {
                this._updateLinePanel(ui, act);
              } else if (["rect", "circle", "triangle", "polygon", "path"].includes(act.type)) {
                this._updateShapePanel(ui, act);
              }
            }

            this.updateLayerList();
          },
          setSharedId: function (val) {
            const act = App.canvas.getActiveObject();
            if (!act) return;
            const cleanVal = val.trim();
            act.set("sharedId", cleanVal);
            if (cleanVal) {
              App.variables.set(cleanVal, act.text || "", act);
            }
            App.history.saveState();
          },
          toggleSyncMode: function (mode) {
            const sharePanel = document.getElementById("syncPanel_share");
            const refPanel = document.getElementById("syncPanel_ref");
            const act = App.canvas.getActiveObject();
            if (mode === "none") {
              sharePanel.classList.add("hidden");
              refPanel.classList.add("hidden");
              if (act) {
                this.clearSyncData();
              }
            } else if (mode === "share") {
              sharePanel.classList.remove("hidden");
              refPanel.classList.add("hidden");
              if (act) document.getElementById("propSharedInput").value = act.sharedId || "";
            } else if (mode === "ref") {
              sharePanel.classList.add("hidden");
              refPanel.classList.remove("hidden");
              this.refreshSharedSelect();
              const select = document.getElementById("propSharedSelect");
              if (select) select.value = act.refId || "";
            }
          },

          refreshSharedSelect: function () {
            const select = document.getElementById("propSharedSelect");
            const act = App.canvas.getActiveObject();
            const currentId = act ? act.sharedId : "";

            select.innerHTML = '<option value="">选择共享字段</option>';

            const keys = App.content.getAvailableSharedIds();

            if (keys.length === 0) {
              const opt = document.createElement("option");
              opt.text = "(暂无共享字段)";
              opt.disabled = true;
              select.add(opt);
            }

            keys.forEach((key) => {
              const opt = document.createElement("option");
              opt.value = key;
              opt.text = key;
              if (key === currentId) opt.selected = true;
              select.add(opt);
            });
          },
          saveSharedId: function () {
            const input = document.getElementById("propSharedInput");
            const val = input.value.trim();
            if (!val) return Utils.toast("请输入共享名称", "error");
            const act = App.canvas.getActiveObject();
            if (!act) return;
            const exists = App.canvas.getObjects().some((obj) => {
              return obj !== act && obj.sharedId === val && obj.syncMode === "share";
            });
            if (exists) {
              return Utils.toast(`共享名称 "${val}" 已存在，请使用其他名称`, "error");
            }
            act.set({
              sharedId: val,
              syncMode: "share",
            });
            App.content.render(act);
            App.history.saveState();
            Utils.toast(`已设置共享字段: ${val}`);
            App.ui.updateInspector();
          },
          applyRefId: function (val) {
            if (!val) return;
            const act = App.canvas.getActiveObject();
            if (!act) return;

            act.set("refId", val);
            act.set("syncMode", "ref");
            act.set("editable", true);
            App.content.render(act);
            App.history.saveState();
            App.ui.updateInspector();
          },

          clearSyncData: function () {
            const act = App.canvas.getActiveObject();
            if (!act) return;
            act.set({
              sharedId: null,
              refId: null,
              syncMode: "none",
              editable: true,
            });
            const input = document.getElementById("propSharedInput");
            if (input) input.value = "";
            const select = document.getElementById("propSharedSelect");
            if (select) select.value = "";
            const noneRadio = document.querySelector('input[name="syncMode"][value="none"]');
            if (noneRadio) noneRadio.checked = true;
            document.getElementById("syncPanel_ref")?.classList.add("hidden");
            document.getElementById("syncPanel_share")?.classList.add("hidden");
            App.history.saveState();
            Utils.toast("已取消同步");
            App.ui.updateInspector();
          },

          _renderBackgroundProps: function (ui, bgObj) {
            ui("propOpacity").val(bgObj.opacity || 1);
            ui("opacityVal").text(Math.round((bgObj.opacity || 1) * 100) + "%");
            this._updateImagePanel(ui, bgObj, true);
          },

          _updateImagePanel: function (ui, obj, isBackground) {
            ui("imgProps").show(true);
            ui("affixProps").show(false);

            if (isBackground) {
              ui("imgNormalControls").show(false);
              ui("imgBgControls").show(true);

              document.getElementById("vdpImgDirCtrl").classList.add("hidden");

              const shouldPrint = obj.printBackground !== false;
              ui("checkPrintBg").check(shouldPrint);
            } else {
              ui("imgNormalControls").show(true);
              ui("imgBgControls").show(false);
              ui("dataTypeTabs").show(true);

              document.getElementById("dataTypeTabs")?.classList.replace("grid-cols-4", "grid-cols-2");

              const btnStatic = document.getElementById("dtBtn-static");
              const btnVariable = document.getElementById("dtBtn-variable");

              ["dtBtn-serial", "dtBtn-date"].forEach((id) => document.getElementById(id)?.classList.add("hidden"));

              const isVar = obj.dataBinding && obj.dataBinding.type === "variable";

              if (isVar) {
                ui("imgProps").show(false);
              }

              const activeClass = "py-1.5 text-center rounded-md transition text-[10px] font-bold bg-white text-red-600 shadow-sm ring-1 ring-black/5";
              const normalClass = "py-1.5 text-center rounded-md transition text-[10px] font-bold text-slate-500 hover:text-slate-700 hover:bg-gray-200/50";

              if (btnStatic) btnStatic.className = !isVar ? activeClass : normalClass;
              if (btnVariable) btnVariable.className = isVar ? activeClass : normalClass;

              if (isVar) {
                ui("dataProps").show(true);
                this._updateVDPUI(ui, obj);
                const dirCtrl = document.getElementById("vdpImgDirCtrl");
                const statusText = document.getElementById("vdpImgDirStatus");
                const btnText = document.getElementById("vdpImgDirBtnText");
                if (dirCtrl) {
                  dirCtrl.classList.remove("hidden");

                  if (obj.imgDirId && obj.imgDirName) {
                    statusText.innerText = `📁 ${obj.imgDirName}`;
                    statusText.className = "text-[10px] text-green-600 font-bold truncate max-w-[120px] inline-block align-bottom";
                    btnText.innerText = "更改文件夹...";
                    statusText.title = obj.imgDirName;
                  } else {
                    statusText.innerText = "未单独设置";
                    statusText.className = "text-[10px] text-orange-500 font-bold";
                    btnText.innerText = "设置图片文件夹...";
                  }
                }
              } else {
                ui("dataProps").show(false);
                document.getElementById("vdpImgDirCtrl").classList.add("hidden");
              }
            }
          },

          _handleMultiSelection: function (ui, act) {
            const objs = act.getObjects();
            const types = new Set(objs.map((o) => o.type));
            const isOnly = (...args) => [...types].every((t) => args.includes(t));

            if (isOnly("i-text", "textbox", "text")) {
              this._updateTextPanel(ui, objs[0]);
            } else if (isOnly("rect", "circle", "triangle", "polygon", "path")) {
              this._updateShapePanel(ui, objs[0]);
              ui("rectCornerControl").show(false);
            } else if (isOnly("line")) {
              this._updateLinePanel(ui, objs[0]);
            }
          },

          updateDateConfig: function (key, value) {
            const act = App.canvas.getActiveObject();
            if (!act || !act.isDynamicDate) return;
            const cfg = act.dateConfig;
            if (key === "showDate" && !value && !cfg.showTime) {
              document.getElementById("dateShowDate").checked = true;
              return Utils.toast("日期和时间至少显示一项", "info");
            }
            if (key === "showTime" && !value && !cfg.showDate) {
              document.getElementById("dateShowTime").checked = true;
              return Utils.toast("日期和时间至少显示一项", "info");
            }

            cfg[key] = value;
            if (key === "showDate") document.getElementById("dateFormatWrapper").classList.toggle("hidden", !value);
            if (key === "showTime") document.getElementById("timeFormatWrapper").classList.toggle("hidden", !value);
            const newText = Utils.formatDate(new Date(), null, cfg);
            act.rawContent = newText;
            App.content.render(act);
            App.history.saveState();
          },

          updatePageConfig: function (key, value) {
            const act = App.canvas.getActiveObject();
            if (!act || !act.isDynamicPageNum) return;

            act.pageConfig[key] = value;

            const currentPage = (App.state.currentDataIndex || 0) + act.pageConfig.startFrom;
            const totalPages = App.dataSource.calculateTotalPages();
            let text = act.pageConfig.format.replace("{page}", currentPage).replace("{total}", totalPages);

            act.set("text", text);
            App.canvas.requestRenderAll();
            App.history.saveState();
          },
          updateSerialConfig: function (key, value) {
            const act = App.canvas.getActiveObject();
            if (!act || (!act.isSerialNumber && !act.isBarcode)) return;
            if (!act.serialConfig) return;
            act.serialConfig[key] = value;
            this.updateSerialPreview(act.serialConfig);
            if (key === "generateCount") {
              App.dataSource.updateNavUI();
            } else {
              const currentIndex = App.state.currentDataIndex || 0;
              const newText = App.tools._calculateSerialNumber(act.serialConfig, currentIndex);
              act.rawContent = newText;
              App.content.render(act);
            }

            App.history.saveState();
          },

          updateSerialPreview: function (config) {
            const preview = [];
            const previewCount = 6;

            for (let i = 0; i < previewCount; i++) {
              preview.push(App.tools._calculateSerialNumber(config, i));
            }

            const previewText = preview.join(", ") + "...";

            const el = document.getElementById("serialPreviewText");
            if (el) el.innerText = "预览: " + previewText;
          },
          _getUIProxy: function () {
            return (id) => {
              const el = document.getElementById(id);
              return {
                el,
                val: (v) => {
                  if (el) el.value = v ?? "";
                  return this._getUIProxy()(id);
                },
                text: (v) => {
                  if (el) el.innerText = v;
                  return this._getUIProxy()(id);
                },
                check: (v) => {
                  if (el) el.checked = !!v;
                  return this._getUIProxy()(id);
                },
                show: (force = true) => {
                  if (el) el.classList.toggle("hidden", !force);
                  return this._getUIProxy()(id);
                },
                parentShow: (force = true) => {
                  if (el && el.parentElement) el.parentElement.classList.toggle("hidden", !force);
                  return this._getUIProxy()(id);
                },
                active: (force) => {
                  if (el) el.classList.toggle("active", !!force);
                  return this._getUIProxy()(id);
                },
              };
            };
          },

          _updateBarcodePanel: function (ui, act, currentType) {
            ui("barcodeProps").show(true);
            const cfg = act.barcodeConfig || {};
            const isAutoGenerated = act.isSerialNumber || act.isDynamicDate || currentType === "variable";
            const inputContainer = document.getElementById("bcText").parentElement;

            if (isAutoGenerated) {
              if (inputContainer) inputContainer.classList.add("hidden");
              const sharedCheck = document.getElementById("bcUseShared");
              if (sharedCheck && sharedCheck.parentElement && sharedCheck.parentElement.parentElement) {
                sharedCheck.parentElement.parentElement.classList.add("hidden");
              }
            } else {
              if (inputContainer) inputContainer.classList.remove("hidden");
              const sharedCheck = document.getElementById("bcUseShared");
              if (sharedCheck && sharedCheck.parentElement && sharedCheck.parentElement.parentElement) {
                sharedCheck.parentElement.parentElement.classList.remove("hidden");
              }

              const isSharedRef = act.syncMode === "ref";
              const checkbox = document.getElementById("bcUseShared");
              const textArea = document.getElementById("bcText");
              const select = document.getElementById("bcSharedSelect");
              checkbox.checked = isSharedRef;

              if (!isSharedRef) {
                ui("bcText").val(act.rawContent !== undefined ? act.rawContent : cfg.text);
              }
            }

            ui("bcType").val(cfg.type);
            ui("bcColor").val(cfg.color);
            ui("bcShowText").check(cfg.showText !== false);
            ui("bcTextAlign").val(cfg.textAlign || "center");
            ui("bcBarHeight").val(cfg.barheight || 10);
            ui("bcFontSize").val(cfg.fontSize || 10);
            ui("bcTextGap").val(cfg.textGap || 0);
            ui("bcEcc").val(cfg.ecc || "Q");
            App.barcode.toggleOptions(cfg.type);
          },

          _updateTablePanel: function (ui, act) {
            ui("tableProps").show(true);
            ui("textProps").show(true);
            ui("shapeProps").show(true);
            ui("affixProps").show(false);
            ui("propLineHeight").parentShow(false);
            ui("propCharSpacing").parentShow(false);
            ui("shapeDash").show(false);
            ui("rectCornerControl").show(false);
            const cell = act.tableData.cells[0]?.[0] || App.tableEditor.createCell();
            ui("propFont").val(cell.fontFamily);
            ui("propSize").val(Utils.px2pt(cell.fontSize));
            ui("propColor").val(cell.textColor);
            ui("btnBold").active(cell.bold);
            ui("btnItalic").active(cell.italic);
            ui("btnUnderline").active(false);
            ui("btnVertical").active(!!act.isVertical);
            const isTransparent = cell.bg === "transparent" || !cell.bg;
            ui("shapeFill").val(isTransparent ? "#f2f2f2" : cell.bg);
            if (ui("shapeFillWrapper").el) ui("shapeFillWrapper").el.classList.remove("opacity-50", "pointer-events-none");
            ui("shapeNoFill").check(cell.bg === "transparent");
            ui("shapeStroke").val(cell.borderColor);
            ui("shapeStrokeWidth").val(cell.borderWidth);
            ui("varSettings").show(false);
          },

          _updateTextPanel: function (ui, act) {
            ui("textProps").show(true);
            ui("sharedProps").show(true);

            ui("propLineHeight")
              .parentShow(true)
              .val(act.lineHeight || 1.2);
            ui("lineHeightVal").val(act.lineHeight || 1.2);
            ui("propCharSpacing")
              .parentShow(true)
              .val(act.charSpacing || 0);
            ui("charSpacingVal").val(act.charSpacing || 0);
            ui("propFont").val(act.fontFamily);
            ui("propSize").val(Utils.px2pt(act.fontSize));
            ui("propColor").val(act.fill);
            ui("btnBold").active(act.fontWeight === "bold");
            ui("btnItalic").active(act.fontStyle === "italic");
            ui("btnUnderline").active(!!act.underline);
            ui("btnVertical").active(!!act.isVertical);

            const sharedId = act.sharedId;
            const radios = document.getElementsByName("syncMode");
            const sharePanel = document.getElementById("syncPanel_share");
            const refPanel = document.getElementById("syncPanel_ref");

            const input = document.getElementById("propSharedInput");
            const btn = document.getElementById("propSharedBtn");
            const hint = document.getElementById("propSharedHint");

            sharePanel.classList.add("hidden");
            refPanel.classList.add("hidden");

            const currentMode = act.syncMode || (sharedId ? "share" : "none");

            radios.forEach((r) => (r.checked = r.value === currentMode));

            if (currentMode === "share") {
              sharePanel.classList.remove("hidden");
              if (input) {
                input.value = sharedId || "";
                input.disabled = true;
              }
              if (btn) {
                btn.innerText = "删除";
                btn.onclick = () => App.ui.clearSyncData();
              }
              if (hint) {
                hint.innerHTML = `提示：在其他字段前后缀中输入<b class="text-red-600">{${sharedId}}</b>可引用。`;
              }
            } else if (currentMode === "ref") {
              refPanel.classList.remove("hidden");
              this.refreshSharedSelect();
              const select = document.getElementById("propSharedSelect");
              if (select) select.value = act.refId || "";
            } else {
              if (input) {
                input.value = "";
                input.disabled = false;
              }
              if (btn) {
                btn.innerText = "保存";
                btn.onclick = () => App.ui.saveSharedId();
              }
              if (hint) {
                hint.innerHTML = `提示：在其他字段前后缀中输入 {共享字段名} 可引用。`;
              }
            }

            if (typeof act.prefixRaw === "undefined") act.prefixRaw = act.prefix || "";
            if (typeof act.suffixRaw === "undefined") act.suffixRaw = act.suffix || "";
            const pRaw = act.prefixRaw !== undefined ? act.prefixRaw : act.prefix || "";
            const sRaw = act.suffixRaw !== undefined ? act.suffixRaw : act.suffix || "";

            ui("propPrefix").val(pRaw);
            ui("propSuffix").val(sRaw);

            if (act.isDynamicPageNum) {
              ui("pageNumProps").show(true);
              ui("pageFormat").val(act.pageConfig.format);
              ui("pageStartFrom").val(act.pageConfig.startFrom);
              ui("dataTypeTabs").show(false);
            } else {
              ui("pageNumProps").show(false);
            }
          },

          _updateLinePanel: function (ui, act) {
            ui("lineProps").show(true);
            ui("lineColor").val(act.stroke);
            ui("lineStrokeWidth").val(act.strokeWidth);
            const dash = act.strokeDashArray;
            ui("lineDashCheck").check(!!(dash && dash.length));
            ui("lineDashVal").val((dash && dash[0]) || 5);
          },

          _updateShapePanel: function (ui, act) {
            ui("shapeProps").show(true);
            ui("affixProps").show(false);
            const isTransparent = act.fill === "transparent" || !act.fill;
            ui("shapeNoFill").check(isTransparent);
            const wrapper = ui("shapeFillWrapper").el;
            if (wrapper) {
              if (isTransparent) {
                wrapper.classList.add("opacity-50", "pointer-events-none");
                ui("shapeFill").val(act._lastColor || "#666666");
              } else {
                wrapper.classList.remove("opacity-50", "pointer-events-none");
                ui("shapeFill").val(act.fill);
              }
            }
            ui("shapeStroke").val(act.stroke || "#666666");
            ui("shapeStrokeWidth").val(act.strokeWidth || 0);
            const dash = act.strokeDashArray;
            ui("shapeDash")
              .check(!!(dash && dash.length))
              .parentShow(true);
            ui("shapeDashVal").val((dash && dash[0]) || 5);
            if (act.type === "rect" || act.isSmartRect) {
              ui("rectCornerControl").show(true);
              const conf = act.cornerConfig || {
                tl: act.rx || 0,
                tr: act.rx || 0,
                bl: act.rx || 0,
                br: act.rx || 0,
                style: "round",
              };
              ui("cornerStyle").val(conf.style);
              ["tl", "tr", "bl", "br"].forEach((k) => ui(`corner${k.toUpperCase()}`).val(conf[k]));

              if (conf.tl === conf.tr && conf.tr === conf.bl && conf.bl === conf.br) {
                ui("masterRadius").val(conf.tl);
                ui("masterRadiusVal").val(conf.tl);
              }
            }
          },

          _updateVDPUI: function (ui, act) {
            const ds = App.state.dataSource;
            if (!ds.isActive || !ds.workbook) {
              ui("noDataSourceTip").show(true);
              ui("bindControls").show(false);
              return;
            }

            ui("noDataSourceTip").show(false);
            ui("bindControls").show(true);

            const sheetSel = ui("bindSheet").el;
            if (sheetSel) {
              const targetSheet = (act.dataBinding && act.dataBinding.sheet) || ds.currentSheet;
              sheetSel.innerHTML = "";
              ds.sheetNames.forEach((s) => sheetSel.add(new Option(s, s)));
              sheetSel.value = targetSheet;

              let headers = [];
              if (targetSheet === ds.currentSheet) {
                headers = ds.headers;
              } else {
                try {
                  const ws = ds.workbook.Sheets[targetSheet];
                  if (ws) {
                    const json = XLSX.utils.sheet_to_json(ws, {
                      header: 1,
                    });
                    if (json.length > 0) headers = json[0].map((h) => String(h || "").trim());
                  }
                } catch (e) {}
              }

              const fieldSel = ui("bindField").el;
              if (fieldSel) {
                fieldSel.innerHTML = "";
                if (headers.length === 0) fieldSel.add(new Option("无字段", ""));
                else headers.forEach((f) => fieldSel.add(new Option(f, f)));
                fieldSel.value = (act.dataBinding && act.dataBinding.field) || "";
              }
            }
          },
          updateLayerList: function () {
            const list = document.getElementById("layerList");
            if (!list) return;
            list.innerHTML = "";

            const isLabelPreview = App.state.paperType === "label" && App.state.label.mode === "preview";

            let objs = [];
            let bgObj = null;

            if (isLabelPreview) {
              const designData = App.state.label.designContent;
              if (designData) {
                objs = (designData.objects || []).filter((o) => !o.isGrid).reverse();
                bgObj = designData.backgroundImage;
              }
            } else {
              objs = App.canvas
                .getObjects()
                .filter((o) => !o.isGrid)
                .reverse();
              bgObj = App.canvas.backgroundImage;
            }

            const activeRaw = App.canvas.getActiveObject();
            let activeObjs = [];
            if (!isLabelPreview && activeRaw) {
              activeObjs = activeRaw.type === "activeSelection" && activeRaw._objects ? activeRaw._objects : [activeRaw];
            }

            const renderItem = (config) => {
              const { icon, name, obj, isBg } = config;

              const isSelected = !isLabelPreview && (isBg ? App.state.editingBackground : activeObjs.includes(obj));

              const div = document.createElement("div");

              const cursorClass = isLabelPreview ? "cursor-default" : "cursor-pointer";

              const opacityClass = isLabelPreview ? "opacity-90" : "";

              const baseClass = `layer-item flex items-center justify-between px-3 py-2.5 border-b border-gray-100 last:border-b-0 text-xs transition-all select-none group border-l-4 ${cursorClass} ${opacityClass}`;
              const activeClass = "bg-red-50 border-l-red-500 text-red-600 font-bold";
              const normalClass = "bg-white border-l-transparent text-slate-600 hover:bg-gray-50";

              div.className = `${baseClass} ${isSelected ? activeClass : normalClass}`;

              if (!isBg && !isLabelPreview) div.setAttribute("draggable", "true");

              const deleteBtnHtml = `
                <button class="del-btn w-6 h-6 flex items-center justify-center rounded text-gray-400 hover:text-red-600 hover:bg-red-100 opacity-0 group-hover:opacity-100 transition-all shrink-0" title="删除">
                    <i class="ph ph-trash"></i>
                </button>`;

              div.innerHTML = `
                  <div class="flex items-center gap-2.5 overflow-hidden pointer-events-none flex-1">
                      <i class="ph ${icon} text-lg shrink-0 opacity-80"></i>
                      <span class="truncate">${name}</span>
                  </div>
                  ${deleteBtnHtml}
              `;

              if (!isLabelPreview) {
                div.fabricObj = obj;
                div.onclick = (e) => {
                  if (isBg) {
                    App.canvas.discardActiveObject();
                    App.canvas.requestRenderAll();
                    App.state.editingBackground = true;
                  } else {
                    App.state.editingBackground = false;
                    if (e.ctrlKey || e.metaKey) {
                      const idx = activeObjs.indexOf(obj);
                      let newSel = idx > -1 ? activeObjs.filter((o) => o !== obj) : [...activeObjs, obj];
                      if (newSel.length > 1) {
                        const sel = new fabric.ActiveSelection(newSel, { canvas: App.canvas });
                        App.canvas.setActiveObject(sel);
                      } else if (newSel.length === 1) {
                        App.canvas.setActiveObject(newSel[0]);
                      } else {
                        App.canvas.discardActiveObject();
                      }
                    } else {
                      App.canvas.setActiveObject(obj);
                    }
                  }
                  App.canvas.requestRenderAll();
                  this.updateInspector();
                };

                div.ondblclick = (e) => {
                  e.preventDefault();
                  if (!isSelected) div.click();
                  App.ui.switchTab("props");
                };

                if (!isBg) {
                  div.addEventListener("dragstart", (e) => {
                    div.classList.add("dragging");
                    e.dataTransfer.effectAllowed = "move";
                    if (!isSelected) {
                      App.canvas.setActiveObject(obj);
                      App.canvas.requestRenderAll();
                    }
                  });
                  div.addEventListener("dragend", () => {
                    div.classList.remove("dragging");
                    this._finalizeLayerOrder();
                  });
                }
              }

              const delBtn = div.querySelector(".del-btn");
              if (delBtn) {
                delBtn.onclick = (e) => {
                  e.stopPropagation();

                  if (isLabelPreview) {
                    const content = App.state.label.designContent;
                    if (isBg) {
                      delete content.backgroundImage;
                    } else {
                      if (content && content.objects) {
                        const idx = content.objects.indexOf(obj);
                        if (idx > -1) {
                          content.objects.splice(idx, 1);
                        }
                      }
                    }

                    App.label.renderPreview();
                    this.updateLayerList();
                    Utils.toast("已在预览中删除图层");
                  } else {
                    if (isBg) {
                      App.paper.clearBackground();
                    } else {
                      App.canvas.remove(obj);
                      App.canvas.discardActiveObject();
                      App.history.saveState();
                      App.state.editingBackground = false;
                      this.updateInspector();
                    }
                  }
                };
              }

              return div;
            };

            objs.forEach((o) => {
              let icon = "ph-square";
              let label = o.type;

              const checkType = (typeStr) => o.type === typeStr;

              if (o.isBarcode) {
                icon = "ph-barcode";
                label = "条码";
              } else if (o.isTable) {
                icon = "ph-table";
                label = "表格";
              } else if ((o.type || "").includes("text")) {
                icon = "ph-text-t";
                label = o.text ? o.text.substring(0, 12) : "文本";
              } else if (checkType("image")) {
                icon = "ph-image";
                label = "图片";
              } else if (checkType("line")) {
                icon = "ph-line-segment";
                label = "线条";
              } else if (["rect", "circle", "triangle"].includes(o.type)) {
                icon = "ph-shapes";
                label = "形状";
              } else if (checkType("group")) {
                icon = "ph-squares-four";
                label = "组合";
              }

              list.appendChild(
                renderItem({
                  icon,
                  name: label,
                  obj: o,
                  isBg: false,
                })
              );
            });

            if (bgObj) {
              list.appendChild(
                renderItem({
                  icon: "ph-image-square",
                  name: "【背景】图片",
                  obj: bgObj,
                  isBg: true,
                })
              );
            }

            if (!isLabelPreview) {
              list.ondragover = (e) => {
                e.preventDefault();
                const afterElement = this._getDragAfterElement(list, e.clientY);
                const draggable = document.querySelector(".dragging");
                if (!draggable) return;

                if (afterElement == null) {
                  const last = list.lastElementChild;
                  if (last && !last.getAttribute("draggable")) {
                    list.insertBefore(draggable, last);
                  } else {
                    list.appendChild(draggable);
                  }
                } else {
                  list.insertBefore(draggable, afterElement);
                }
              };
            }
          },
          switchTab: function (tabName) {
            const tabs = ["props", "layers", "data"];

            tabs.forEach((t) => {
              const btn = document.getElementById(`tabBtn-${t}`);
              const content = document.getElementById(`tabContent-${t}`);

              if (t === tabName) {
                btn.classList.add("bg-white", "text-slate-700", "border-red-600");
                btn.classList.remove("text-slate-500", "border-transparent", "hover:bg-gray-100");
                content.classList.remove("hidden");
              } else {
                btn.classList.remove("bg-white", "text-slate-700", "border-red-600");
                btn.classList.add("text-slate-500", "border-transparent", "hover:bg-gray-100");
                content.classList.add("hidden");
              }
            });

            if (tabName === "layers") {
              this.updateLayerList();
            }
          },

          updateBind: async function (key, val) {
            const act = App.canvas.getActiveObject();
            if (!act || !act.dataBinding) return;
            act.dataBinding[key] = val;
            const ds = App.state.dataSource;
            if (key === "sheet" && ds.workbook) {
              try {
                const worksheet = ds.workbook.Sheets[val];
                const json = XLSX.utils.sheet_to_json(worksheet, { header: 1 });
                const headers = json.length ? json[0].map((h) => String(h || "").trim()) : [];
                if (!headers.includes(act.dataBinding.field)) {
                  act.dataBinding.field = headers.length ? headers[0] : "";
                }
              } catch (e) {
                console.warn("Sheet switch error:", e);
              }
            }

            if (ds.isActive && ds.workbook) {
              const targetSheet = act.dataBinding.sheet;
              const targetField = act.dataBinding.field;
              if (!App.dataSource._sheetCache) App.dataSource._sheetCache = {};
              if (!App.dataSource._sheetCache[targetSheet]) {
                const ws = ds.workbook.Sheets[targetSheet];
                if (ws) {
                  App.dataSource._sheetCache[targetSheet] = XLSX.utils.sheet_to_json(ws, {
                    raw: false,
                    dateNF: "yyyy-mm-dd",
                    defval: "",
                  });
                }
              }

              const dataList = App.dataSource._sheetCache[targetSheet];
              const pageIndex = App.state.currentDataIndex || 0;
              let newRawValue = "";
              if (dataList && dataList.length > 0) {
                const safeIndex = Math.min(pageIndex, dataList.length - 1);
                const row = dataList[safeIndex];
                if (row) {
                  const rowVal = row[targetField];
                  newRawValue = rowVal !== undefined && rowVal !== null ? String(rowVal) : "";
                }
              } else {
                newRawValue = `{${targetField}}`;
              }

              if (act.type === "image") {
                await App.dataSource._updateImageAsync(act, newRawValue);
                App.canvas.requestRenderAll();
              } else {
                act.rawContent = newRawValue;
                App.content.render(act);
              }
            }
            this.updateInspector();
            App.history.saveState();
          },

          refreshSharedSelectForBarcode: function () {
            const select = document.getElementById("bcSharedSelect");
            const act = App.canvas.getActiveObject();
            const currentRefId = act ? act.refId : "";
            select.innerHTML = '<option value="">选择共享字段</option>';
            const keys = App.content.getAvailableSharedIds();
            if (keys.length === 0) {
              const opt = document.createElement("option");
              opt.text = "(暂无可用字段)";
              opt.disabled = true;
              select.add(opt);
            }

            keys.forEach((key) => {
              const opt = document.createElement("option");
              opt.value = key;
              opt.text = key;
              if (key === currentRefId) opt.selected = true;
              select.add(opt);
            });
          },
          _getDragAfterElement: function (container, y) {
            const draggableElements = [...container.querySelectorAll('.layer-item[draggable="true"]:not(.dragging)')];

            return draggableElements.reduce(
              (closest, child) => {
                const box = child.getBoundingClientRect();
                const offset = y - box.top - box.height / 2;
                if (offset < 0 && offset > closest.offset) {
                  return {
                    offset: offset,
                    element: child,
                  };
                } else {
                  return closest;
                }
              },
              {
                offset: Number.NEGATIVE_INFINITY,
              }
            ).element;
          },
          _replaceObject: function (oldObj, newObj) {
            const canvas = App.canvas;
            const idx = canvas.getObjects().indexOf(oldObj);
            if (idx === -1) return;
            const wasActive = canvas.getActiveObject() === oldObj;
            newObj.dataBinding = oldObj.dataBinding;
            newObj.rawContent = oldObj.rawContent;
            newObj.isSerialNumber = oldObj.isSerialNumber;
            newObj.serialConfig = oldObj.serialConfig;
            newObj.isDynamicDate = oldObj.isDynamicDate;
            newObj.dateConfig = oldObj.dateConfig;
            newObj.isDynamicPageNum = oldObj.isDynamicPageNum;
            newObj.pageConfig = oldObj.pageConfig;
            const wasHistoryLocked = App.history.locked;
            App.history.locked = true;
            App.state.isReplacingObject = true;
            try {
              canvas.remove(oldObj);
              canvas.insertAt(newObj, idx, false);
              if (wasActive) {
                canvas.setActiveObject(newObj);
              }
            } finally {
              App.history.locked = wasHistoryLocked;
              App.state.isReplacingObject = false;
            }

            if (!wasHistoryLocked) {
              App.history.saveState();
            }
          },
          _finalizeLayerOrder: function () {
            const list = document.getElementById("layerList");
            const gridObjects = App.canvas.getObjects().filter((o) => o.isGrid);

            const domOrderObjs = Array.from(list.children)
              .map((div) => div.fabricObj)
              .filter((o) => o);
            const newStackOrder = domOrderObjs.reverse();
            App.canvas._objects = [...gridObjects, ...newStackOrder];
            App.canvas.requestRenderAll();
            App.history.saveState();
          },
          showLoading: (m) => {
            const el = document.getElementById("loadingOverlay");
            if (el) {
              el.querySelector("p").innerText = m;
              el.classList.remove("hidden");
            }
          },
          hideLoading: () => document.getElementById("loadingOverlay")?.classList.add("hidden"),
          toggleFullScreen: () => (!document.fullscreenElement ? document.documentElement.requestFullscreen() : document.exitFullscreen()),
          showModal: (id) => document.getElementById(id).classList.remove("hidden"),
          hideModal: (id) => document.getElementById(id).classList.add("hidden"),

          align: function (mode) {
            const activeObj = App.canvas.getActiveObject();
            const queue = App.state.selectionQueue;
            if (!activeObj || activeObj.type !== "activeSelection" || queue.length < 2) return Utils.toast("请按住 Shift 依次点击选择对象进行对齐", "info");

            const anchor = queue[0];
            App.canvas.discardActiveObject();
            const aRect = anchor.getBoundingRect(true);

            queue.forEach((obj) => {
              if (obj === anchor) return;
              const r = obj.getBoundingRect(true);
              let dx = 0,
                dy = 0;
              if (mode === "left") dx = aRect.left - r.left;
              else if (mode === "center") dx = aRect.left + aRect.width / 2 - (r.left + r.width / 2);
              else if (mode === "right") dx = aRect.left + aRect.width - (r.left + r.width);

              if (mode === "top") dy = aRect.top - r.top;
              else if (mode === "middle") dy = aRect.top + aRect.height / 2 - (r.top + r.height / 2);
              else if (mode === "bottom") dy = aRect.top + aRect.height - (r.top + r.height);

              if (dx !== 0 || dy !== 0) {
                obj.set({
                  left: obj.left + dx,
                  top: obj.top + dy,
                });
                obj.setCoords();
              }
            });
            App.canvas
              .setActiveObject(
                new fabric.ActiveSelection(queue, {
                  canvas: App.canvas,
                })
              )
              .requestRenderAll();
            App.history.saveState();
          },

          alignObject: function (mode) {
            const act = App.canvas.getActiveObject();
            if (!act) return;
            const cfg = App.paper.getSettings();
            const areaL = cfg.marginLeft,
              areaR = App.state.baseWidth - cfg.marginRight;
            const areaT = cfg.marginTop,
              areaB = App.state.baseHeight - cfg.marginBottom;
            const r = act.getBoundingRect(true);
            let dx = 0,
              dy = 0;

            if (mode === "left") dx = areaL - r.left;
            else if (mode === "centerH") dx = areaL + (areaR - areaL) / 2 - (r.left + r.width / 2);
            else if (mode === "right") dx = areaR - (r.left + r.width);
            else if (mode === "top") dy = areaT - r.top;
            else if (mode === "middle") dy = areaT + (areaB - areaT) / 2 - (r.top + r.height / 2);
            else if (mode === "bottom") dy = areaB - (r.top + r.height);

            if (dx !== 0 || dy !== 0) {
              act
                .set({
                  left: act.left + dx,
                  top: act.top + dy,
                })
                .setCoords();
              App.canvas.requestRenderAll();
              this.updateGeo(null, null, act);
              App.history.saveState();
            }
          },

          distribute: function (mode) {
            const act = App.canvas.getActiveObject();
            if (!act || act.type !== "activeSelection" || act.getObjects().length < 3) return Utils.toast("至少需要3个元素", "info");
            const objs = act.getObjects();
            App.canvas.discardActiveObject();
            const isH = mode === "horizontal";
            objs.sort((a, b) => (isH ? a.left - b.left : a.top - b.top));
            const first = objs[0],
              last = objs[objs.length - 1];
            const getC = (o) => (isH ? o.getCenterPoint().x : o.getCenterPoint().y);
            const step = (getC(last) - getC(first)) / (objs.length - 1);

            objs.forEach((o, i) => {
              if (i > 0 && i < objs.length - 1) o.set(isH ? "left" : "top", (isH ? o.left : o.top) + (getC(first) + step * i - getC(o))).setCoords();
            });
            App.canvas
              .setActiveObject(
                new fabric.ActiveSelection(objs, {
                  canvas: App.canvas,
                })
              )
              .requestRenderAll();
            this.updateInspector();
            App.history.saveState();
          },
        },

        // --- IO (导入/导出) ---
        io: {
          _getFontCss: () =>
            [...document.styleSheets]
              .flatMap((s) => {
                try {
                  return [...s.cssRules].filter((r) => r.type === CSSRule.FONT_FACE_RULE).map((r) => r.cssText);
                } catch {
                  return [];
                }
              })
              .join(""),
          _createPrintIframe: function (content, css = "") {
            const id = "print-iframe-sandbox";
            let f = document.getElementById(id);
            if (f) f.remove();
            f = document.createElement("iframe");
            f.id = id;
            f.style.cssText = "position:fixed;top:0;opacity:0;pointer-events:none;";
            document.body.appendChild(f);
            const doc = f.contentWindow.document;
            doc.open();
            doc.write(
              `<html><head><style>@page{size:${App.state.currentPaper.w}mm ${App.state.currentPaper.h}mm;margin:0}body{margin:0;display:flex;justify-content:center}${css}</style></head><body>${content}</body></html>`
            );
            doc.close();
          },

          // 打印
          print: async function () {
            const updateTasks = App.canvas.getObjects().map(async (o) => {
              if (o.isDynamicDate && o.dateConfig) {
                o.rawContent = Utils.formatDate(new Date(), null, o.dateConfig);
                return App.content.render(o);
              }
            });
            await Promise.all(updateTasks);
            App.canvas.requestRenderAll();
            const isLabelDesign = App.state.paperType === "label" && App.state.label.mode === "design";
            const isLabelPreview = App.state.paperType === "label" && App.state.label.mode === "preview";
            if (isLabelDesign) {
              App.label.enterPreview();
              await new Promise((r) => setTimeout(r, 100));
            }

            const totalPages = App.dataSource.calculateTotalPages();
            const shouldBatch = totalPages > 1 && !App.state.printCurrentOnly;
            const originalIndex = App.state.currentDataIndex;
            const originalLabelPage = App.state.label.previewPage || 0;
            const loopCount = shouldBatch ? totalPages : 1;
            const { w, h } = App.state.currentPaper;
            let allPagesHtml = "";
            try {
              for (let i = 0; i < loopCount; i++) {
                if (shouldBatch) {
                  if (isLabelPreview || isLabelDesign) {
                    App.state.label.previewPage = i;
                    await App.label.renderPreview();
                  } else {
                    await App.dataSource.renderPage(i);
                  }
                } else {
                  if (isLabelPreview) await App.label.renderPreview();
                }

                const vC = await App.vector.getExportCanvas(false);
                vC.setViewportTransform([1, 0, 0, 1, 0, 0]);
                const svg = vC.toSVG({
                  suppressPreamble: true,
                  viewBox: {
                    x: 0,
                    y: 0,
                    width: App.state.baseWidth,
                    height: App.state.baseHeight,
                  },
                });
                vC.dispose();
                allPagesHtml += `
        <div style="position: relative; width: ${w}mm; height: ${h}mm; overflow: hidden; break-after: page; page-break-after: always;">
          ${svg}
        </div>
      `;
              }

              allPagesHtml += `<script>setTimeout(() => { window.print(); }, 500);<\/script>`;
              const css = this._getFontCss() + " body { display: block !important; margin: 0; } @page { margin: 0; }";
              this._createPrintIframe(allPagesHtml, css);
            } catch (e) {
              console.error(e);
              Utils.toast("打印生成失败: " + e.message, "error");
            } finally {
              if (shouldBatch) {
                if (isLabelPreview || isLabelDesign) {
                  App.state.label.previewPage = originalLabelPage;
                  await App.label.renderPreview();
                } else {
                  App.dataSource.renderPage(originalIndex);
                }
              }
              App.ui.hideLoading();
            }
          },
          //导出pdf
          exportPDF: async function () {
            const btn = document.querySelector('button[onclick="App.io.exportPDF()"]');
            const oldTxt = btn ? btn.innerHTML : "";
            if (btn) {
              btn.disabled = true;
              btn.innerHTML = `<i class="ph ph-spinner animate-spin"></i> 处理中...`;
            }

            const originalIndex = App.state.currentDataIndex;
            const originalLabelPage = App.state.label.previewPage || 0;
            let shouldBatch = false;
            let isLabelPreview = false;
            try {
              const updateTasks = App.canvas.getObjects().map(async (o) => {
                if (o.isDynamicDate && o.dateConfig) {
                  o.rawContent = Utils.formatDate(new Date(), null, o.dateConfig);
                  return App.content.render(o);
                }
              });
              await Promise.all(updateTasks);
              App.canvas.requestRenderAll();
              const isLabelDesign = App.state.paperType === "label" && App.state.label.mode === "design";
              if (isLabelDesign) {
                App.label.enterPreview();
                await new Promise((r) => setTimeout(r, 100));
              }

              isLabelPreview = App.state.paperType === "label" && App.state.label.mode === "preview";
              const totalPages = App.dataSource.calculateTotalPages();
              shouldBatch = totalPages > 1 && !App.state.printCurrentOnly;
              const loopCount = shouldBatch ? totalPages : 1;
              const { w, h } = App.state.currentPaper;
              const orientation = w > h ? "l" : "p";
              const pdf = new window.jspdf.jsPDF({
                orientation: orientation,
                unit: "mm",
                format: [w, h],
                compress: true,
              });
              const settings = App.paper.getSettings();
              const typeLabel = App.paper.defaults[settings.type]?.label || "设计稿";
              for (let i = 0; i < loopCount; i++) {
                if (shouldBatch) {
                  if (isLabelPreview) {
                    App.state.label.previewPage = i;
                    await App.label.renderPreview();
                  } else {
                    await App.dataSource.renderPage(i);
                  }
                }

                const vC = await App.vector.getExportCanvas(true);
                vC.setViewportTransform([1, 0, 0, 1, 0, 0]);
                const svg = vC.toSVG({
                  suppressPreamble: true,
                  viewBox: {
                    x: 0,
                    y: 0,
                    width: App.state.baseWidth,
                    height: App.state.baseHeight,
                  },
                });
                vC.dispose();
                if (i > 0) pdf.addPage([w, h], orientation);
                await pdf.svg(new DOMParser().parseFromString(svg, "image/svg+xml").documentElement, {
                  x: 0,
                  y: 0,
                  width: w,
                  height: h,
                });
              }

              const fileName = `${typeLabel}_${Date.now()}.pdf`;
              pdf.save(fileName);
              Utils.toast(`PDF 导出成功 (${loopCount} 页)`);
            } catch (e) {
              console.error(e);
              Utils.toast("导出失败: " + e.message, "error");
            } finally {
              if (shouldBatch) {
                if (isLabelPreview) {
                  App.state.label.previewPage = originalLabelPage;
                  await App.label.renderPreview();
                } else {
                  App.dataSource.renderPage(originalIndex);
                }
              }

              App.ui.hideLoading();
              if (btn) {
                btn.disabled = false;
                btn.innerHTML = oldTxt;
              }
            }
          },

          saveProject: function () {
            const settings = App.paper.getSettings();
            const fitLabelEl = document.getElementById("fitLabelSize");
            if (fitLabelEl) {
              settings.fitLabelSize = fitLabelEl.checked;
              if (settings.fitLabelSize && settings.type === "label") {
                const val = (id) => parseFloat(document.getElementById(id)?.value) || 0;
                const intVal = (id) => parseInt(document.getElementById(id)?.value) || 1;
                settings.marginTop = val("marginTop") * CONFIG.MM_TO_PX;
                settings.marginBottom = val("marginBottom") * CONFIG.MM_TO_PX;
                settings.marginLeft = val("marginLeft") * CONFIG.MM_TO_PX;
                settings.marginRight = val("marginRight") * CONFIG.MM_TO_PX;
                settings.labelGapH = val("labelGapH");
                settings.labelGapV = val("labelGapV");
                settings.labelCols = intVal("labelCols");
                settings.labelRows = intVal("labelRows");
              }
            }

            let canvasData;
            if (App.state.paperType === "label" && App.state.label.mode === "preview") {
              canvasData = typeof App.state.label.designContent === "string" ? JSON.parse(App.state.label.designContent) : App.state.label.designContent;
            } else {
              canvasData = App.canvas.toJSON(CUSTOM_PROPS);
              canvasData.objects = canvasData.objects.filter((o) => !o.isGrid);
            }

            if (canvasData.objects) {
              canvasData.objects.forEach((obj) => {
                if (obj.type === "image" && obj.dataBinding && obj.src && obj.src.startsWith("blob:")) {
                  obj.src = "";
                }
              });
            }

            const dsState = App.state.dataSource;
            const dsMeta =
              dsState.isActive && dsState.fileHandleId
                ? {
                    fileName: dsState.fileName,
                    currentSheet: dsState.currentSheet,
                    fileHandleId: dsState.fileHandleId,
                    imgDirId: dsState.imgDirId,
                  }
                : null;

            const typeLabel = App.paper.defaults[settings.type]?.label || "设计稿";

            const blob = new Blob(
              [
                JSON.stringify({
                  version: "4.2",
                  timestamp: new Date().toISOString(),
                  settings: settings,
                  paperSize: document.getElementById("paperSize").value,
                  thumbnail: App.canvas.toDataURL({
                    format: "png",
                    multiplier: 0.5,
                  }),
                  canvasData: canvasData,
                  dataSource: dsMeta,
                }),
              ],
              {
                type: "application/json",
              }
            );

            const a = document.createElement("a");
            a.href = URL.createObjectURL(blob);
            a.download = `${typeLabel}_${Date.now()}.paper`;
            a.click();
            URL.revokeObjectURL(a.href);
            Utils.toast("项目已保存");
            App.state.hasUnsavedChanges = false;
          },

          loadProjectData: function (data) {
            try {
              if (data.settings) {
                const s = data.settings;
                const setV = (id, v) => document.getElementById(id) && (document.getElementById(id).value = v);
                const setC = (id, v) => document.getElementById(id) && (document.getElementById(id).checked = v);

                setV("paperType", s.type || "ruled");

                if (s.marginTop !== undefined) setV("marginTop", Math.round(Utils.px2mm(s.marginTop)));
                if (s.marginBottom !== undefined) setV("marginBottom", Math.round(Utils.px2mm(s.marginBottom)));
                if (s.marginLeft !== undefined) setV("marginLeft", Math.round(Utils.px2mm(s.marginLeft)));
                if (s.marginRight !== undefined) setV("marginRight", Math.round(Utils.px2mm(s.marginRight)));

                setV("rowCount", s.rowCount);
                setV("gridColor", s.gridColor);
                setV("strokeWidth", s.strokeWidth);
                setV("paperBgColor", s.paperBgColor || "#ffffff");
                if (s.customW) setV("customW", s.customW);
                if (s.customH) setV("customH", s.customH);
                if (s.paperOrientation !== undefined) setC("paperOrientation", s.paperOrientation);

                if (s.type === "label") {
                  if (s.labelWidth) setV("labelWidth", s.labelWidth);
                  if (s.labelHeight) setV("labelHeight", s.labelHeight);
                  if (s.labelCols) setV("labelCols", s.labelCols);
                  if (s.labelRows) setV("labelRows", s.labelRows);

                  if (s.labelGapH !== undefined) setV("labelGapH", s.labelGapH);
                  if (s.labelGapV !== undefined) setV("labelGapV", s.labelGapV);

                  if (s.labelQuantity) setV("labelQuantity", s.labelQuantity);
                  if (s.showCropMarks !== undefined) setC("showCropMarks", s.showCropMarks);

                  if (s.fitLabelSize !== undefined) setC("fitLabelSize", s.fitLabelSize);
                }

                setC("doubleFirst", s.doubleFirst);
                setC("doubleLast", s.doubleLast);
                setC("gridDashed", s.gridDashed);
                setV("gridDashArray", s.gridDashArray);
                setC("ruledClosed", !!s.ruledClosed);
                setC("ruledClosedDouble", !!s.ruledClosedDouble);
                setC("paperDual", !!s.dual);
                setC("doubleBorder", s.doubleBorder !== undefined ? s.doubleBorder : true);

                if (s.type === "english") {
                  setV("englishOffset", Utils.px2mm(s.englishOffset || 0).toFixed(1));
                  setV("englishLineGap", Utils.px2mm(s.englishLineGap || 6).toFixed(1));
                  setV("englishGroupGap", Utils.px2mm(s.englishGroupGap || 6).toFixed(1));
                }

                setV("columnCount", s.columnCount || 12);
                setV("gridColumns", s.gridColumns || 24);
                setV("squareDash", s.squareDash || 4);

                if (s.type === "music") {
                  setV("staffCount", s.staffCount || 8);
                  setV("staffLineCount", s.staffLineCount || 5);
                }
                setV("staffLineGap", Utils.px2mm(s.staffLineGap || 3).toFixed(1));
                setV("staffGroupGap", Utils.px2mm(s.staffGroupGap || 12).toFixed(1));

                if (["tianzige", "mizige", "huizige", "jiugongge"].includes(s.type)) {
                  setV("tianSize", Utils.px2mm(s.tianSize || 20).toFixed(1));
                  setV("tianInnerScale", s.tianInnerScale ?? 0.4);
                  if (s.type === "huizige") {
                    setV("huiInnerW", Utils.px2mm(s.huiInnerW || 10).toFixed(1));
                    setV("huiInnerH", Utils.px2mm(s.huiInnerH || 10).toFixed(1));
                  }
                  if (s.type === "jiugongge") {
                    setV("jiuCols", s.jiuCols || 3);
                    setV("jiuRows", s.jiuRows || 3);
                  }
                }

                if (s.type === "dots") {
                  setV("dotSpace", Utils.px2mm(s.dotSpace || 5).toFixed(1));
                  setV("dotSize", Utils.px2mm(s.dotSize || 1).toFixed(1));
                  setC("dotStagger", !!s.dotStagger);
                }

                if (s.type === "triangle" || s.type === "hexagon") {
                  setV("geoSize", Utils.px2mm(s.geoSize || 10).toFixed(1));
                }

                if (data.paperSize) setV("paperSize", data.paperSize);
              }

              App.dataSource.syncFromProject(data.dataSource);

              if (data.dataSource && data.dataSource.imgDirId) {
                App.dataSource.restoreImageDir(data.dataSource.imgDirId);
              }
              App.paper.changeType(document.getElementById("paperType").value || "ruled", false);
              App.paper.updateSize();

              App.canvas.clear();
              const done = () => {
                if (App.state.paperType === "label") {
                  App.state.label.mode = "design";
                  App.state.label.designContent = null;
                  App.label.updateToggleButtonUI();
                }
                App.paper.drawGrid();
                App.ui.hideModal("welcomeModal");
                App.ui.updateLayerList();

                App.canvas.getObjects().forEach((o) => {
                  if (o.isDynamicDate && o.dateConfig) {
                    o.rawContent = Utils.formatDate(new Date(), null, o.dateConfig);
                    App.content.render(o);
                  }
                });

                App.history.reset();
                App.state.hasUnsavedChanges = false;
                App.ui.hideLoading();
                Utils.toast("项目加载成功");
              };
              data.canvasData ? App.canvas.loadFromJSON(data.canvasData, done) : done();
            } catch (e) {
              console.error(e);
              Utils.toast("数据解析异常: " + e.message, "error");
              App.ui.hideLoading();
            }
          },

          loadProject: function (file) {
            if (!file) return;
            App.ui.showLoading("打开中...");
            const r = new FileReader();
            r.onload = (e) => {
              try {
                this.loadProjectData(JSON.parse(e.target.result));
              } catch {
                Utils.toast("文件格式错误", "error");
              } finally {
                App.ui.hideLoading();
              }
            };
            r.readAsText(file);
          },

          copy: function () {
            const act = App.canvas.getActiveObject();
            if (act) {
              act.clone((c) => {
                App.state.clipboard = c;
                App.state.pasteCount = 0;
              }, CUSTOM_PROPS);
            }
          },

          paste: function () {
            if (!App.state.clipboard) return;
            App.state.pasteCount++;

            App.state.clipboard.clone((c) => {
              App.canvas.discardActiveObject();

              c.set({
                left: c.left + 20 * App.state.pasteCount,
                top: c.top + 20 * App.state.pasteCount,
                evented: true,
              });

              if (c.dataBinding) {
                c.dataBinding = JSON.parse(JSON.stringify(c.dataBinding));
              }
              if (c.dateConfig) c.dateConfig = JSON.parse(JSON.stringify(c.dateConfig));
              if (c.serialConfig) c.serialConfig = JSON.parse(JSON.stringify(c.serialConfig));
              if (c.barcodeConfig) c.barcodeConfig = JSON.parse(JSON.stringify(c.barcodeConfig));

              if (c.syncMode === "share" && c.sharedId) {
                c.syncMode = "ref";
                Utils.toast("已粘贴为引用对象");
              }

              if (c.isTable && c.tableData) {
                c.tableData = JSON.parse(JSON.stringify(c.tableData));
              }
              if (c.isSmartRect && c.cornerConfig) {
                c.cornerConfig = JSON.parse(JSON.stringify(c.cornerConfig));
              }

              if (c.type === "activeSelection") {
                c.canvas = App.canvas;
                c.forEachObject((o) => {
                  if (o.syncMode === "share" && o.sharedId) {
                    o.syncMode = "ref";
                  }
                  App.canvas.add(o);
                });
                c.setCoords();
              } else {
                App.canvas.add(c);
              }

              App.canvas.setActiveObject(c);

              if (c.syncMode === "ref" && c.sharedId) {
                App.ui.applyRefId(c.sharedId);
              }

              App.canvas.requestRenderAll();
              App.ui.updateLayerList();
              App.ui.updateInspector();
              App.history.saveState();
            }, CUSTOM_PROPS);
          },
        },
        // 内容与渲染管理器 ---
        content: {
          parseVariables: function (text) {
            if (!text) return "";
            const str = String(text);
            return str.replace(/\{([^}]+)\}/g, (match, key) => {
              const source = this.findObjectBySharedId(key);
              if (source) {
                return this.compute(source, true);
              }
              return match;
            });
          },
          compute: function (obj, isRecursiveCall = false) {
            if (!obj) return "";
            if (isRecursiveCall && obj._isComputing) return obj.rawContent || "";
            obj._isComputing = true;
            let raw = "";
            if (obj.syncMode === "ref" && obj.refId) {
              const parent = this.findObjectBySharedId(obj.refId);
              raw = parent ? this.compute(parent, true) : "{引用丢失}";
            } else {
              raw = String(obj.rawContent !== undefined ? obj.rawContent : obj.text || "");
            }

            let parsedRaw = this.parseVariables(raw);

            let myPre = obj.prefixRaw !== undefined ? obj.prefixRaw : obj.prefix || "";
            let mySuf = obj.suffixRaw !== undefined ? obj.suffixRaw : obj.suffix || "";
            myPre = this.parseVariables(myPre);
            mySuf = this.parseVariables(mySuf);
            obj._isComputing = false;
            return myPre + parsedRaw + mySuf;
          },

          findObjectBySharedId: function (id) {
            if (!id) return null;
            const objs = App.canvas.getObjects();
            return objs.find((o) => o.sharedId === id && o.syncMode === "share");
          },

          render: async function (obj) {
            if (!obj) return;
            if (obj._isRendering) return;
            obj._isRendering = true;
            try {
              const finalString = this.compute(obj);
              if (obj.isBarcode) {
                const newConfig = { ...obj.barcodeConfig, text: finalString };
                const newObj = await App.barcode.createOrUpdate(obj, newConfig);
                App.ui._replaceObject(obj, newObj);
              } else if (["i-text", "textbox", "text"].includes(obj.type)) {
                if (obj.text !== finalString) {
                  obj.set("text", finalString);
                }
              }

              if (obj.syncMode === "share" && obj.sharedId) {
                this.updateDependents(obj.sharedId);
              }
            } finally {
              obj._isRendering = false;
            }

            obj.setCoords();
            App.canvas.requestRenderAll();
          },

          updateDependents: function (sharedId) {
            const objs = App.canvas.getObjects();
            const variablePattern = new RegExp(`\\{${sharedId}\\}`);
            objs.forEach((o) => {
              if (o.syncMode === "ref" && o.refId === sharedId) {
                this.render(o);
                return;
              }

              const p = o.prefixRaw || o.prefix || "";
              const s = o.suffixRaw || o.suffix || "";
              const t = o.rawContent || o.text || "";
              if (variablePattern.test(p) || variablePattern.test(s) || variablePattern.test(t)) {
                this.render(o);
              }
            });
          },

          setRawContent: function (obj, val) {
            if (!obj) return;
            if (obj.syncMode === "ref" && obj.refId) {
              const parent = this.findObjectBySharedId(obj.refId);
              if (parent) {
                this.setRawContent(parent, val);
                return;
              } else {
                Utils.toast("关联源不存在，已转为静态文本");
                obj.syncMode = "none";
                obj.refId = null;
              }
            }

            obj.rawContent = val;
            this.render(obj);
            App.history.saveState();
          },

          setAffix: function (obj, type, val) {
            if (!obj) return;
            if (obj.rawContent === undefined || obj.rawContent === null) {
              let cleanText = String(obj.text || "");
              const oldPre = obj.prefixRaw !== undefined ? obj.prefixRaw : obj.prefix || "";
              const oldSuf = obj.suffixRaw !== undefined ? obj.suffixRaw : obj.suffix || "";
              if (oldPre && cleanText.startsWith(oldPre)) {
                cleanText = cleanText.substring(oldPre.length);
              }

              if (oldSuf && cleanText.endsWith(oldSuf)) {
                cleanText = cleanText.substring(0, cleanText.length - oldSuf.length);
              }

              obj.rawContent = cleanText;
            }

            if (type === "prefix") obj.prefixRaw = val;
            if (type === "suffix") obj.suffixRaw = val;
            obj[type] = val;
            this.render(obj);
            App.history.saveState();
          },

          getAvailableSharedIds: function () {
            const objs = App.canvas.getObjects();
            const ids = new Set();
            objs.forEach((o) => {
              if (o.syncMode === "share" && o.sharedId) {
                ids.add(o.sharedId);
              }
            });
            return Array.from(ids).sort();
          },

          getSharedValue: function (sharedId) {
            const sourceObj = this.findObjectBySharedId(sharedId);
            if (!sourceObj) return "";
            return this.compute(sourceObj);
          },
        },
        // --- 矢量导出 (Opentype.js) ---
        vector: {
          _fontCache: {},

          getFont: async function (fontFamily) {
            if (this._fontCache[fontFamily]) return this._fontCache[fontFamily];
            if (App.state.availabelFonts && App.state.availabelFonts.length > 0) {
              const localFontData = App.state.availabelFonts.find((f) => f.family === fontFamily);
              if (localFontData) {
                try {
                  const buffer = await (await localFontData.blob()).arrayBuffer();
                  const parsedFont = opentype.parse(buffer);
                  this._fontCache[fontFamily] = parsedFont;
                  return parsedFont;
                } catch (e) {
                  console.warn(`本地字体 ${fontFamily} 解析失败`, e);
                }
              }
            }
            if (this._fontCache["DEFAULT"]) return this._fontCache["DEFAULT"];
            return new Promise((resolve) => {
              opentype.load("./static/SourceHanSerifCN-Bold.ttf", (err, font) => {
                if (!err) {
                  this._fontCache["DEFAULT"] = font;
                  if (fontFamily) this._fontCache[fontFamily] = font;
                  resolve(font);
                } else {
                  resolve(null);
                }
              });
            });
          },

          _convertObj: async function (o) {
            if (o.type === "group" || o.isTable) {
              const newChildren = [];
              for (const child of o.getObjects()) newChildren.push(await this._convertObj(child));
              const props = o.toObject(["left", "top", "angle", "scaleX", "scaleY", "originX", "originY", "opacity", "fill", "stroke", "strokeWidth", "isTable", "tableData", "width", "height"]);
              const newGroup = new fabric.Group(newChildren, props);
              if (o.isTable) {
                newGroup.isTable = true;
                newGroup.tableData = o.tableData;
              }
              return newGroup;
            }

            if (["i-text", "text", "textbox"].includes(o.type)) {
              if (!o.text || !o.text.toString().trim()) return o;
              const font = await this.getFont(o.fontFamily);
              if (!font) return o;

              try {
                const textStr = o.text.toString();
                const fontSize = o.fontSize,
                  lineHeight = o.lineHeight || 1.16;
                const lines = textStr.split("\n");
                let pathData = "";
                let startY = -((lines.length - 1) * fontSize * lineHeight) / 2 + fontSize * 0.35;

                lines.forEach((line, i) => {
                  if (!line.trim()) return;
                  const lineWidth = font.getAdvanceWidth(line, fontSize);
                  let xOffset = -lineWidth / 2;
                  if (o.textAlign === "center") xOffset = -lineWidth / 2;
                  else if (o.textAlign === "right") xOffset = (o.type === "textbox" ? o.width / 2 : 0) - lineWidth;
                  else xOffset = o.type === "textbox" ? -o.width / 2 : -lineWidth / 2;

                  pathData += font.getPath(line, xOffset, startY + i * fontSize * lineHeight, fontSize).toPathData(2);
                });

                const path = new fabric.Path(pathData, {
                  ...o.toObject(["fill", "stroke", "strokeWidth", "opacity", "scaleX", "scaleY", "angle", "shadow", "originX", "originY", "left", "top", "width", "height"]),
                  objectCaching: false,
                  stroke: o.stroke || null,
                  fill: o.fill,
                });
                path.setPositionByOrigin(o.getCenterPoint(), "center", "center");
                return path;
              } catch (e) {
                return o;
              }
            }
            return o;
          },

          getExportCanvas: async function (convertText) {
            const originalBg = App.canvas.backgroundImage;
            let shouldHideBg = false;
            if (originalBg && originalBg.printBackground === false) {
              shouldHideBg = true;
              App.canvas.backgroundImage = null;
            }
            const json = App.canvas.toJSON(CUSTOM_PROPS);
            if (shouldHideBg) {
              App.canvas.backgroundImage = originalBg;
            }
            const grids = App.canvas
              .getObjects()
              .filter((o) => o.isGrid && !o.isCutLine)
              .map((o) => ({
                ...o.toObject(["stroke", "strokeWidth", "strokeDashArray", "x1", "y1", "x2", "y2"]),
                excludeFromExport: false,
              }));
            json.objects = [...grids, ...json.objects];

            const tC = new fabric.Canvas(null, {
              width: App.state.baseWidth,
              height: App.state.baseHeight,
              backgroundColor: App.paper.getSettings().paperBgColor,
            });
            return new Promise((resolve) => {
              tC.loadFromJSON(json, async () => {
                tC.getObjects().forEach((o) => {
                  if (["i-text", "text", "textbox"].includes(o.type)) {
                    // FIX: 使用 compute 方法来确保 prefix/suffix 中的共享变量 {xxx} 被正确解析
                    o.text = App.content.compute(o);
                  }
                });
                if (convertText) {
                  const savedBgImage = tC.backgroundImage;
                  const processedObjs = [];
                  for (const originalObj of tC.getObjects()) {
                    if (originalObj.isGrid) processedObjs.push(originalObj);
                    else processedObjs.push(await this._convertObj(originalObj));
                  }

                  tC.clear();

                  tC.setBackgroundColor(App.paper.getSettings().paperBgColor, () => {});

                  if (savedBgImage) {
                    tC.setBackgroundImage(savedBgImage, () => {});
                  }

                  processedObjs.forEach((o) => tC.add(o));
                }
                tC.renderAll();
                resolve(tC);
              });
            });
          },
        },
        // --- 标签纸管理器 ---
        label: {
          // 切换模式
          toggleMode: function () {
            if (App.state.paperType !== "label") return;

            if (App.state.label.mode === "design") {
              this.enterPreview();
            } else {
              this.enterDesign();
            }
          },
          enterPreview: function () {
            const json = App.canvas.toJSON(CUSTOM_PROPS);
            json.objects = json.objects.filter((o) => !o.isGrid);
            App.state.label.designContent = json;

            App.state.label.mode = "preview";

            const isSingleMode = document.getElementById("fitLabelSize")?.checked;
            if (isSingleMode) {
              App.state.label.previewPage = App.state.currentDataIndex || 0;
            } else {
              App.state.label.previewPage = 0;
            }

            App.paper.updateSize();
            this.updateToggleButtonUI();
          },

          enterDesign: function () {
            App.state.label.mode = "design";

            if (App.state.label.designContent) {
              App.canvas.loadFromJSON(App.state.label.designContent, () => {
                App.canvas.forEachObject((o) => {
                  o.selectable = true;
                  o.evented = true;
                  o.setCoords();
                });
                App.paper.updateSize();
                this.updateToggleButtonUI();

                App.ui.updateLayerList();

                const isSingleMode = document.getElementById("fitLabelSize")?.checked;
                if (isSingleMode) {
                  const page = App.state.label.previewPage || 0;
                  const ds = App.state.dataSource;

                  if (ds.isActive && page < ds.data.length) {
                    App.state.currentDataIndex = page;
                  }
                }

                App.dataSource.renderPage(App.state.currentDataIndex);
              });
            } else {
              App.paper.updateSize();
              this.updateToggleButtonUI();
              App.dataSource.renderPage(App.state.currentDataIndex);

              App.ui.updateLayerList();
            }
          },
          renderPreview: async function () {
            const wasHistoryLocked = App.history.locked;
            App.history.locked = true;
            App.canvas.renderOnAddRemove = false;

            try {
              App.canvas.clear();
              const cfg = App.paper.getSettings();
              App.canvas.setBackgroundColor(cfg.paperBgColor || "#ffffff");
              App.canvas.backgroundImage = null;

              const designJSON = App.state.label.designContent;
              if (!designJSON) return;

              const labelW = Utils.mm2px(cfg.labelWidth);
              const labelH = Utils.mm2px(cfg.labelHeight);
              const gapH = Utils.mm2px(cfg.labelGapH);
              const gapV = Utils.mm2px(cfg.labelGapV);
              const startX = cfg.marginLeft;
              const startY = cfg.marginTop;

              const ds = App.state.dataSource;
              let totalLabelCount = 0;

              if (ds.isActive && ds.data.length > 0) {
                totalLabelCount = ds.data.length * cfg.labelQuantity;
              } else {
                totalLabelCount = cfg.labelQuantity;
              }

              const itemsPerPage = Math.max(1, cfg.labelCols * cfg.labelRows);
              const totalPages = Math.ceil(totalLabelCount / itemsPerPage);

              if (typeof App.state.label.previewPage === "undefined") App.state.label.previewPage = 0;
              let currentPage = App.state.label.previewPage;
              if (currentPage >= totalPages) currentPage = Math.max(0, totalPages - 1);
              App.state.label.previewPage = currentPage;

              const startItemIndex = currentPage * itemsPerPage;
              let drawnCount = 0;

              for (let r = 0; r < cfg.labelRows; r++) {
                for (let c = 0; c < cfg.labelCols; c++) {
                  const globalIndex = startItemIndex + drawnCount;
                  if (globalIndex >= totalLabelCount) break;

                  const currentX = startX + c * (labelW + gapH);
                  const currentY = startY + r * (labelH + gapV);

                  const dataIndex = ds.isActive && ds.data.length > 0 ? Math.floor(globalIndex / cfg.labelQuantity) : globalIndex;

                  await this._cloneDesignTo(designJSON, currentX, currentY, dataIndex, currentPage, totalPages);
                  drawnCount++;
                }
              }

              if (cfg.showCropMarks) {
                const lineOpts = {
                  fill: "transparent",
                  stroke: "#60a5fa",
                  strokeWidth: 0.5,
                  strokeDashArray: [4, 4],
                  selectable: false,
                  evented: false,
                  excludeFromExport: false,
                  originX: "left",
                  originY: "top",
                  isGrid: true,
                };
                for (let r = 0; r < cfg.labelRows; r++) {
                  const yTop = startY + r * (labelH + gapV);
                  const yBottom = yTop + labelH;
                  const rowStartX = startX;
                  const rowEndX = startX + cfg.labelCols * labelW + (cfg.labelCols - 1) * gapH;
                  if (r > 0 || cfg.marginTop > 0.5) App.canvas.add(new fabric.Line([rowStartX, yTop, rowEndX, yTop], lineOpts));
                  if (r < cfg.labelRows - 1 || cfg.marginBottom > 0.5) App.canvas.add(new fabric.Line([rowStartX, yBottom, rowEndX, yBottom], lineOpts));
                }
                for (let c = 0; c < cfg.labelCols; c++) {
                  const xLeft = startX + c * (labelW + gapH);
                  const xRight = xLeft + labelW;
                  const colStartY = startY;
                  const colEndY = startY + cfg.labelRows * labelH + (cfg.labelRows - 1) * gapV;
                  if (c > 0 || cfg.marginLeft > 0.5) App.canvas.add(new fabric.Line([xLeft, colStartY, xLeft, colEndY], lineOpts));
                  if (c < cfg.labelCols - 1 || cfg.marginRight > 0.5) App.canvas.add(new fabric.Line([xRight, colStartY, xRight, colEndY], lineOpts));
                }
              }

              App.dataSource.updateNavUI(currentPage, totalPages, true);
            } finally {
              App.canvas.renderOnAddRemove = true;
              App.canvas.requestRenderAll();
              App.history.locked = wasHistoryLocked;
            }
          },

          _cloneDesignTo: function (json, x, y, dataIndex, currentPage, totalPages) {
            return new Promise(async (resolve) => {
              if (json.backgroundImage) {
                await new Promise((r) => {
                  fabric.Image.fromObject(json.backgroundImage, (img) => {
                    if (img) {
                      img.left += x;
                      img.top += y;

                      img.set({
                        selectable: false,
                        evented: false,
                        excludeFromExport: false,
                        globalCompositeOperation: "source-over",
                      });

                      App.canvas.add(img);
                      img.sendToBack();
                    }
                    r();
                  });
                });
              }

              fabric.util.enlivenObjects(json.objects, async (objs) => {
                const processing = objs.map(async (o) => {
                  o.set({
                    left: o.left + x,
                    top: o.top + y,
                  });

                  const ds = App.state.dataSource;
                  const hasData = ds.isActive && ds.data[dataIndex];

                  const prefix = o.prefix || "";
                  const suffix = o.suffix || "";

                  if (o.isDynamicPageNum && o.pageConfig) {
                    const pageNum = currentPage + (o.pageConfig.startFrom || 1);
                    const total = totalPages || 1;
                    const pageText = o.pageConfig.format.replace("{page}", pageNum).replace("{total}", total);

                    o.rawContent = pageText;

                    o.set("text", prefix + pageText + suffix);
                  }

                  if (o.isSerialNumber && o.serialConfig) {
                    const serialText = App.tools._calculateSerialNumber(o.serialConfig, dataIndex);
                    o.rawContent = serialText;

                    if (!o.isBarcode) {
                      o.set("text", prefix + serialText + suffix);
                    }
                  }

                  if (o.dataBinding && o.dataBinding.type === "variable" && hasData) {
                    const val = ds.data[dataIndex][o.dataBinding.field];
                    if (val !== undefined && val !== null) {
                      const valStr = String(val);
                      if (["i-text", "textbox", "text"].includes(o.type)) {
                        o.rawContent = valStr;

                        o.set("text", prefix + valStr + suffix);
                      }
                    }
                  }

                  if (o.isBarcode && o.dataBinding && o.dataBinding.type === "variable" && hasData) {
                    const val = ds.data[dataIndex][o.dataBinding.field];
                    if (val !== undefined && val !== null) {
                      try {
                        const newConfig = {
                          ...o.barcodeConfig,
                          text: String(val),
                        };

                        const newBarcodeObj = await App.barcode.createOrUpdate(o, newConfig);
                        o = newBarcodeObj;
                      } catch (err) {
                        console.warn("Label generation: Barcode error", err);
                      }
                    }
                  }

                  if (o.isTable && o.tableData && hasData) {
                    let tableChanged = false;
                    o.tableData.cells.forEach((row) => {
                      row.forEach((cell) => {
                        if (cell.dataBinding && cell.dataBinding.type === "variable") {
                          const val = ds.data[dataIndex][cell.dataBinding.field];
                          if (val !== undefined && val !== null) {
                            const valStr = String(val);

                            if (cell.text !== valStr) {
                              cell.text = valStr;
                              tableChanged = true;
                            }
                          }
                        }
                      });
                    });
                    if (tableChanged) {
                      const props = o.toObject(["left", "top", "scaleX", "scaleY", "angle", "opacity", "originX", "originY"]);
                      const newTableGroup = App.tableEditor.buildFabricTable(o.tableData);
                      newTableGroup.set(props);
                      o = newTableGroup;
                    }
                  }

                  o.set({
                    selectable: false,
                    evented: false,
                    lockMovementX: true,
                    lockMovementY: true,
                    lockRotation: true,
                    lockScalingX: true,
                    lockScalingY: true,
                  });

                  App.canvas.add(o);
                });

                await Promise.all(processing);
                resolve();
              });
            });
          },

          updateToggleButtonUI: function () {
            const btn = document.getElementById("labelModeToggle");
            const isLabel = App.state.paperType === "label";

            const toolbar = document.querySelector("header > div:nth-child(2)");

            if (!isLabel) {
              btn.classList.add("hidden");
              if (toolbar) toolbar.classList.remove("pointer-events-none");
              return;
            }

            btn.classList.remove("hidden");
            const icon = btn.querySelector("i");
            const span = btn.querySelector("span");

            if (App.state.label.mode === "design") {
              icon.className = "ph ph-eye text-base";
              span.innerText = "预览模式";
              if (toolbar) toolbar.classList.remove("pointer-events-none");
            } else {
              icon.className = "ph ph-pencil-simple text-base";
              span.innerText = "设计模式";
              if (toolbar) toolbar.classList.add("pointer-events-none");
            }
          },
        },
        // --- 模板系统 ---
        templates: {
          data: [],
          init: async function () {
            try {
              this.data = await (await fetch("./templates/templates.json")).json();
              const grid = document.getElementById("templateGrid");
              if (grid) {
                grid.innerHTML = "";
                this.data.forEach((t) => {
                  const d = document.createElement("div");
                  d.className = "template-card bg-white p-3 rounded-xl border border-gray-200 cursor-pointer transition flex flex-col gap-2";
                  d.innerHTML = `<div class="h-36 bg-gray-50 rounded-lg overflow-hidden flex items-center justify-center border border-gray-100">${
                    t.thumbnail ? `<img src="${t.thumbnail}" class="h-full w-auto object-contain">` : '<i class="ph ph-file-plus text-3xl text-gray-300"></i>'
                  }</div><div><h3 class="font-bold text-slate-700 text-sm">${t.name}</h3><p class="text-slate-400 text-xs">${t.desc || "无描述"}</p></div>`;
                  d.onclick = () => this.load(t.id);
                  grid.appendChild(d);
                });
              }
            } catch {
              Utils.toast("模板加载失败", "error");
            }
          },

          load: async function (id) {
            if (id === "blank_a4" || !this.data.find((i) => i.id === id)?.url) {
              App.dataSource.close();
              App.ui.showLoading("创建中...");
              setTimeout(() => {
                App.paper.changeType("blank", true);
                const defaults = {
                  paperSize: "A4",
                  paperOrientation: false,
                  marginTop: 25,
                  marginBottom: 25,
                  marginLeft: 20,
                  marginRight: 20,
                  paperBgColor: "#ffffff",
                };
                Object.entries(defaults).forEach(([k, v]) => {
                  const el = document.getElementById(k);
                  if (el) el.type === "checkbox" ? (el.checked = v) : (el.value = v);
                });
                App.paper.updateSize();
                App.canvas.clear();
                App.paper.drawPaper();
                App.ui.hideModal("welcomeModal");
                App.ui.updateLayerList();
                App.history.reset();
                App.ui.hideLoading();
              }, 200);
              return;
            }

            const t = this.data.find((i) => i.id === id);
            if (t?.url) {
              App.ui.showLoading("下载模板...");
              try {
                // 加载模板前也先清空当前数据源
                await App.dataSource.close();
                App.io.loadProjectData(await (await fetch(t.url)).json());
              } catch {
                Utils.toast("加载失败", "error");
                App.ui.hideLoading();
              }
            }
          },
        },

        //页面标尺
        ruler: {
          h: null,
          v: null,
          ctxH: null,
          ctxV: null,
          isEnabled: true,

          init: function () {
            this.h = document.getElementById("ruler-h");
            this.v = document.getElementById("ruler-v");
            if (!this.h || !this.v) return;
            this.ctxH = this.h.getContext("2d");
            this.ctxV = this.v.getContext("2d");
            this.draw();
          },

          draw: function (mouseX, mouseY) {
            if (!this.isEnabled || !this.h || !this.v) return;

            const dpr = window.devicePixelRatio || 1,
              thick = 20,
              zoom = App.state.zoom;
            const main = document.querySelector("main"),
              wrapper = document.getElementById("canvasWrapper");
            const w = main.clientWidth - thick,
              h = main.clientHeight - thick;

            [this.h, this.v].forEach((c, i) => {
              const size = i ? [thick, h] : [w, thick];

              if (c.width !== size[0] * dpr || c.height !== size[1] * dpr) {
                c.width = size[0] * dpr;
                c.height = size[1] * dpr;
                c.style.width = size[0] + "px";
                c.style.height = size[1] + "px";
              }
            });

            // 2. 计算标尺参数
            const mBox = main.getBoundingClientRect(),
              wBox = wrapper.getBoundingClientRect();
            const start = [wBox.left - mBox.left - thick, wBox.top - mBox.top - thick - 25]; // [水平偏移, 垂直偏移]
            const pxPerMm = CONFIG.MM_TO_PX * zoom;

            const step = pxPerMm < 0.5 ? 50 : pxPerMm < 2 ? 10 : pxPerMm < 4 ? 5 : 1;
            const showMid = step * 5 * pxPerMm > 45;

            const drawAxis = (ctx, isVert, len, offset) => {
              ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
              ctx.fillStyle = "#fff";
              ctx.fillRect(0, 0, isVert ? thick : len, isVert ? len : thick);
              ctx.beginPath();
              ctx.strokeStyle = "#e2e8f0";
              ctx.lineWidth = 1;
              isVert ? (ctx.moveTo(19.5, 0), ctx.lineTo(19.5, len)) : (ctx.moveTo(0, 19.5), ctx.lineTo(len, 19.5));
              ctx.stroke();

              ctx.fillStyle = ctx.strokeStyle = "#a5a5a5";
              ctx.font = "10px sans-serif";
              ctx.beginPath();
              const min = Math.floor(-offset / pxPerMm),
                max = Math.ceil((len - offset) / pxPerMm);

              for (let mm = Math.floor(min / step) * step; mm <= max; mm += step) {
                const pos = offset + mm * pxPerMm;
                const isMajor = mm % (step * 10) === 0,
                  isMid = mm % (step * 5) === 0;
                const tickLen = isMajor ? 10 : isMid ? 6 : 4;

                if (isVert) {
                  ctx.moveTo(thick, pos);
                  ctx.lineTo(thick - tickLen, pos);
                } else {
                  ctx.moveTo(pos, thick);
                  ctx.lineTo(pos, thick - tickLen);
                }

                if (isMajor || (isMid && showMid)) {
                  if (isVert) {
                    ctx.save();
                    ctx.translate(10, pos + 2);
                    ctx.rotate(-1.57);
                    ctx.fillText(mm, 2, 0);
                    ctx.restore();
                  } else ctx.fillText(mm, pos + 2, 10);
                }
              }
              ctx.stroke();
            };

            drawAxis(this.ctxH, false, w, start[0]);
            drawAxis(this.ctxV, true, h, start[1]);

            if (mouseX != null) {
              const drawC = (ctx, isV, pos, max) => {
                if (pos < 0 || pos > max) return;
                ctx.strokeStyle = "#e11d48";
                ctx.beginPath();
                isV ? (ctx.moveTo(0, pos), ctx.lineTo(thick, pos)) : (ctx.moveTo(pos, 0), ctx.lineTo(pos, thick));
                ctx.stroke();
              };
              drawC(this.ctxH, false, mouseX - mBox.left - thick, w);
              drawC(this.ctxV, true, mouseY - mBox.top - thick, h);
            }
          },
        },
      };
      window.onload = function () {
        App.init();
      };
    </script>
  </body>
</html>
